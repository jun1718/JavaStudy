예제모음
------------------------------------------------------------------------------------

======================================================================================================
*21.08.31_4회차(4강)
======================================================================================================












######################################################################################################
개념정리_논리연산자(eager, short circuit evaluation)

연산자마다 가능한연산이있음
예를들면 *라면 숫자형*숫자형 등은 가능하지만 *연산자의 피연산자로는 논리자료형을 지원하지 않는다.

#논리연산자의 피연산자에따른 역할변경
	-즉 논리연산자를 사용하려면 피연산자 모두 논리값이 와야한다.
정수 &(|) 정수: 비트연산
논리 &(|) 논리: 논리연산

#&논리곱
ture & true -> true
true & false -> false
false & true -> false
false & false -> false

#|논리합
ture | true -> true
true | false -> true
false | true -> true
false | false -> false


#논리곱에서 연산과정
	-short circuit evaluation(단락(축)평가): 좌항에서 결과가 판정나면 우항을 실행하지 않는다.
		(서킷 어바이유웨이션)
		-사용이유: 메모리를 절약하자
		-한개짜리 : 좌항에서 결과가 판정되도 우항을 실행한다.
	-eager evalution(열성적인평가, 이걸 어(굉장히작게)바이유웨이션)
	**** 참고
	파이썬(구글링https://yahwang.github.io/posts/55)
		-eager evalution : &/|
		-short circuit evalution : and/or
	java(구글링https://yahwang.github.io/posts/55)
		-eager evalution : &/|
		-short circuit evalution : &&/||
	c(구글링https://yahwang.github.io/posts/55)
		-eager evalution : 없음, 지원하지 않음
		-short circuit evalution : &&/||

		
1)& : FM, eager evaluation
	ex)논리값과 관계없이 ++b를 꼭해야하는경우

2)&&(short circuit) 
-좌항이 false면 우항을 실행하지않고 false.
-좌항이 true면 우항을 실행한다.

#논리합에서 연산과정
1)| : FM, eager evaluation


2)||(short circuit)
-좌항이 true면 우항을 실행하지않고 true
-좌항이 false면 우항을 실행하여 판별

######################################################################################################















######################################################################################################
예제1)논리연산자의 short circuit evaluation, eager evaluation 응용

1)현재 출력결과에서 두번째 y가 22가 아닌 21로 출력되도록 하라
2)b값을 2번의 출력 모두 20이 되도록 하라

<아래의 클래스에서  출력결과>
연산결과가 거짓입니다.
x: 10 y: 21
연산결과가 참입니다.
x: 10 y: 22
연산결과가 거짓입니다.
a: 10b: 21
연산결과가 참입니다.
a: 10b: 22


public class _1LogicalOperating {
	public static void main(String[] args) {
		int x = 10, y = 20;
		if ((x!=10) & (++y == 21)) {
			System.out.println("연산결과가 참입니다.");
		}
		else {
			System.out.println("연산결과가 거짓입니다.");
		}
		System.out.println("x: " + x + " y: " + y);
		
		if ((x==10)|(++y==21)) {
			System.out.println("연산결과가 참입니다.");
		}
		else {
			System.out.println("연산결과가 거짓입니다.");
		}
		System.out.println("x: " + x + " y: " + y);
		
		
		int a = 10; int b =20;
		if ((a!=10) & (++b == 21)) {
			System.out.println("연산결과가 참입니다.");
		}
		else {
			System.out.println("연산결과가 거짓입니다.");
		}
		System.out.println("a: " + a + "b: " +b);
		
		if ((a==10)|(++b==21)) {
			System.out.println("연산결과가 참입니다.");
		}
		else {
			System.out.println("연산결과가 거짓입니다.");
		}
		System.out.println("a: " + a + "b: " +b);
		
	}
}



######################################################################################################



답:



public class _1LogicalOperating {
	public static void main(String[] args) {
		int x = 10, y = 20;
		if ((x!=10) & (++y == 21)) {
			System.out.println("연산결과가 참입니다.");
		}
		else {
			System.out.println("연산결과가 거짓입니다.");
		}
		System.out.println("x: " + x + " y: " + y);
		
		if ((x==10)||(++y==21)) {
			System.out.println("연산결과가 참입니다.");
		}
		else {
			System.out.println("연산결과가 거짓입니다.");
		}
		System.out.println("x: " + x + " y: " + y);
		
		
		int a = 10; int b =20;
		if ((a!=10) && (++b == 21)) {
			System.out.println("연산결과가 참입니다.");
		}
		else {
			System.out.println("연산결과가 거짓입니다.");
		}
		System.out.println("a: " + a + "b: " +b);
		
		if ((a==10)||(++b==21)) {
			System.out.println("연산결과가 참입니다.");
		}
		else {
			System.out.println("연산결과가 거짓입니다.");
		}
		System.out.println("a: " + a + "b: " +b);
		
	}
}













######################################################################################################
개념정리_대입연산자

-대입연산자의 기본기호는 '='이고, 보다 발전된 대입 연산자는 x operand = a의 형태를 가지고 있으며 이는 x = x operand a와 같은
역할을 함
-대입연산자에는 =,+=,-=,*=,/=,%=,<<=,>>=,>>>=,&=,^=,|= 등이 있습니다.



public class _2AssignmentOperatorExample {
	public static void main(String[] args) {
		int a=5, b= 5;
		a+=3;  //a = a+3
		b=+ 3; //b = (+3)으로 인식되는거임
		System.out.println("a : "+a);
		System.out.println("b : "+b);
		
		a-= 4;
		System.out.println("============================");
		System.out.println("a : "+a);
		
		a *= 6;
		System.out.println("a : "+a);
		
		a/=5;
		System.out.println("a : "+a);
		
		a %=3;
		System.out.println("a : "+a);
	}
}

######################################################################################################















######################################################################################################
예제2)난수생성(정수,실수)

1)RandomExample 클래스를 만들어서 아래의 소스코드가 정상적으로 실행되도록 만들어라.


public class _3RandomExample {
	public static void main(String[] args) {

		//실수난수생성하기 0이상 1.0미만
		System.out.println("랜덤값: " + r);
	
		System.out.println("*** 신년 여행지 선정 ! ***");
		if () { 
			System.out.println("모로코로 갑시다!!!");
		}
		else if() {
			System.out.println("상하이로 갑시다!!!");
		}
		else{
			System.out.println("집에서 놉시다!!!");
		}
		
		//정수 난수 생성하기 0~9

		System.out.println("=============================");
		System.out.println("정수 난수값: " + );
		
		System.out.println("*** 신년 여행지 선정 ! ***");
		if () { 
			System.out.println("모로코로 갑시다!!!");
		}
		else if() { 
			System.out.println("상하이로 갑시다!!!");
		}
		else{
			System.out.println("집에서 놉시다!!!");
		}
	}
}

######################################################################################################






답:



public class _3RandomExample {
	public static void main(String[] args) {
		//난수(랜덤값)을 발생시키는 메서드 random()
		//0.0이상 1.0미만의 랜덤 실수값을 가져옴 c에서 rand()는 0~65535개였나? 그랬던듯
		double r = Math.random();
		System.out.println("랜덤값: " + r);
		
		System.out.println("*** 신년 여행지 선정 ! ***");
		if (r >0.66) { //0.67~0.99 33개 이상
			System.out.println("모로코로 갑시다!!!");
		}
		else if(r > 0.33) {//0.34~0.66 33개 
			System.out.println("상하이로 갑시다!!!");
		}
		else{//0~0.32 33개
			System.out.println("집에서 놉시다!!!");
		}
		
		//정수 난수 생성하기 0~9
		int rn = (int)(r*10);
		System.out.println("=============================");
		System.out.println("정수 난수값: " + rn);
		
		System.out.println("*** 신년 여행지 선정 ! ***");
		if (rn >0.66) { //0.67~0.99 33개 이상
			System.out.println("모로코로 갑시다!!!");
		}
		else if(rn > 0.33) {//0.34~0.66 33개 
			System.out.println("상하이로 갑시다!!!");
		}
		else{//0~0.32 33개
			System.out.println("집에서 놉시다!!!");
		}
	}
}




public class _4ConditionalOperatorExample {

	public static void main(String[] args) {
		//-4~5까지의 정수 난수값 발생
		int r = (int)(Math.random()*10-4);
		
		System.out.println("-4~5까지의 정수난수값 : " + r);
		
		
	}
	
	
	
}














######################################################################################################
예제3)조건연산자+난수생성

1)-4~5까지의 정수 난수값 발생후 출력
2)위의 난수값들을 모두 절대값으로 변경(음수가 없도록 하라는 뜻)하여 abs라는 정수형 공간에 저장한 후 출력
	-조건: 조건연산자(conditional operator를 사용할것)
3)조건연산자를 이용해서 조건에따라 성공과 실패를 저장하는 String 객체를 만들어라
	-무조건 성공만하게 만들어보시오


#조건연산자 : if와 같은데 아주 간단한 로직을 만들때 사용함(예를들어 c에서 매크로함수? 였던듯)
(조건식 ? 연산식1 : 연삭식2) : 조건이 참이면 1식 거짓이면 2식을 실행함

######################################################################################################


답:


public class _4ConditionalOperatorExample {

	public static void main(String[] args) {
		//-4~5까지의 정수 난수값 발생
		int r = (int)(Math.random()*10-4);
		
		System.out.println("-4~5까지의 정수난수값 : " + r);
		
		//3항조건연산자
		int abs = (r >=0) ? r : -r;
		System.out.println(abs);
		String s = (abs>=0) ? "성공" : "실패";
		
		System.out.println(s);
	}
	
	
	
}



######################################################################################################
개념정리_연산자 우선순위 및 종류

연산자우선순위

1.단항연산자
(), [], .(참조연산자)
++--(증감), +-(부호), !(논리반전), ~(비트반전), (type)

2.이항연산자
*/%(산술연산자)
+-

<< >> >>>(비트이동연산자)	>>>:부호포함 우측이동

< <= > >=(비교연산자)
== !=
instanceof(비교연산자:객체형비교)

&, | ^(비트연산자,논리연산자)
&&, || (논리연산자)

3.삼항연산자
? : (조건부연산자conditional operator)

4.이항연산자(대입연산자)
연산후 대입연산자, 대입연산자
 =,+=,-=,*=,/=,%=,<<=,>>=,>>>=,&=,^=,|=


연산자종류	 연산자			피연산자 수

증감 연산	++, --			단항
비교 연산	==, !=, <, 		이항
	>, <=, >=, 
	instanceof	
비트 연산  ~, &, |, 		이항
	^, <<, >>,
	>>>	
논리 연산	!, &, |,		이항 단항 
	&&, ||	

조건부 연산 ? : 			삼항
대입 연산	=, +=, -=, *=, 		이항
	/=, %= &=, ^=, 
	|=, <<=, >>=, 
	>>>=	
######################################################################################################











######################################################################################################
개념정리_표준입출력

* 자바 표준 입/출력(IO: Input/Output)

- IO란 입력과 출력을 뜻합니다.

- Input:
1. 파일의 데이터를 읽는다. (loading)
1. 키보드의 입력데이터를 읽는다.
1. 네트워크상의 데이터를 읽는다.

- Output
1. 파일에 데이터를 쓴다.(save)
1. 모니터에 데이터를 쓴다.(모니터에 데이터를 출력한다.)
1. 네트워크상에 데이터를 쓴다.(파일 전송)

- C언어에서는 문자열을 출력할 때 printf() 함수를 이용하고, 입력받을 때 scanf() 함수를 이용합니다.

- 자바에서 데이터를 출력하는 명령은 System.out이고, 데이터를 입력받을 때는 System.in을 이용합니다.

- 데이터를 입력받을 때는 표준 JAVA  API인 Scanner클래스를 사용하며, 이 Scanner 클래스는 다양한 타입의 입력 값들을 읽어들이기  
	위한 메서드들을 제공합니다.




######################################################################################################











######################################################################################################
개념정리_자바 표준 API의 class인 Scanner 사용법

0.Scanner가 들어있는 API(import) 불러오기

1. 스캐너 객체 생성
ex) Scanner scan = new Scanner(System.in);

2. 입력 받을 데이터 타입에 따른 메서드 호출.

ex) scan.next(), scan.nextLine(), scan.nextInt(), scan.nextDouble() 등

- next(): 공백을 포함하지 않는 문자열을 입력 받을 때
- nextLine(): 공백을 포함한 문자열을 입력 받을 때
- nextInt(): 정수를 입력 받을 때
- nextDouble(): 실수를 입력 받을 때
문자입력은????? 

3. 스캐너 객체 종료. ex) scan.close();


######################################################################################################















######################################################################################################
예제4)표준입력함수 사용(ScannerExample)

1)아래 출력결과처럼 이루어지도록 구현하시오.

<출력결과>
이름을 입력하세요.
> 이순신
나이를 입력하세요.
> 26
------------------
이름 : 이순신
나이 : 26

######################################################################################################


답:

import java.util.Scanner;

public class ScannerExample {
	public static void main(String[] args) {
		//1.스캐너 객체 생성
		Scanner scan = new Scanner(System.in);
		//2.스캐너 클래스가 가지고 있는 입력메서드들을 사용하여 데이터를 입력받음
		
		
		System.out.println("이름을 입력하세요.");
		System.out.print("> ");	//println하면 안됨
		String name = scan.next();
		
		System.out.println("나이를 입력하세요.");
		System.out.print("> ");
		int age = scan.nextInt();
		
		
		
		System.out.println("------------------------------");
		System.out.println("이름 : " + name);
		System.out.println("나이 : " + age);
		
		
		scan.close();
	
	}
}















######################################################################################################
개념정리_배열(Arrays)

-평균낼때 매번학생수 체크해야함, 변수이름이 너무많아짐 그래서 나옴


* 배열(Array)

- 배열은 같은 데이터 유형 변수를 여러 개 선언해야 하는 불편함을 줄이기 위해 사용합니다.

- 자바에서는 배열도 일종의 데이터 타입으로 취급할 수 있기 때문에 배열을 정의하는 대괄호"[]"가  배열 변수명 앞에 오는  것이  가능 합니다.


-배열(Array)이란 선형 자료구조(Data Structure)중 하나로, 동일한 타입의 연관된 데이터를 메모리에 연속적으로 저장하여 
하나의 변수에 묶어서 관리하기 위한 자료 구조입니다.  가장 기본적인 자료구조인 만큼 C,Java,Python등 거의 모든 언어에 구현되어 있습니다.
 배열의 길이는 최초 선언한 값으로 고정되며 위와 같이 인덱스(Index)를 통해 데이터에 접근 할 수 있습니다

		출처: https://ifuwanna.tistory.com/231 [IfUwanna IT]

#배열 "변수"선언: <데이터 타입><배열 이름[]> or <데이터 타입[]><배열 이름> 배열 생성: <배열 이름> = new <데이터 타입[배열의 크기]>
	-배열을 선언만한경우 힙영역에 생성은안되고 배열명의 공간에는 nll값이들어온다
	-c와다르게 []연산자안에 상수값을 안넣어도 컴파일시 문제가 없다.(차후 동적할당된 공간의 주소를받는 포인터형변수로 만들어지나봄?)
	-ex) int nabi[]; -> 자료형 : int(정수) 기본자료형(타입) 
	     int[] nabi; -> 자료형 : int(정수) 배열자료형(타입)	=>자바에선 이방식을 선호함


- 자바의 배열은 선언시에는 크기를 명시할 수 없으며, 생성시에 크기를 명시한다.

- 배열은 기본데이터 타입이나 객체참조 데이터 타입 또는 다른 배열의 순차적인 집합체라고 할 수 있습니다.

- 하나의 배열에 여러가지 데이터형을 혼합해서 사용할 수 없습니다. 이런 배열의 특징을 동종모음(Homogeneous collection)이라고   합니다.

- 배열은 선언, 생성, 초기화의 과정을 통하여 만들어집니다.

#배열의 생성 : 동적할당
	-ex) int[] nabi;
	     nabi = new int[5];
	-주소값: 한바이트당 하나의 주소를가지고있음
		-ex)int는 주소값을 4개가지고 있는거임 4byte니까
	-대표주소만알면된다.

- 선언 시에는 배열에 들어갈 데이터 타입을 결정하고, 생성 시 만들 배열의 크기를 결정합니다. 
	그리고 초기화 과정을 통하여 배열에 들어갈 값을 입력해 줍니다.

- 배열의 길이란 배열에 저장할 수 있는 전체 항목 수를 말하는데 코드에서 배열의 길이를 얻으려면 '배열변수이름.length'라는 코드를 사용합니다.


#배열의 초기화: 각 인덱스에 값을 처음넣는 행위
	-배열은 생성시 최초에 각 자료형에 대한 기본값으로 초기화가 되지만 그것을 배열의 초기화라고 부르지 않고 그 후 직접 유효값을넣을때
		배열의 초기화라 하나보다?

#배열특징 
1)reference Type(기본타입이아니다 참조타입이다)
2)homogeneous(호모지니어스) collection : 동종모음구조 : 같은 종류의 데이터만 모아지는 것
		-int형 배열을 만들면 double형 데이터는 해당 배열타입에 들어갈수 없다.
3)immutable : 크기 변경불가능(배열의 길이)
	-해결책: 리스트, 셋 등으로 배열을 강화시킬수있다고한다.

*****참고	(멤버변수 및 지역변수 초기화에 대하여)
#암시적 초기화방법: 클래스에서 멤버변수를 선언과 동시에 초기화하지 않은경우 자동으로 데이터의 형태가 가지는 기본값으로 초기화를 진행한다.
	-이때 초기화는 멤버변수에서만되고 지역변수에대해서는 기본값으로 초기화되지않는다. 그럼으로 반드시 초기화하여야한다.
	-각 데이터타입의 기본값(default value), 배열 생성시 배열의 타입별 초기값
		int[] a; 배열변수->a, 배열변수형->int 힙영역에 생성되는 int배열변수형 공간에서 각 세부공간은 int이고 그공간에
			배열변수형이 저장됨
	      배열변수형   초기값
		byte : 0
		short : 0
		int : 0
		long : 0L
		float : 0.0F
		double : 0.0
		char : " "(유니코드의 공백문자) : '\u0000'
		boolean : false
		string : null
		참조변수(주소가들어가는 모든 변수) : null
	*java 자료형의 대분류 : 기본자료형(primitive type), 참조자료형(참조타입,reference type)
		기본자료형 : 정수타입(byte,char,short,int,long), 실수타입(float, double), 논리타입(boolean)
			-메모리에서 할당된 공간의 값으로 실제 값을 저장
		참조자료형 : 배열타입, 열거타입, 클래스, 인터페이스
			-메모리에서 할당된 공간의 값으로 메모리(할당된 특정공간)의 주소값을 저장하는 것
		*자료형은 메모리에 공간을 할당받았을때 그모양이 무엇이냐 물을때 그 종류라고 보면될듯? 특정 데이터를 저장할수 있는공간의
											이름 
#new : 힙영역에 새로운 객체를 만들때 사용하는 연산자로 객체 생성연산자라한다
String s = "a";	//힙영역에 동적할당된 객체공간의 멤버변수공간에 값 문자 배열이 만들어진후 a값과 널값이 들어가고 해당 객체공간의
		주소를 s에 넣는다. 즉 s는 참조변수라는 것이다.

s = null; //특히하게도 자바에서는 힙영역의 특정객체에 대한 참조변수가 없으면 garbage collector로 공간할당을 자동해제한다.
		garbage collector : 사용되지 않는 메모리를 다시 사용할 수 있도록 하는 것 -> jvm이 할당된 모든
					메모리를 가지고 있고 이를 관리한다는 뜻임

변수의 초기화
변수를 선언하고 처음으로 값을 저장하는 것을 '변수의 초기화'라고 한다.

멤버변수는 초기화를 하지 않아도 자동적으로 변수의 자료형에 맞는 기본값으로 초기화가 이루어지므로 
초기화하지 않고 사용해도 되지만 지역 변수는 사용하기 전에 반드시 초기화를 해야한다.


class InitTest {
  int x;
  int y = x; //문제 없음

  void method() {
    int i;
    int j = i; // 컴파일 에러: 지역변수를 초기화하지 않고 사용함
  }
}

멤버 변수의 초기화 방법
명시적 초기화(explicit initialization) : 선언과 동시에 초기화하는 방법임
생성자(constructor)
초기화 블럭(initialization block)
인스턴스 초기화 블럭 : 인스턴스 변수를 초기화 하는데 사용
클래스 초기화 블럭 : 클래스 변수를 초기화하는데 사용




배열변수의 데이터 타입은 int배열타입이고 배열변수가 참조하는 배열의 타입은 int이다.(아무리 구글링해도 잘 모르겠음)


######################################################################################################





















######################################################################################################
예제5)배열(객체)의 자료형, 배열변수의 자료형(배열타입)

1)int배열타입 변수인 score를 만들고 응용하라

1-1)배열의 선언
1-2)배열의 생성
1-3)배열의 초기화
1-4)배열의 값참조(사용)
1-5)배열의 내부 값을 문자열 형태로 출력
1-6)배열의 길이 출력
1-7)배열의 선언과 생성을 동시에하는 byte배열타입 변수 bArr(참조변수)를 만들고(배열의 선언) 내부문자열형태로출력,길이출력
1-8)int배열타입 배열변수를 선언, 배열 생성, 배열 초기화 동시에 한후 문자열형태 및 길이 출력 
1-9)배열의 초기값설정하지않고 초기값이 기본값으로 자동초기화된것을 확인
1-10)char배열타입 배열변수를 선언, 배열 생성, 배열 초기화 동시에 한후 문자열형태 및 길이 출력 
1-11)String배열타입 배열변수를 선언, 배열 생성, 배열 초기화 동시에 한후 문자열형태 및 길이 출력 





######################################################################################################


답:


import java.util.Arrays;
import java.util.Scanner;

public class _1 {
	public static void main(String[] args) {
		
		int[] score;
		score = new int[5];
		for (int i=0, b=1;i<4;i++,b++) {
			score[i] = b;
		}
		System.out.println(Arrays.toString(score));
		System.out.println(score[0]);
		System.out.println(score.length);
		
		byte[] bArr = new byte[5];
		System.out.println(Arrays.toString(bArr));
		System.out.println(bArr.length);
		
		int[] arr = new int[] {10, 39, 29, 43, 56};
		System.out.println(Arrays.toString(arr));
		System.out.println(arr.length);
		
		char[] ch = new char[] {'남', 'B', 65, '자'};
		System.out.println(Arrays.toString(ch));
		System.out.println(ch.length);
		
		String[] str = new String[] {"ㄴ어래ㅑㄷ저ㅐㅑ렂대ㅑㄹ", "hi", " "};
		System.out.println(Arrays.toString(str));
		System.out.println(str.length);
		System.out.println(str.length);
	}
}



강의내용이면서 읽기힘든 답:

import java.util.Arrays;

public class _6ArrayBasic {
	public static void main(String[] args) {
		//1.배열의 선언 -stack에 배열의 참조변수를 설정
//		int score[50];//자바에서는 선언시 크기명시 불가
//		int score[];	//c style
		int[] score;    //java style
				//현재는 힙에 할당안됨 score에는 null 값이 들어가있음
//		System.out.println(score); //에러
		
		
		
		//2.배열의 생성 -heap에 실제 데이터가 저장될 공간을 생성
		//배열은 생성시 크기를 명시함. 한번 설정한 크기는 변경불가
		score = new int[5];
		System.out.println(score);
		System.out.println(score[0]);	//기본값으로 초기화됨
		
		//3.배열의 초기화 - 배열에 값을 저장하는 과정
		score[0] = 87;
		System.out.println(score[0]);	//배열의 초기화
			
		score[2] = 99;
		score[3] = score[0];
		
		
		//4.배열의 값 참조(사용)
		System.out.println("배열의 3번째 데이터값 : " + score[2]);
		System.out.println("배열의 4번째 데이터값 : " + score[3]);
		
		/*
		 * 배열 내부에 저장된 값들을 한눈에 문자열 형태로 확인해보려면 출력메서드 
		 * println의 매개값으로 Arrays.toString(배열변수명)을 쓰면 됨
		 */
		System.out.println(Arrays.toString(score));
		
		
		//배열의 길이를 알아보려면 배열변수명.length 명령을 사용
		System.out.println("배열의 길이: " + score.length);
		
		//배열의 선언과 생성을 동시에 하는방법
		byte[] bArr = new byte[7];
		System.out.println(Arrays.toString(bArr));
		
		//배열의  선언과 생성과 초기화를 동시하는 방법
		char[] letters = new char[] {'가', '나', '다', '라'};
		System.out.println(Arrays.toString(letters));
		System.out.println("배열의 길이: " + letters.length);
		
//		String[] names = new String[] {"홍길동", "심사임당", "강감찬"};
		String[] names = {"홍길동", "심사임당", "강감찬"}; // 선언-생성-초기화를 동시에
											//하는경우에는 new 배열타입[] 생략가능
		System.out.println(names);
		System.out.println(Arrays.toString(names));
		System.out.println("배열의 길이: " + names.length);
		
		//배열의 초기값을 설정하지 않으면 각 데이터 타입의 기본값으로 자동초기화됨
		
		
	}
}




























======================================================================================================
*21.09.01_5회차(5강)
======================================================================================================


























































######################################################################################################
개념정리_제어문

* 제어문

- 제어문의 종류는 조건문, 반복문, 탈출문이 있습니다.
- 조건문은 특정 조건을 만족할 때 실행할 문장을 작성하는데 사용합니다.
- 반복문은 여러 번 반복 실행할 코드가 있다면 반복문을 작성합니다.
- 반복문이 실행되는 동안 실행을 중지시키고 싶으면 탈출문을 사용합니다.


* 조건문 if ~ else

- if문은 프로그램의 흐름을 바꾸는데 사용되는 조건 선택 분기문입니다.
- if문의 조건식 결과는 반드시 boolean형이어야 되며, 조건식이 참이면 if문 블록안의 실행문이 실행되고, 거짓이면 else문 블록안의 실행문이 실행됩니다.
- if문장은 else문장 없이 사용할 수 있습니다. 그러나 else문장은 if문장 없이 단독으로 사용할 수 없습니다.
- 조건식의 결과가 거짓일 때 실행할 문장이 없다면, else문 이하를 생략해도 됩니다.


* 다중 분기 조건문 if ~ else if ~ else

- 여러 조건들을 설정할 때 사용하는 조건문입니다.
- 다중 분기 조건문은 위에서부터 차례로 조건을 검색합니다.


public class _1IfExample1 {
	public static void main(String[] args) {
		//0~100까지의 정수형 난수 발생
		int point = (int)(Math.random()*101);
		System.out.println("점수: "+point);
		
		if(point>=60) {
			System.out.println("60점 이상입니다.");
			System.out.println("시험에 합격했습니다.");
		} else {
			System.out.println("60점 미만입니다.");
			System.out.println("시험에 불합격했습니다.");			
		}//end else
		System.out.println("수고하셨습니다!");
	}//end main
}//end class



import java.util.Scanner;

public class _1IfExample2 {
	public static void main(String[] args) {
		Scanner scan = new Scanner(System.in);
		
		System.out.println("점수를 입력하세요.");
		System.out.print("> ");
		int point = scan.nextInt();
		
		if(point >= 90) {
			if(point > 100) {
				System.out.println("점수를 잘못 입력했습니다.");
			} else if(point >= 95) {
				System.out.println("당신의 학점은 A+입니다.");
			} else {
				System.out.println("당신의 학점은 A입니다.");				
			}
		} else if(point >= 80) {			
			System.out.println("당신의 학점은 B입니다.");
		} else if(point >= 70) {
			System.out.println("당신의 학점은 C입니다.");
		} else if(point >= 60) {
			System.out.println("당신의 학점은 D입니다.");			
		} else {
			System.out.println("당신의 학점은 F입니다.");			
			System.out.println("당신은 재수강!");			
		}
	}//end main
}//end class


######################################################################################################

































######################################################################################################
예제6) if 


* 1. 양의 정수를 입력받아서 그 수가 홀수라면
*    "x는 홀수입니다.", 짝수라면 "x는 짝수입니다."가
*    출력되도록 조건문을 활용하여 코드를 만들어보세요.
*    힌트) 짝수는 2로 나누면 나머지가 0이다.
* 2. 만약 사용자가 0을 입력하면 "0입니다." 하고 종료되도록, 음수를
*    입력하면 "음의 정수입니다."를 출력하고 종료되도록 조건문을
*    수정해보세요.   
*/		


######################################################################################################


답:


import java.util.Scanner;

public class _2IfQuiz {
	public static void main(String[] args) {
		Scanner scan = new Scanner(System.in);
		System.out.print("양의 정수 입력 : ");
		int num = scan.nextInt();
		
		if(num == 0) {
			System.out.println("0입니다");
			return;
		} else if(num < 0) {
			System.out.println("음의 정수입니다.");
			return;			
		}
		
		if(num % 2 == 0) {
			System.out.println("x는 짝수입니다.");
		} else {
			System.out.println("x는 홀수입니다.");			
		}
		
	}//end main
}//end class






















######################################################################################################
개념정리_switch ~ case



* 조건문 switch ~ case

- 복합 if문은 구현하기 복잡하고 프로그램의 효율성이 감소되는 단점이 있기 때문에, 다중 분기 문제를 해결할 때는 switch문을 사용합 니다.

- switch문은 다중 분기 구조이므로 복합 if문의 논리적인 구조를 간결하게 표현할 수 있습니다.

- if문과는 달리 조건식이 사용되지 않고, 값을 가지는 변수 또는 표현식이 판단조건으로 사용되며, 연산 결과의 데이터 타입은 int, String, Enum(열거형)이 사용됩니다.

- case문 뒤에 사용되는 값은 변수를 사용할 수 없고, 반드시 상수를 사용해야 합니다.

- switch ~ case문에서 default는 if~else에서 else와 비슷한 효과를 가집니다.

switch (변수) // 변수 : char int string, enum
{
case 변수값(상수):
	해당 case의 실행코드
case 상수2:
	해당 case의 실행코드
default:
	해당 case의 실행코드
}	


######################################################################################################






























######################################################################################################
예제7) switch ~ case


1)case 변수를 정수타입으로 두기
	아래 방식으로 swtich ~ case를 만들어서 효율성을 if보다 좋게하라

90점이상 100점이하 A 출력
	100점초과시 점수잘못입력함을 출력
80점이상 B 출력
70점이상 C 출력
60점이상 D 출력
50점이상 D 출력

2)case변수 문자열타입으로 두기
	아래처럼 출력되게 해봐라

배열이름 : foods
	배열변수 자료형 : String배열타입

정수난수 0~4를 만든뒤 해당 난수를 이용해서 switch에 접목하라(switch변수의 자료형은 Styring이다.)

비빔밥, 사시미, 북경요리, 카레, 똠양꼼
한식	일식	중식  기타해외요리입니다.


######################################################################################################




답:




1)case 변수를 정수타입으로 두기
	아래 방식으로 swtich ~ case를 만들어서 효율성을 if보다 좋게하라

import java.util.Scanner;

public class _3SwitchExample1 {
	public static void main(String[] args) {
		Scanner scan = new Scanner(System.in);
		System.out.print("점수 : ");
		int point = scan.nextInt();
		
		/*
		 * switch 키워드 뒤에 나오는 변수나 연산식은 결과값이 반드시 문자나 정수타입이어야함
		 */
		switch(point/10){
 			//case 뒤에는 반드시 상수를 적어야함
		case 10:
		case 9:	//90~99
			if (point > 100) {
				System.out.println("점수잘못입력함.");
			} else {
				System.out.println("당신의 학점은 A입니다.");	
			}
			break;
		case 8:	
			System.out.println("당신의 학점은 B입니다.");
			break;
		case 7:
			System.out.println("당신의 학점은 C입니다.");
			break;
		case 6: //50 ~ 69 D
		case 5:
			System.out.println("당신의 학점은 D입니다.");
			break;
		default:
			System.out.println("당신의 학점은 F입니다.");
		}
		
		
		scan.close();
	}

}





2)case변수 문자열타입으로 두기
	아래처럼 출력되게 해봐라

public class _3SwitchExample2 {
	public static void main(String[] args) {
		String[] foods = {"비빔밥", "사시미", "북경오리", "카레", "똠양꼼"};
		//index(0~4) 범위 난수 발생
		int idx = (int)(Math.random() * 5);
		System.out.println("선택된 음식 : " + foods[idx]);
		
		switch(foods[idx]) { //문자나 정수만가능 foods는 String배열타입, idx를하니 char
								//문자타입 그래서 가능
		case "비빔밥":
			System.out.println("한식입니다.");
			break;
		case "사시미":
			System.out.println("일식입니다.");
			break;
		case "북경오리":
			System.out.println("중식입니다.");
			break;
		default:
			System.out.println("기타 해외요리입니다.");
		}
	}//end main
}//end class





























######################################################################################################
예제8) switch ~ case 출력결과만으로 유추하여 실행하기(심화)

<출력결과>
직급을 입력하세요.
[사원,대리,과장,차장,부장]
> 사워
사워은(는) 없는 직급입니다.
직급을 다시 입력해주세요.


직급을 입력하세요.
[사원,대리,과장,차장,부장]
> 대리
대리의 급여는 300만원입니다.
		//이런식으로 각 월급을 알려줘라 월급은 맘대로 설정





######################################################################################################




답:


import java.util.Arrays;
import java.util.Scanner;

public class _4SwitchQuiz {
	public static void main(String[] args) {
		
		System.out.println("직급을 입력하세요.");
		System.out.println("[사원, 대리, 과장, 차장, 부장]");
		System.out.print("> ");
		
		Scanner scan = new Scanner(System.in);
		String position = scan.next();
		
		switch(name){
		case "사원":
			System.out.println(position+"의 직급은 100만원입니다.");
			break;
		case "대리":
			System.out.println(position+"의 직급은 200만원입니다.");
			break;
		case "과장":
			System.out.println(position+"의 직급은 300만원입니다.");
			break;
		case "차장":
			System.out.println(position+"의 직급은 400만원입니다.");
			break;
		case "부장":
			System.out.println(position+"의 직급은 500만원입니다.");
			break;
		default:
			System.out.println(position+"은(는) 없는 직급입니다.");
			System.out.println("직급을 다시 입력해주세요.");
		}
	}//end main
}//end class



























######################################################################################################
개념정리_while

* 반복문 while

- while문은 조건식을 만족하는 동안 반복문을 실행하는데, 조건식을 검사해서 조건식이 참이면 실행문을 반복하고, 거짓이면 while문 을 빠져나옵니다.

- while문에 들어가는 조건식도 if문과 마찬가지로 반드시 boolean타입으로 결과를 반환해야 합니다.

- 조건식 안에 true를 넣으면 무한루프가 발생하기 때문에 반드시 탈출구문을 넣어야 합니다.




public class _5WhileExample1 {
	public static void main(String[] args) {
		//1~10까지의 누적합계를 구하는 로직
		int sum = 0; //합계를 저장할 변수
		int n=1; //제어변수 : 반복문의 횟수를 제어할 변수
		
		while(n <= 10) {
			sum += n;
			n++;
		}
		System.out.println("1부터 10까지의 합 : "+ sum);
		
	}//end main
}//end class


######################################################################################################
























######################################################################################################
예제9) while 응용(소수판별로직)

소수를 판별하는 while 제어문을 작성하시오.


######################################################################################################




답:



import java.util.Scanner;

public class _5WhileExample2 {
	public static void main(String[] args) {
		//정수를 이력받아서 해당 정수가 소수인지 판별
		Scanner scan = new Scanner(System.in);
		System.out.print("정수를 입력: ");
		int num = scan.nextInt();
		
		int i=2;
		while (num%i != 0) {
			i++;
		}
		if (i == num) {
			System.out.println(num + "은 소수입니다.");
		}
		else {
			System.out.println(num + "은 소수가 아닙니다.");			
		}
	}
}




































======================================================================================================
*21.09.02_6회차(6강)
======================================================================================================














































######################################################################################################
개념정리_do while, for

#차이점
while : 시작값이 false면 0회실행
do while : 시작값이 false면 1회실행

#for(초기값;boolean형 조건식;반복표현식(증감식)){
	실행문
}//초기값은 반드시 한번실행된다.

#for예문

public class _2ForExample1 {
	public static void main(String[] args) {
		int sum=0;
		for(int n=1; n<=10;n++) {
			sum += n;
		}
		
		System.out.println("누적합: " + sum);
	}
}


public class _2ForExample2 {
	public static void main(String[] args) {
		//7~100까지의 정수중 7의 배수를 모두 가로로 출력
		for(int i=7; i<101; i++) {
			System.out.print(i+ " ");
		}
		System.out.println("\n--------------------");
		
		//1~100가지의 정수중 6의 배수를 모두 가로로 출력
		for(int i = 1; i < 101; i++) {
			if(i%6==0) {
				System.out.print(i + " ");
			}			
		}
		System.out.println("\n--------------------");
		
		//1~100가지 정수중 8의 배수이면서 동시에 16의 배수가 아닌수를 모두 가로로 출력
		for(int i=1;i<101;i++) {
			if(i%8==0 && i%16!=0)
				System.out.print(i + " ");
		}
		System.out.println("\n--------------------");
		
		//1~850까지의 정수중 9의 배수의 개수를 출력
		int n=0;
		for(int i=1;i<851;i++) {
			if(i%9==0)
				n++;
		}
		System.out.println("9의 배수의 개수: " + n);
	}
}


public class _3ForQuiz {
	public static void main(String[] args) {
		int dan = (int)(Math.random()*8)+2;
		System.out.println("랜덤 구구단 " + dan + "단");
		System.out.println("--------------------------");
		for(int i=1;i<10;i++) {
			System.out.println(dan + " x " + i + " = " + dan*i);
		}
	}
}




######################################################################################################














######################################################################################################
예제10) do while

1)정수를 입력받아 1부터 입력받은 숫자까지의 누적합을 구하는 로직을 통해 while로 구현하고
 do while로 구현해서 차이점을 확인하라
######################################################################################################


답:

0을넣어서 확인해야함 0을 넣었을때 while은 1번도안해서 sum=0 dowhile은 1번해서 sum=1이됨

import java.util.Scanner;

public class _1DoWhileExample {
	public static void main(String[] args) {
		//정수를 입력받아 1부터 입력받은 숫자까지의 누적합을 구하는 로직
		Scanner scan = new Scanner(System.in);
		System.out.print("정수: ");
		int target = scan.nextInt();
		int sum = 0;
		int n=1;
		
//		while(n<=target) {
//			sum+=n;
//			n++;
//		}
//		System.out.println("1부터 " + target + "까지의 누적합계  : " + sum);
		
		do {
			sum += n;
			n++;
		}while(n<=target);
		
		System.out.println("1부터 " + target + "까지의 누적합계  : " + sum);
	}
}


















######################################################################################################
예제11) 별짓기



*****
 ****
  ***
   **
    *



    *
   ***
  *****
 *******
*********



*********
 *******
  *****
   ***
    *


######################################################################################################


답:




*****
 ****
  ***
   **
    *
i	" "	*
0	0	5	
1	1	4
2	2	3
3	3	2
4	4	1
"":i
*: 5-i



public class _5ForStarEx1 {
	public static void main(String[] args) {
		for(int i=0;i<5;i++) {
			for(int j=0;j<i;j++) {
				System.out.print(" ");
			}
			for(int j=0;j<5-i;j++) {
				System.out.print("*");
			}
			System.out.println();
		}
	}
}



    *
   ***
  *****
 *******
*********

" "	*
4	1
3	3
2	5
1	7
0	9

"":j<4-i
* :j<(i*2)+1


public class _5ForStarEx2 {
	public static void main(String[] args) {
		for(int i=0;i<5;i++) {
			for(int j=0;j<4-i;j++) {
				System.out.print(" ");
			}
			for(int j=0;j<(i*2)+1;j++) {
				System.out.print("*");
			}
			System.out.println();
		}
	}
}



*********
 *******
  *****
   ***
    *


""	*
0	9	8 (2*4) +1
1	7	6 (2*3) +1
2	5	4    2
3	3	2
4	1	0 

"":j<i
* :j<2*(4-i)+1




public class _5ForStarEx3 {
	public static void main(String[] args) {
		for(int i=0;i<5;i++) {
			for(int j=0;j<i;j++) {
				System.out.print(" ");
			}
			for(int j=0; j<(2*(4-i)+1); j++) {
				System.out.print("*");
			}
			System.out.println();
		}	
	}
}





























































======================================================================================================
*21.09.03_7회차(7강)
======================================================================================================
























































######################################################################################################
개념정리_향상된 for문
#enhanced for(강화된 포문, 향상된 포문)

for(엘리먼트 선언: 배열또는 컬렉션의 레퍼런스->배열변수말하는거임){
	실행문;
}

엘리먼트: 배열변수에서 나오는 0번인덱스값부터를 받을 변수
레퍼런스: 배열변수 또는 컬렉션변수 


public class _1EnhancedForLoop {
	public static void main(String[] args) {
		 String[] weekDay = {"일", "월", "화", "수", "목", "금", "토"};
//		 for(int i=0;i<weekDay.length;i++) {
//			 System.out.println(weekDay[i] + "요일");
//		 }
		 for(String day:weekDay) {
			 System.out.println(day+"요일");
		 }

	}

}



######################################################################################################


























######################################################################################################
예제12) enhanced for문
향상된 for문을 사용하여 총점과 평균을 출력

######################################################################################################


답:


public class _1EnhancedForLoop {
	public static void main(String[] args) {

		 //향상된 for문을 사용하여 총점과 평균을 출력
		 int sum=0;
		double avg=0;
		
		for(int i:scores) {
			sum += i;
		}
		avg = (double)sum / scores.length;
		System.out.println(avg);
	}

}


























######################################################################################################
예제13)loop+제어문+탈출문
1)아래의 출력결과가 되도록하라
	-커피는 최초 5잔이다.
돈넣어라 : 500
커피를 한잔드리겠습니다.
남은 커피 : 4잔
돈넣어라 : 700
커피를 한잔드리겠습니다.
남은 커피 : 3잔
잔돈 : 200원입니다.
돈넣어라 : 600
커피를 한잔드리겠습니다.
남은 커피 : 2잔
잔돈 : 100원입니다.
돈넣어라 : 400
500원이상넣어라
돈넣어라 : 500
커피를 한잔드리겠습니다.
남은 커피 : 1잔
돈넣어라 : 700
커피를 한잔드리겠습니다.
남은 커피 : 0잔
잔돈 : 200원입니다.
음료수가 다떨어졌습니다. 판매를 중지합니다.

######################################################################################################




답:





import java.util.Scanner;

public class _2LoopQuiz {
	public static void main(String[] args) {
		Scanner scan = new Scanner(System.in);
		int coffee=5;
		
		while(true) {
			System.out.print("돈넣어라 : ");
			int money=scan.nextInt();
			if(money<500) {
				System.out.println("500원이상넣어라");
			}else if(money==500){
				System.out.println("커피를 한잔드리겠습니다.");
				coffee--;
				System.out.println("남은 커피 : " + coffee + "잔");
				if(coffee==0) {
					System.out.println("음료수가 다떨어졌습니다. 판매를 중지합니다.");
					break;
				};
			}else if(money>500){
				System.out.println("커피를 한잔드리겠습니다.");
				coffee--;
				money-=500;
				System.out.println("남은 커피 : " + coffee + "잔");
				System.out.println("잔돈 : " + money + "원입니다.");
				if(coffee==0) {
					System.out.println("음료수가 다떨어졌습니다. 판매를 중지합니다.");
					break;
				};
			}
		}
	}
}

































































======================================================================================================
*21.09.04_8회차(8강)
======================================================================================================



















































######################################################################################################
개념정리_메서드 및 매개변수 개념


함수: 클래스가 아닌 전역에 선언되고 정의된함수
메서드: 클래스안에 선언되고 정의된 함수

자바: 클래스밖에없기때문에 함수가없고 모두 메서드라부름

*메서드(method) : 코드반복을 막기위함
-메서드는 정의하는 과정과 호출하는 과정이 있음
-메서드 선언은 메서드 내부에서는 할수없음 반드시 메서드블록 외부에서만 선언가능
	-main안에서 못만든단소리
	-class내부에서만가능
-메서드 내부에서는 다른 메서드의 호출만 가능
-호출하는 과정은 메서드를 사용하는 과정이며 해당메서드가 필요로하는 데이터(매개값)를 메서드 내부로 전달하면서 해당 메서드는
 매개값을 통해 처리한 결과값을 호출부로 다시 반환해줌


public class _1MethodExample1 {
	public static int calcSum(int num){
		int sum=0;
		for(int i=1;i<=num;i++) {
			sum+=i;
		}//endFor
		return sum;
	}//endMethod
	public static int calcSum2(int begin, int end) {
		int sum=0;
		//short sum=0;가능 왜냐면 반환될때 int로 자동형변환되기때문임 작은놈->큰놈
		for(int i=begin;i<=end;i++) {
			sum+=i;
		}
		return sum;
	}
	
	public static void main(String[] args) {
		System.out.println("1~10까지 누적합: "+calcSum(10));
		System.out.println("1~20까지 누적합: "+calcSum(20));
		int result = calcSum(100);
		System.out.println("1~100까지 누적합: "+result);
		System.out.println(0+"~"+100+"까지의 누적합: "+calcSum2(0,100));
		
	}//endMain
}//endClass


#매개변수
-매개변수는 메서드를 호출할때 실행에 필요한값들을 메서드 내부로 전달하기위한 매개체
-메서드 호출부에서 어떤매개값을 전달하느냐에 따라 메서드의 실행결과가 달라짐
-매개변수를 몇개전달받을지는 메서드를 선언할때 선언부에서 결정해야함
-매개변수를 하나도 선언하지 않을수 있으며 이때는 메서드 선언부의 ()를 비워둠 그리고 호출시에도 ()를 비워서 호출함





public class _1MethodExample2 {
	public static void main(String[] args) {
		System.out.println(calcSum());
		System.out.println(calcSum());
		System.out.println(calcSum());
		System.out.println(calcSum());
		System.out.println("이번에 획득한 무기: "+randomWeapon());
	}
	
	public static int calcSum() {
		int sum=0;
		for(int i=1;i<=100;i++) {
			sum+=i;
		}
		return sum;
	}
	public static String randomWeapon() {
		double d=Math.random();
		if(d>0.66) return "단검";
		else if(d>0.33) return "장궁";
		else return "지팡이";
	}
}




######################################################################################################


















######################################################################################################
개념정리_반환값 개념

#반환유형(return type)

1.반환값은 메서드를 호출한 곳으로 메서드의 최종실행 결과를 전달하는 값임
2.매개변수는 여러개 존재할수있지만 반환값은 오직 하나여야함
3.return이라는 키워드를 사용하여 return 뒤에 전달할 값을 지정
4.전달할 값의 데이터 타입을 반환유형이라고 하며 메서드를 선언할때 메서드 이름 앞에 반환유형을 명시해야함
5.반환값이 있는 메서드는 호출문이 하나의 값이 되기때문에 반화된 값을 다른변수에 대입할수도있고 다른 메서드의 매개값으로 사용할수도
	있음

6.모든 메서드가 반환값이 필요한것은 아님 메서드 실행 이후에 반환값이 없다면 return을 사용하지 않아도 된다.
	-이때는 반환유형을 선언시에 void라 해야함
7.모든 메서드는 return키워드를 만나면 강제로 종료됩니다. 따라서 return문 이하에 코드를 작성할수 없음
8.반환값이 없는 메서드는 반드시 단독호출해야함
	-변수에 저장하거나 다른 메서드의 매개값으로 사용불가




import java.util.Scanner;

public class _1MethodExample3 {
	public static int add(int n1, int n2) {
		return n1 + n2;
	}//add
	public static int[] totalOperate(int n1, int n2){
		int[] total= {n1+n2,n1-n2,n1*n2,n1/n2};
		return total;
	}//totalOperate
	public static void callMyName(String name) {
		if(name.length()<2) {
			System.out.println("이름은 2글자 이상으로 입력하세요!");
			return;
		}
		System.out.println("내 이름은 "+name+"입니다.!!");
	}//callMyName
	
	public static void main(String[] args) {
		int r = add(3,5);
		System.out.println(r);
		
		int r2=add(add(4,6), add(8,7));
		System.out.println(r2);
		
		int[] tot=totalOperate(30,5);
		System.out.println("30 + 5 = "+tot[0]);
		System.out.println("30 - 5 = "+tot[1]);
		System.out.println("30 * 5 = "+tot[2]);
		System.out.println("30 / 5 = "+tot[3]);
		callMyName("리덕화");
		
		System.out.println("---------------------------");
		Scanner sc = new Scanner(System.in);
		System.out.print("이름 입력: ");
		String name = sc.nextLine();
		callMyName(name);
	}//main
}//class


######################################################################################################

















######################################################################################################
개념정리_string mainpulate


#대소문자 변경 / Stirng 문자열에서 특정문자 반환(변수, 버퍼)

public class StringMainPulate {
	public static void main(String[] args) {
		String str = "iNSERT";
		System.out.println(str);
		
		//문자열을 일괄적으로 소문자로 변환하는 메서드는 toLowerCase()
		str = str.toLowerCase(); //반대 : toUpperCase()
		System.out.println(str);
		
		str = str.toUpperCase();
		System.out.println(str);
		
		//문자열에서 특정 문자 하나만 가져오는 메서드는 charAt(문자열인덱스번호)입니다.
		char c = str.charAt(0);			//str이란 변수에서 0번인덱스 가져오기
		System.out.println(str.charAt(0));
		System.out.println(c);
		
	}//main
}//class



char gender = scan.next().charAt(0);	//버퍼에서 바로 0번인덱스만 가져오기


######################################################################################################





















######################################################################################################
예제14)고객관리프로그램(다음 강의를 통해 완성될 예제_정보수정, 정보삭제 기능이 없음)



#요구사항정의
-고객의 정보는 이름,성별,이메일,출생년도가 있습니다. 고객의 정보를 입력받아 배열에 저장해야합니다. 이름은 문자열로 저장하며, 
 성별은 남자는 M, 여자는 F로 저장합니다. 이메일은 문자열로 저장하며 태어난 출생년도는 정수로 저장합니다.
-고객관리프로그램은 고객의 정보를 저장, 조회, 수정, 삭제할 수 있는 기능이 있어야 합니다. 고객 정보를 파일에 저장하는 기능을 구현하지 않아도 
 됩니다.
-I를 눌러 고객의 정보를 입력받도록 하며, 저장된 고객정보는 P또는 N을 눌러 이전 고객정보 또는 다음 고객정보를 조회할수 있어야합니다.
 조회한 고객정보는 U를 눌러 새로운 정보로 수정할수 있어야합니다. D를 누르면 조회한 고객 정보를 배열에서 삭제해야 합니다. 프로그램의 
 종료는 Q를 누릅니다.





######################################################################################################




답:



import java.util.Arrays;
import java.util.Scanner;

public class CustomerManager {
	//프로그램 전체에서 사용할 변수들은 클래스블록 바로 아래에 선언합니다.
	//static이 붙은 블록에서는 static변수와 static 메서드만 사용할수 있음
	
//globalVariable
	static String[] nameList = new String[100];
	static char[] genderList = new char[100];
	static String[] emailList = new String[100];
	static int[] birthList = new int[100];
	
	//현재 고객데이터가 몇명 저장되었는지 알기위한 변수 count 선언
	static int count = 0;
	
	//배열의 인덱스를 조작하기 위해 인덱스를 변수화시킴
	//배열의 인덱스는 0번부터 출발함으로 초기값을 0바로 이전값인 -1로 세팅하여 초기에
	//next를 실행했을때 인덱스가 0이되어 첫번째 고객을 조회하기 위함
	static int index = -1;
	static Scanner scan = new Scanner(System.in);

//userDefinedMethod
	//고객정보를 입력받는 메서드 선언
	public static void insertData() {
		System.out.println("==============고객정보입력=============");
		
		System.out.print("이름 : ");
		String name = scan.next();
		
		System.out.print("성별(M/F): ");
		char gender = scan.next().charAt(0);
		
		System.out.print("이메일: ");
		String email = scan.next();
		
		System.out.print("출생년도: ");
		int birth = scan.nextInt();
		
		nameList[count] = name;
		genderList[count] = gender;
		emailList[count] = email;
		birthList[count] = birth;
		
		System.out.println("=====================================");
		count++;
		index++;
	}
	public static void disp() {
		for(int i=0;i<count;i++) {
			System.out.println(nameList[i]);
			System.out.println(genderList[i]);
			System.out.println(emailList[i]);
			System.out.println(birthList[i]);
		}
	}
	public static void printData(int index) {
		System.out.println("\n===========고객정보=============");
		System.out.println(nameList[index]);
		System.out.println(genderList[index]);
		System.out.println(emailList[index]);
		System.out.println(birthList[index]);
		System.out.println("\n==============================");
	}
	
	
//main
	public static void main(String[] args) {
//while
		while(true) {
			System.out.println("\n[INFO] 고객수: " + count
					+ ", 인덱스: " + index);
			System.out.println("메뉴를 입력하세요.");
			System.out.println("(I)nsert, (P)revious, "
					+ "(N)ext, (C)urrent, (U)pdate, "
					+ "(D)elete, (Q)uit");
			System.out.print("메뉴 입력: ");
			String menu = scan.next();
			
			menu = menu.toUpperCase();
			char m = menu.charAt(0);
//switch
			switch(m) {
			case 'ㅑ':
			case 'I':
				System.out.println("\n고객정보 입력을 시작합니다.");
				insertData();
				System.out.println("고객정보가 정상적으로 입력되었습니다.");
//				System.out.println("현재 종류별 총 입력정보");
//				System.out.println(Arrays.toString(nameList));
//				System.out.println(Arrays.toString(genderList));
//				System.out.println(Arrays.toString(emailList));
//				System.out.println(Arrays.toString(birthList));
				break;
			case 'ㅔ':
			case 'P':			
				if(count==0) {
					System.out.println("데이터를 먼저 입력해주세요."
							+"\n현재 데이터가 하나도 없습니다.");
					continue;
				}
				System.out.println("\n이전 고객정보를 조회합니다.");
				if(index==0) {
					System.out.println("이전 데이터가 없습니다.(현재 첫번재) "
							+ "\n첫번째 데이터를 다시 출력합니다.");
					printData(index);
					continue;
				}
				index--;
				printData(index);
				break;
			case 'ㅜ':
			case 'N':
				if(count==0) {
					System.out.println("데이터를 먼저 입력해주세요."
							+"\n현재 데이터가 하나도 없습니다.");
					continue;
				}
				System.out.println("\n다음 고객정보를 조회합니다.");
				if(count!=0&&index==count-1) {
					System.out.println("다음 데이터가 없습니다.(현재 마지막)"
							+ "\n가장 마지막 데이터를 출력합니다.");
					printData(index);
					continue;
				} 
				index++;
				printData(index);
				
				break;
			case 'ㅊ':
			case 'C':
				System.out.println("\n현재 고객정보를 조회합니다.");
				printData(index);
				break;
			case 'ㅕ':
			case 'U':
				System.out.println("\n현재 고객정보를 수정합니다.");
				break;
			case 'ㅇ':
			case 'D':
				System.out.println("\n현재 고객정보를 삭제합니다.");
				break;
			case 'ㅂ':
			case 'Q':
				System.out.println("\n프로그램을 종료합니다.");
				scan.close();
				System.exit(0);	//프로그램을 강제종료하는 구문
				break;
			default:
				System.out.println("\n메뉴를 잘못 입력하셨습니다.");
			}//switch
		}//while
	}//main
}//class

































































































======================================================================================================
*21.09.05_9회차(9강)
======================================================================================================


















































































######################################################################################################
예제14)고객관리프로그램



#요구사항정의
-고객의 정보는 이름,성별,이메일,출생년도가 있습니다. 고객의 정보를 입력받아 배열에 저장해야합니다. 이름은 문자열로 저장하며, 
 성별은 남자는 M, 여자는 F로 저장합니다. 이메일은 문자열로 저장하며 태어난 출생년도는 정수로 저장합니다.
-고객관리프로그램은 고객의 정보를 저장, 조회, 수정, 삭제할 수 있는 기능이 있어야 합니다. 고객 정보를 파일에 저장하는 기능을 구현하지 않아도 
 됩니다.
-I를 눌러 고객의 정보를 입력받도록 하며, 저장된 고객정보는 P또는 N을 눌러 이전 고객정보 또는 다음 고객정보를 조회할수 있어야합니다.
 조회한 고객정보는 U를 눌러 새로운 정보로 수정할수 있어야합니다. D를 누르면 조회한 고객 정보를 배열에서 삭제해야 합니다. 프로그램의 
 종료는 Q를 누릅니다.

//각 함수에대한 조건은 모두 switch에 넣어라(함수에 탈출조건넣지마라는소리임)
insertData(index);
printData(index);
updateData(index);	//풀이에서는 함수에넣긴했는데 풀때는 그렇게풀지마라 정해진건아니고 통일하자는 차원에서.. 
deleteData(index);


######################################################################################################




답:






import java.util.Scanner;

public class CustomerManagement {
//variable
	static String[] nameList = new String[100];
	static char[] genderList = new char[100];
	static String[] emailList = new String[100];
	static int[] birthList = new int[100];
	
	static int count = 0;
	static int index = -1;
	
	static Scanner scan = new Scanner(System.in);
	
//userDefinedMethod
	public static void insertData() {
		System.out.print("이름입력 : ");
		nameList[count] = scan.next();
		
		System.out.print("성별입력(M/W) : ");
		genderList[count] = scan.next().toUpperCase().charAt(0);

		System.out.print("이메일입력 : ");
		emailList[count] = scan.next();
		
		System.out.print("출생년도입력 : ");
		birthList[count] = scan.nextInt();
		
		count++;
	}
	public static void updateData() {
		System.out.printf("이름입력(%s) : ", nameList[index]);
		nameList[index] = scan.next();
		
		System.out.printf("성별입력(%c) : ", genderList[index]);
		genderList[index] = scan.next().toUpperCase().charAt(0);

		System.out.printf("이메일입력(%s) : ", emailList[index]);
		emailList[index] = scan.next();
		
		System.out.printf("출생년도입력(%d) : ", birthList[index]);
		birthList[index] = scan.nextInt();
	}
	public static void printData() {
		System.out.println("=============고객정보 조회=============");
		System.out.println("이름 : " + nameList[index]);
		System.out.println("성별 : " + genderList[index]);
		System.out.println("e메일 : " + emailList[index]);
		System.out.println("출생년도 : " + birthList[index]);
		System.out.println("==================================");
	}
	public static void deleteData() {
		for(int i=index;i<count-1;i++) {
			nameList[i] = nameList[i+1];
			genderList[i] = genderList[i+1];
			emailList[i] = emailList[i+1];
			birthList[i] = birthList[i+1];
		}
		count--;
	}
	public static char menu() {
		System.out.println("\n<명령어 목록>");
		System.out.printf("현재 count: %d, 현재 index: %d\n", count,index);
		System.out.println("Insert, Previous, Current"
				+ ", Next, Update, Delete, Quit");
		
		System.out.print("명령어 입력: ");
		char menu = scan.next().toUpperCase().charAt(0);
		
		return menu;
	}
	public static void menuProcessor(char menu) {
		switch(menu) {
		case 'ㅑ':
		case 'I':
			System.out.println("\n고객의 정보 추가을 실시합니다.");
			insertData();
			break;
			
		case 'ㅔ':
		case 'P':
			System.out.println("\n이전 정보를 조회합니다.");
			if(count==0) {
				System.out.println("데이터를 입력하세요.");
				break;
			}
			if(index<=0) {
				System.out.println("인덱스값을 변경하세요.");
				break;
			}
			index--;
			printData();
			break;
			
		case 'ㅊ':
		case 'C':
			System.out.println("\n현재 정보를 조회합니다.");
			if(count==0) {
				System.out.println("데이터를 입력하세요.");
				break;
			}
			if(index<0) {
				System.out.println("인덱스값을 변경하세요.");
				break;
			}
			printData();
			break;
			
		case 'ㅜ':
		case 'N':
			System.out.println("\n다음 정보를 조회합니다.");
			if(count==0) {
				System.out.println("데이터를 입력하세요.");
				break;
			}
			if(index==count-1) {
				System.out.println("인덱스값을 변경하세요.");
				break;
			}
			index++;
			printData();
			break;
			
		case 'ㅕ':
		case 'U':
			if(count==0) {
				System.out.println("데이터를 입력하세요.");
				break;
			}
			if(index<0) {
				System.out.println("인덱스를 변경하세요.");
				break;
			}
			System.out.println("\n"+nameList[index]+"님의 정보를 수정합니다.");
			updateData();
			break;
			
		case 'ㅇ':
		case 'D':
			if(count==0) {
				System.out.println("데이터를 입력하세요.");
				break;
			}
			if(index<0) {
				System.out.println("인덱스를 변경하세요.");
				break;
			}
			System.out.println("\n정보 삭제를실시합니다.");
			deleteData();
			break;
			
		case 'ㅂ':
		case 'Q':
			System.out.println("\n고객관리 매니저를 종료합니다.");
			System.exit(0);
			break;
			
		default:
			System.out.println("명령어를 잘못 입력하셨습니다.");
		}//switch
	}//menuProcessor

//main
	public static void main(String[] args) {
		while(true) {
			char menu = menu();
			menuProcessor(menu);
		}
	}//main
}//class







######################################################################################################
개념정리_배열의 삭제


#배열 {1,2,3,4}가 있을때 1번인덱스를 삭제하면
 1,3,4,4가 되도록 삭제해야하고 사용자한테는 시스템상 마지막 4를 안보이게해서 논리적으로는 사라진것처럼 보이게해야한다.
	??궁금:근데 왜 굳이 마지막거 널로 안채우지? 널로채우면 더 직관적이고 좋은듯한데
 

import java.util.Arrays;

public class _4ArrayDelete {
	public static void main(String[] args) {
		int[] iArr = {1,3,5,7,9,11,13};
		System.out.println(Arrays.toString(iArr));
		
		int index=3;
		for(int i=index;i<iArr.length-1;i++) {
			iArr[i] = iArr[i+1];
		}
		System.out.println(Arrays.toString(iArr));
		String[] nameList = new String[100];
		nameList[0]="홍길동";
		nameList[1]="신사임당";
		nameList[2]="이순신";
		nameList[3]="강감찬";
		System.out.println(Arrays.toString(nameList));
		//||nameList[i+1]!="0"
		
		int count = 4;
		for(int i=1;i<count-1;i++) {
			nameList[i] = nameList[i+1];			
		}
		System.out.println(Arrays.toString(nameList));
	}
}





######################################################################################################




















######################################################################################################
개념정리_실행파일만들기

<eclips->.jar만들기>
실행중인 소스코드중지
프로젝트우클릭
export
java디렉터리클릭
Runnable JAR file 클릭 -next 클릭
Launch configuration에서 빼고싶은 class 클릭
저장위치및 이름선택
finish
ok

<window>
해당위치에 생겼는지확인
jsmooth 설치

<jsmooth>
skeleton
selection의 none이라 되어있는곳 클릭
console wrapper 클릭
	-console wrapper : 도스프로그램만들때
	-windowed wrapper : 윈도우그래픽프로그램만들때

excutable클릭
excutable binary에서 .jar클릭-클릭 후 binary에 경로가 입력되는데 .jar를 .exe로 수동변경할것
	-어떤파일을 실행가능하게 만들것이냐 묻는거임
		-내생각에는 excuta에서는 exe로 만들때 이름뭘로할건지 묻는거고 그파일이름 다쓰기힘드니까 그냥 .jar가져와서
			.exe로만 바꾸는듯

2번째칸에서 실행파일의 아이콘이될 사진클릭
current directory에 '.'기호 하나만 표시

application클릭
embedded jar의 경로에 .jar클릭
	-use an embedded jar 클릭
main class위치에서 프로젝트 내 실제 실행파일로만들 클래스를 찍어줌

위에 톱니바퀴아이콘클릭
	-이때만들어지는파일은 해당 프로젝트의 클래스들을 언제든지 만들기위한 바로가기역할인가?


######################################################################################################






















######################################################################################################
개념정리_클래스 배경 및 기본코드


#객체
속성: 멤버변수, 필드
기능: 메서드



#아래 add함수를 3개 result를 3개만든것처럼 계속 코드를 재작성해야하는데 이게 낭비다(시간,인력,리소스)
	-그래서 하나의 설계를 만들어놓고 함수처럼 매번 재작성하는게 아니라 객체를 클래스로 찍어내자는것

public class _1Object_Basic1 {
	static int result1 = 0;
	static int result2 = 0;
	static int result3 = 0;
	public static int add1(int n) {
		result1 += n;
		return result1;
	}
	public static int add2(int n) {
		result2 += n;
		return result2;
	}
	public static int add3(int n) {
		result2 += n;
		return result2;
	}
	public static void main(String[] args) {
		System.out.println("1번 계산기 계산결과!");
		System.out.println("=======================");
		System.out.println(add1(6));
		System.out.println(add1(14));
		System.out.println(add1(140));
		
		System.out.println("2번 계산기 계산결과!");
		System.out.println("=======================");
		System.out.println(add2(64));
		System.out.println(add2(10));
	}
}


----------------------------------------------------


#위의 낭비를 해결(시간낭비,인력낭비,리소스낭비_코드영역) + 관리용이 (절차지향은 위처럼 모든걸 함수나 코드로 작성해야해서
							1번계산기로 넣으려면 또 배열을 만들어서 추가적으로 변수들을
							입력해 모아두어야한다. 구조체를 만들던가. 그러면 그변수와
							그변수에 맞는 함수를 외우고서 같이 실행해야하는데
							클래스는 그러한것을 모두 없애준다)


public class _2Calculator {
	int result = 0;
	int add(int n) {
		result += n;
		return result;
	}
	int sub(int n) {
		result-=n;
		return result;
	}
	int mul(int n) {
		result*=n;
		return result;
	}
	
}

public class _3CalMain {
	public static void main(String[] args) {
		_2Calculator c1 = new _2Calculator();	//1번계산기 생성
		_2Calculator c2 = new _2Calculator();	//2번계산기 생성
		
		c1.add(14);
		c1.sub(7);
		c1.mul(6);
		
		c2.add(5);
		c2.sub(4);
		c2.mul(6);
		
		System.out.println("1번계산기 결과값: "+c1.result);
		System.out.println("2번계산기 결과값: "+c2.result);		
	}
}


######################################################################################################























































































































======================================================================================================
*21.09.06_10회차(10강)
======================================================================================================
















































######################################################################################################
개념정리_객체지향프로그래밍 

클래스 내부에 속성(멤버변수)과 기능(함수)

Marker rPen = new Marker();
c와다르게 자바는 rPen앞에 에스크립터를붙여서 포인트변수화 하지 않아도 자동으로
포인트변수화시킨뒤 주소를 저장하나보다.
그럼 배열과마찬가지로 객체를 스택에서 구현은불가능한가?

modifire: 접근제한자

#객체 이용
아래보면 blackPen을 포인터변수화안해도 자동 포인트변수화가된다.
왜냐면 스택에 어차피 클래스를 만들지 못하니 무조건 포인트변수화해놓은듯하다
그럼 마찬가지로 스택에 없으니 .을 찍는경우도 *없이 .만찍어도된다.
스택이 있으면 구분하기위해 스택에선 그냥 .만찍고 포인터변수인경우 차이를 구분하기위해 *.을 찍는데
어차피 모두다 포인터로 *을 찍을거면 찍지말자고 합의했나보다.
안찍어도 그건 포인터밖에 없으니까
즉 -> .*이 무의미해졌고 .하나가 모두 함축한다는 뜻이다.


//설계용 클래스(라이브러리 클래스)는 메인메서드를 작성하지 않는다.
public class Pen {
	//객체의 속성을 나타내는것을 필드(멤버변수)라고 부름
	String color;
	int price;
	
	//객체의 기능을 나타내는 것을 메서드(멤버함수)라고 부름
	void write() {
		System.out.println(color + "색 글을 씁니다.");
	}
	
	void info() {
		System.out.println("----------pen's Info------------");
		System.out.println("색상: "+color);
		System.out.println("가격: "+price);
		//배열은 동종모음구조라 지금처럼 여러 형태의 데이터를 저장불가능하며 기능함수를
		//묶을수없다.
		
		
	}

}

public class PenMain {
	public static void main(String[] args) {
		//Pen의 기능과 속성을 사용하려면 설계용 클래스를 로딩시켜 pen 객체를 생성해야함
		Pen blackPen = new Pen();
		blackPen.color = "검정";
		blackPen.price = 400;
		
		blackPen.write();
		blackPen.info();
		
		Pen redPen = new Pen();
		redPen.color = "빨강";
		redPen.price = 600;
		redPen.write();
		redPen.info();
		
		
		System.out.println(blackPen);
		System.out.println(redPen);
				
		
		Pen bluePen = new Pen();
		bluePen.color = "파랑";
		bluePen.price = 500;
		
		bluePen.write();
		bluePen.info();
		
	
	}

}



######################################################################################################








######################################################################################################
개념정리_변수

#매개변수에 디폴트값을 넣는다고해서 c처럼 디폴트매개변수가 되지 않는다. 그런건 지원안함


public class Variable {
	//필드(멤버변수) 선언.
	int a; //초기화하지 않으면 기본값으로 자동 초기화
	
	//메서드 선언
	void printNumber(int c) {
		//지역변수 b와 매개변수 c를 선언
		int b=0;
		
		System.out.println("멤버변수: "+a);
		System.out.println("지역변수: "+b); //멤버, 매개는 초기화안되어있어도
										//출력등 사용가능한데 지역변수는 반드시
								//초기화해야 출력가능하다. 멤버나 매개는 밖에서
								//들어올것을 알기때문이다.
								//멤버변수는 초기화하지 않아도 기본값으로 자동초기화된다
								//매개는 반드시 밖에서 들어온다
		System.out.println("매개변수: "+c);
		
	}
	
	public static void main(String[] args) {
		Variable  v = new Variable();
		v.printNumber(5);
	}
}
 

######################################################################################################




















######################################################################################################
예제15)계좌관리프로그램

offshoot의 AccountManager.exe와 똑같이 프리코딩하시오.

클래스명: Account 
	멤버변수 : name, password(int), balance(int)->계좌내 잔액
	멤버함수 : 출금(withDrawMoney), 입금(deposit), 잔액조회(getBalance)
	
main클래스: AccountManager
	멤버변수 : 알아서
	멤버함수 : 알아서

######################################################################################################




답:






public class Account {
	String name;
	int password;
	int balance;
	
	void deposit(int money) {
		balance += money;
		System.out.println(money+"원 입금되었습니다.");
	}
	void withDrawMoney(int money) {
		balance -= money;
		System.out.println(money+"원 출금되었습니다.");
	}
	int getBalance() {
		return balance;
	}
}


=====================================


import java.util.Scanner;

public class AccountManagerReview {
	static Scanner scan = new Scanner(System.in);
	
	public static int pwCheck(Account p1) {
		System.out.println("계좌 비밀번호를 입력하세요.");
		System.out.print("> ");
		int password = scan.nextInt();
		if(p1.password!=password) {
			System.out.println("비밀번호가 틀렸습니다.\n메뉴로 돌아갑니다.");
		}
		return password;
	}
	
	
	
	
	public static void accountAccounting(Account p1) {
		System.out.println("계좌를 등록합니다.");
		System.out.print("이름: ");
		p1.name = scan.next();
		
		System.out.print("비밀번호: ");
		p1.password = scan.nextInt();
		
		System.out.print("처음 입금액: ");
		p1.balance = scan.nextInt();
	}
	public static int menu() {
		System.out.println("\n메뉴를 입력하세요.");
		System.out.println("1.예금 / 2.출금 / 3.잔액조회 / 4.종료");
		System.out.print("> ");
		int menu = scan.nextInt();
		
		return menu;
	}
	public static void deposit(Account p1) {
		if(pwCheck(p1)==p1.password) {	
			System.out.print("입금액 입력: ");
			int money = scan.nextInt();
			p1.deposit(money);
		}
	}
	public static void withDrawMoney(Account p1) {
		if(pwCheck(p1)==p1.password) {	
			System.out.print("출금액 입력: ");
			int money = scan.nextInt();
			
			if(money>p1.balance) {
				System.out.println("잔액부족입니다! 슈퍼가서 돈넣고 오세요^^");
				return;
			}
			
			p1.withDrawMoney(money);
		}
	}	
	public static void getBalance(Account p1) {
		if(pwCheck(p1)==p1.password) {			
			System.out.println(p1.name+"님의 계좌잔액은 "+p1.getBalance()+"원입니다.");
		}
	}
	
	public static void main(String[] args) {
		Account p1 = new Account();
		accountAccounting(p1);	
		
		while(true) {
			int menu = menu();
			
			if(menu==1) {
				deposit(p1);
			}
			if(menu==2) {
				withDrawMoney(p1);
			}
			if(menu==3) {
				getBalance(p1);
			}
			if(menu==4) {
				System.out.println("\n프로그램을 종료합니다.");
				System.exit(0);
			}
		}
	}
}





































































































======================================================================================================
*21.09.07_11회차(11강)
======================================================================================================
























































######################################################################################################
개념정리_동적할당해제개념 및 패키지



* Garbage Collecting

- 객체를 생성하는데 사용되는 키워드는 new이지만, 생성된 객체를 메모리에서 해제시키는 키워드는 존재하지 않습니다.
- 그 이유는 자바에서는 자바 가상머신(JVM)이 알아서 메모리를 관리해주며, 이를 가비지 컬렉팅이라 합니다.
- 객체가 더 이상 프로그램에서 사용되지 않으면 가비지 컬렉터가 스스로 판단해서 메모리를 해제하고 수거합니다.

	-장점: 개발자가 해제를 신경쓰지 않아도된다.
	-단점: 시시각각 메모리를 제어하지 못한다.
		-마린태어나고죽고 계속관리해야하는데 그래서 게임을 c++로 만든다.

* 패키지(package)

- 클래스는 크게 2종류가 있습니다. 하나는 개발자가 직접 만들어 사용하는 사용자 정의  클래스이고,  다른  하나는 JDK(Java Development Kit)안에 포함되어 있거나, 다른 개발자들이 미리 만들어 놓은 클래스들이 있습니다.
- 그런데 이런 클래스들은 매우 종류가 많고 비슷한 기능들을 분류시켜야 할 필요성이 있기 때문에 서로 관계가 있는 클래스들을 패키지로 묶어서 관리합니다.
- 현재 클래스에서 다른 패키지의 외부 클래스를  사용하고 싶은 경우에  import 키워드로 해당 클래스의 전체 경로(패키지  명까지 포함)를 지정해줘야 합니다.

ex) import java.util.Scanner;

- 만약 해당 패키지 안에 들어있는 모든 클래스를 사용하고 싶다면 * 기호를 넣어주면 됩니다.     ex) import java.util.*;

- package 선언 방법

1. 사용자가 임의로 패키지를 만드려면 클래스의 가장 윗부분에 패키지 구문을 포함시키면 됩니다.    ex) package store;
1. 패키지 이름은 영문 소문자로 지정하는 것을 권장합니다.
1. 대분류와 소분류 패키지를 구분할 때는 .(dot)을 사용합니다.
1. 최상위 패키지의 이름은 java로 시작할 수 없습니다. java패키지는 표준 API들의 모음을 구성해놓은 패키지입니다.
1. 자바의 키워드들도 패키지이름으로 사용할 수 없습니다.



######################################################################################################







######################################################################################################
개념정리_변수 타입

변수의 타입에는 기본타입, 참조타입이 있다.

참조타입
-배열타입
-클래스타입
-인터페이스타입

String s1 = "안녕"
String s2 = "안녕"
s1 == s2 
동일클래스라면 주소가 같게 입력되서 true
	-저장한걸또저장하네? -> cpp의 참조변수개념으로 저장됨 공간을 공유함
다른클래스라면 주소가 다르게 입력되서 false

그럼 문자열은 비교어떻게해?
아래처럼 해!

객체동등비교 메서드 : eqauls()


s1.equals(s2)
	-맞으면 트루
	-틀리면 폴스 불린자료형을 반환함
package str_equals;

public class User {
	public static void main(String[] args) {
		String id="맹탕구리";
		String id2="맹탕구";
		String pw;
		System.out.println(id.equals(id2));
		System.out.println(id.equals("맹탕구리"));
		System.out.println("랑낭".equals("랑낭1"));
	}

}




######################################################################################################












######################################################################################################
개념정리_기본 및 참조타입 개념, equals

* 기본 타입(primitive type) vs 참조 타입(reference type)

- 기본 타입이란 정수, 실수, 문자, 논리 값을 저장하는 데이터 타입입니다.
- 참조 타입이란 객체의 주소를 참조하는 타입으로 배열, 클래스, 인터페이스 타입을 말합니다.
- 기본 타입으로 선언된 변수는 실제 값(value)을 변수 안에 저장하지만, 참조 타입으로 선언된 변수는 메모리의 주소값을 변수 안에 저장합니다.
- 참조 타입으로 선언된 변수는 스택(stack)영역에 주소값을 저장하고 내부의 실제 값은 힙(heap)영역에 저장합니다.



* 참조 타입 String과 객체 동등 비교 메서드 equals()

- 자바는 문자열이 동일하다면 String 객체를 공유하도록 되어있습니다.
그래서 단순히 문자열을 String 변수에 할당한다면 같은 주소값을 갖게 됩니다.

ex) String str1 = "Hello"; String str2 = "Hello";
--> str1 == str2 -> true

- 그러나 new키워드를 사용해서 String객체를 직접 heap영역에 생성한다면 문자열의 내용이 같더라도 다른 주소값을 가지게 되므로 동등, 비동등 연산자(==, !=)의 결과가 false로 나오게 됩니다.

ex) String str3 = new String("Hello"); String str4 = new String("Hello");
--> str3 == str4 -> false

- 그래서 동일 String객체이든 다른 String 객체이든 상관없이 문자열의 내용 값 그자체를 비교할 때는 equals()  메서드를 사용해야 합    니다.


######################################################################################################











######################################################################################################
개념정리_객체지향 기술, 상속개념

* 객체 지향 프로그래밍 기술

- OOP 기술에는 은닉(캡슐화:Encapsulation), 상속(Inheritance), 다형성(Polymorphism)이 있습니다.


* 상속(Inheritance)

- OOP에서 상속은 기존의 클래스를 확장하여 새로운 클래스를 이끌어내는 것을 의미합니다.
- 상속 관계는 is a 관계를 만족하는 관계입니다.
ex) 돌고래 is a 포유류 --> 돌고래는 포유류의 속성을 가지고 있다.
- 상속은 기존의 코드를 재사용함으로써 불필요한 코드를 재작성하는 번거로움을 없앨 수 있고, 새로운 클래스를 만드는 시간과 노력을       줄일 수 있습니다.
- 자바에서는 C++에서 사용했던 다중상속의 문제점때문에 단일상속만을 지원합니다.
	-다이아몬드구조 
- 어떤 클래스가 다른 클래스로부터 상속을 받아 만들어지면 새롭게 만들어진 클래스를 자식(child or sub)클래스라고 부르며, 멤버변수       와 메서드를 물려준 클래스는 부모(parent or super)클래스라고 부릅니다.
- 상속을 하면 부모클래스의 멤버변수와 메서드가 자식클래스에 상속이 됩니다. 그러나 부모클래스의 생성자는 상속이 되지 않습니다.
- 상속을 사용하는 키워드는 extends 입니다.
- 상속을 하더라도 부모 클래스에서 private 접근제한을 갖는 멤버변수와 메서드는 상속대상에서 제외됩니다.
- 자바의 모든 클래스는 Object 클래스를 상속받고 있습니다. Object클래스는 자바의 최상위 클래스입니다.





#상속형태
-자식클래스의 이름 뒤에 extends라는 키워드를 쓰고 물려받을 클래스의 이름을 씀
	-다른클래스로부터 멤버변수와 메서드를 물려받는 클래스를 자식클래스라함

public class Student extends person {

};

#클래스를만들면서 상속만드는법
-클래스 마들때 superclass에 상속받을 클래스이름을 적으면됨


#object : 상속을 따로 지정하지 않으면 모두 object로 상속받게된다.
	-증거: 클래스만들려고키면 java.lang.Object라고 뜬다.
######################################################################################################












######################################################################################################
예제16)패키지생성 및 내부 클래스 불러오기

패키지생성
1)class에서 패키지만들기
-hello라는 package를 class에서 만들어라
	-hello하위에 bye패키지와 hi패키지를 만들고 각 패키지 내부에 패키지와 같은 이름의 class를 만들어라
		-각 패키지들은 모두 마우스로 만들어라.
2)공백 패키지만들기
-nulll(공백이란의미) 패키지를 만들어라.(클래스가 하나도 없는상태)
3)공백패키지만들고 내부에도 공백패키지만들기
	-flat, hierarchical두개로 보기좋게 해봐라


패키지이용(임폴트)
1)fruit이란 패키지를만들고 내부에 apple과 banana클래스를 만들어라.(내부설계할필요없음 임폴트만 시험할거니까)
	test란 패키지를 만들고 내부에 test란 파일을 만들어라.
2)import_ex란 패키지를만들고 내부에 ImportExample클래스를 만들어라
3)importexample클래스에서 fruit과 test패키지 내의 클래스들의 객체를 모두 만들어라.
apple과 banana는 동시에 import하고 너머지는 직접 하나하나 import하여 객체를 만들수있게하라




######################################################################################################




답:




package day0907.fruit;

public class Apple {

}

package day0907.fruit;

public class Banana {

}

package day0907.hello.bye;

public class Bye {

}

package day0907.hello.hi;

public class Hi {

}

package day0907;

import day0907.fruit.*;
//import day0907.fruit;
import day0907.hello.hi.Hi;
import day0907.hello.bye.Bye;

public class MainClass {
	Apple ap = new Apple();
	Banana bn = new Banana();
	Bye b = new Bye();
	Hi hi = new Hi();
}















######################################################################################################
예제17)상속

inherit패키지내부에 phone 패키지를 만드는데 두개를 동시에 만들어라.
그리고 phone패키지 내부에 DmbPhone, MainClass, Phone 3개의 클래스를 만들어라
그후 아래 폼을 이용해서 출력결과가 실행되게하라(Phone과 DmbPhone 클래스를 설계하라!)

Phone클래스 멤버변수: String model, String color
Phone클래스 메서드(멤버함수): powerOn, powerOff, ring(벨울리는기능_전화오는기능), hangUp(전화끊는기능)

package inherit.phone;

public class MainClass {
	public MainClass() {
		//Dmb폰 객체 생성
		DmbPhone dp = new DmbPhone("햅틱", "메탈그레이", 10);
		
		//dmb폰 객체에서 상속받은 Phone클래스의 멤버변수에 접근
		System.out.println("모델 : "+dp.model);
		System.out.println("색상 : "+dp.color);
		
		//DmpPhone에서 선언한 멤버변수에 접근
		System.out.println("채널 : "+dp.channel);
		
		
		//Dmbphone으로 만들어진 객체를이용하여 Phone에서 상속받은 메서드 호출
		dp.powerOn();
		dp.ring();
		dp.hangUp();
		
		//DmbPhone에서 선언한 메서드 호출
		dp.turnOnDmb();
		dp.changeChannel(7);
		dp.turnOffDmb();
		
		//Dmbphone으로 만들어진 객체를이용하여 Phone에서 상속받은 메서드 호출
		dp.powerOff();
	}
}


<출력결과>
모델: 햅틱
색상: 메탈그레이
채널: 10
전원을 켭니다.
벨이 울립니다.
전화를 끊습니다.
방송 수신을 시작합니다.
채널 7번으로 변경합니다.
방송 수신을 종료합니다.
전원을 끕니다.

######################################################################################################




답:


package inherit.phone;

public class Phone {
	String model;
	String color;
	
	void powerOn() {
		System.out.println("전원을 켭니다.");
	}
	void powerOff() {
		System.out.println("전원을 끕니다.");
	}
	void ring() {
		System.out.println("벨이 울립니다.");
	}
	void hangUp() {
		System.out.println("전화를 끊습니다.");
	}
}




package inherit.phone;

public class DmbPhone extends Phone{
	 int channel;
	
	 DmbPhone(String mod, String col, int ch){
		 model = mod;
		 color = col;
		 channel = ch;
	 }
	
	void turnOnDmb() {
		System.out.println("방송 수신을 시작합니다.");
	}
	void turnOffDmb() {
		System.out.println("방송 수신을 종료합니다.");
	}
	void changeChannel(int n) {
		channel = n;
		System.out.printf("채널  %d번으로 변경합니다.\n", channel);
	}

}






































































































======================================================================================================
*21.09.08_12회차(12강)
======================================================================================================






















































######################################################################################################
개념정리_overriding, overloading


* 메서드 재정의(Overriding) : 통상적으로 메서드의 기능은 같게끔 하고 내부 블록만 추가하는 것

- 메서드 재정의란 부모클래스로부터 상속받은 메서드를 자식클래스에서 행위를 바꾸거나 보완하기 위해 다시 정의해서 사용하는 것을 말합니다.

- 이는 부모클래스에서 특별한 용도로 사용하던 메서드를 자식클래스에서 다른 용도로 사용할 때 필요합니다.

- 부모클래스의 모든 메서드가 자식클래스에 맞게 설계되어 있다면 가장 이상적인 상속이지만, 특정 메서드는 자식 클래스가 사용하기 에 적합하지 않을 수도 있습니다.

- 이 경우 상속된 일부 메서드는 자식클래스에서 재정의하여 사용해야 합니다.

- 메서드가 자식클래스에서 재정의되었다면 자식객체를 통해 메서드를 호출했을 때 새롭게 재정의된 메서드가 호출됩니다.

- 메서드 재정의 규칙
1. 반드시 상속을 전제로 해야합니다.
1. 반드시 반환 유형이 같아야 합니다.
1. 메서드 이름이 같아야 합니다.
1. 매개 변수 선언이 정확히 일치해야 합니다.
1. 접근제한자는 같거나 더 제한이 없어야 합니다.(more public)


* 중복(Overloading) : 통상적으로 메서드의 기능을 변경하는 것 

- 자바는 메서드나 생성자의 중복 선언을 허용합니다.

- 중복은 메서드 또는 생성자를 선언할 때 이름은 같지만 매개 변수의 유형이나 개수를 다르게 선언해 놓는 것을 의미합니다.

- 중복을 사용하면 하나의 메서드로 매개 변수의 유형에 따라 다른 동작이 실행되게 합니다.

- 중복의 조건

1. 이름이 같아야 합니다.
1. 접근제한자나 반환유형은 영향을 미치지 않습니다.
1. 매개 변수의 유형이 달라야 합니다.
1. 매개 변수의 개수가 달라야 합니다.
1. 매개 변수의 순서가 달라야 합니다.




#차이점: 매개변수의 변화
overriding : 매개변수가 안바뀌고 외부형틀이 완전히 똑같다.
overloading : 매개변수가 변경되고 반환자료형도 변경할수있다.

공통점: 내부블록 수정가능, 기존메서드와 이름이 같음



package overloading.basic;
/*
 * 오버로딩(중복)-하나의 클래스 내부에 같은 이름을 가진 메서드를 여러개 선언할수 있게하는 문법
 * 	-부모꺼를 오버로딩할순 없는가?
 * 1.매개변수의 데이터타입이 달라야함
 * 2.매개변수의 순서가 달라야함
 * 3.매개변수의 개수가 달라야함
 */
public class Basic {
	void input(int a) {
		System.out.println("정수 1개가 입력됨");
	}
	void input(int i, int j) {
		System.out.println("정수 2개가 입력됨");
	}
	void input(String s) {
		System.out.println("문자열 1개가 입력됨");
	}
	void input(String s, double d) {
		System.out.println("문자열 1개, 실수형 1개가 입력됨");
	}
	void input(double x, String d) {
		System.out.println("실수형 1개, 문자열 1개가 입력됨");
	}
}



package overloading.basic;

public class MainClass {

	public static void main(String[] args) {
		Basic b = new Basic();
		b.input(5);
		b.input("하이");
		b.input(5,10);
		b.input(3.14,"하하");
		
		System.out.println();
	}

}


######################################################################################################














######################################################################################################
예제17)overriding

11일차의 goodcase안의 employee,main,person,student,teacher를 가져오고 아래처럼 출력되도록
오버라이딩하라(main은 손대지마라)

이름: 홍길동, 나이: 45
이름: 이순신, 나이: 23, 학번: 2018110033
이름: 강감찬, 나이: 44, 과목: 수학
이름: 신사임당, 나이: 33, 부서: 구매부

######################################################################################################




답:

package overriding.person;

/*
 * 데이터를 다른 클래스에게 물려주는 클래스를 부모클래스라고 합니다.
 * 상속을 사용할 시 데이터를 물려받는 클래스에게 부모클래스의 멤버변수,
 * 메서드가 상속됩니다.
 * 단, 생성자는 상속되지 않습니다.
 */
public class Person {
	
	String name;
	int age;
	
	String info() {
		return "이름: " + name + ", 나이: " + age;
	}
	
}



package overriding.person;

/*
 * 다른 클래스로부터 멤버변수와 메서드를 물려받는 클래스를
 * 자식 클래스라고 부릅니다. 
 * 자식 클래스의 이름 뒤에 extends라는 키워드를 쓰고 
 * 물려받을 클래스의 이름을 써줍니다.
 */
public class Student extends Person {
	String stuID;
	String info() {
		return "이름: " + name + ", 나이: " + age + ", 학번: " + stuID;
	}
	
}




package overriding.person;

public class Teacher extends Person {
	
	String subject;
	String info() {
		return "이름: " + name + ", 나이: " + age + ", 과목: " + subject;
	}
}




package overriding.person;

public class Employee extends Person {
	
	String department;
	String info() {
		return "이름: " + name + ", 나이: " + age + ", 부서: " + department;
	}
}




package overriding.person;

public class MainClass {

	public static void main(String[] args) {
		
		Person hong = new Person();
		hong.name = "홍길동";
		hong.age = 45;
		System.out.println(hong.info());
		
		Student lee = new Student();
		lee.stuID = "2018110033";
		lee.name = "이순신";
		lee.age = 23;
		System.out.println(lee.info());
		
		Teacher kang = new Teacher();
		kang.subject = "수학";
		kang.name = "강감찬";
		kang.age = 44;
		System.out.println(kang.info());
		
		Employee shin = new Employee();
		shin.department = "구매부";
		shin.age = 33;
		shin.name = "신사임당";
		System.out.println(shin.info());
		

	}

}









######################################################################################################
개념정리_this


#생성자를 메서드명으로 호출하는방법: 첫호출시밖에없음.
	-그다음부터는 this로
	-this(name, 1);
#생성자생성순서: 매개변수가 많을수록 모든 매개변수를 수용할수있는 생성자를 만든후 점점 매개변수를 줄여가는것이 좋다.
#f3을 누르면 만들어진곳으로 향할수있다.

* this

- this는 자기 자신 객체를 지정할 때 사용하는 키워드입니다.

- this. 을 사용하면 동일 클래스 내의 멤버(멤버변수, 메서드)를 참조할 수 있습니다.

- this()를 사용하면 생성자 내부에서 자신의 다른 생성자를 호출할 수 있습니다.

package this_.car;

public class Car {
	String model;
	int speed;
	Car(String model){
		this.model = model;
	}
	Car(){
		this("이름없음");
	}
	
	void accel(int speed) {
		if(this.speed >= 150) {
			System.out.println("속도를 더이상 올릴수 없습니다.");
		}else {
			this.speed = speed;
		}
	}
	void run(int maxSpeed) {
		for(int i=0;i<=maxSpeed;i+=30) {
			this.accel(i);
			System.out.printf("%s가 달립니다.(시속: %dkm/h)\n", this.model, 
					this.speed);
		}
	}
}

package this_.car;

public class MainClass {
	public static void main(String[] args) {
		Car myCar1 = new Car("람보르기니 아벤타도르");
		Car yourCar = new Car("아반떼 스포츠");
		
		myCar1.run(250);
		System.out.println("==============================");
		yourCar.run(130);
	}
}





* super

- super는 한단계 위 부모클래스의 객체를 지정할 때 사용하는 키워드입니다.

- super. 을 사용하면 부모클래스의 멤버를 참조할 수 있습니다.

- super()는 생성자 내부에서만 사용이 가능하며, 부모클래스의 생성자를 호출하는데 사용합니다.
	-생성자 외부에서는 super()로 부모클래스의 생성자를 불러오는것이안되고
	 대신에 외부에서 super.으로 메서드 혹은 변수에 접근하는건 가능하다.

package super_.person;
public class Student extends Person {
	String stuID;
	
	Student(String name, int age, String str){
		super(name, age);
		this.stuID = str;
//		this.name = name;
//		this.age = age;
		
	}
	
	String info() {
		//return "이름: " + name + ", 나이: " + age + ", 학번: " + stuID;
		return super.info() +" 학번: " + stuID;
	}
	
}

- 생성자의 첫 라인에는 반드시 this(), super()가 있어야 하는데 이를 기술하지 않으면 묵시적으로 super()가 삽입되어 부모클래스의 
기본 생성자를 자동으로 호출합니다.
	-즉 생성자 첫라인에 this()를 쓰면 super()를 안쓰고 this()를 안쓰면 자동으로 super()가 묵시적으로 삽입된다.

package super_.person;

public class Teacher extends Person {
	
	String subject;
	
	Teacher(){	//아래 주석의 teacher가 이놈의 생략형이다.
		
	}
	/*
	* Teacher(){	
	*	super(); //이렇게 묵시적으로 super가 삽입되니까 부모의 매개변수가없는 생성자를 호출하는데
	* }		//Person에서 기본생성자가 없으면 혹은 매개변수가없는 생성자가 없다면 이건 에러이고
	*			//위에 있는 teacher에도 super가 생략되있는것일뿐이니 위에도 에러가난다.
	*/
	
	String info() {
		return "이름: " + name + ", 나이: " + age + ", 과목: " + subject;
	}


- 생성자 내부에서 또다른 생성자를 호출할 때는 반드시 생성자 블록 내부의 첫 라인에 기술해야 합



-----------------------------------------------



######################################################################################################
















######################################################################################################
예제18)this, super

this_.person패키지에 있는  person student teacher를 가져온다.

아래로 했을때 출력이되도록하라
-이때 super를 모조리 이용해서하라
-super로 부모생성자를부르고
-this로 super대신 사용해라
	-this를쓰면 super가 쓰여지지않는다.
	-super로 다양한 매개변수를넣어봐라

package super_.person;

public class MainClass {

	public static void main(String[] args) {
		Student hong = new Student("홍길동", 13, "34");	
		System.out.println(hong.info());
		
		Teacher lim = new Teacher("임창정", 50, "음악");

		System.out.println(lim.info());
	}

}

이름: 홍길동, 나이: 13 학번: null	//부모꺼에서 자식객체 info 호출하여 출력된거
이름: 홍길동, 나이: 13 학번: 34	//자식꺼에서 지꺼 info 호출하여 출력된거
이름: 임창정, 나이: 50null		//부모꺼에서 자식객체 info 호출하여 출력된거
이름: 임창정, 나이: 50음악		//자식꺼에서 지꺼 info 호출하여 출력된거
######################################################################################################




답:



package super_.person;

/*
 * 데이터를 다른 클래스에게 물려주는 클래스를 부모클래스라고 합니다.
 * 상속을 사용할 시 데이터를 물려받는 클래스에게 부모클래스의 멤버변수,
 * 메서드가 상속됩니다.
 * 단, 생성자는 상속되지 않습니다.
 */
public class Person {
	
	String name;
	int age;
	
	Person(String name, int age){
		this.name = name;
		this.age = age;
		System.out.println(this.info());
	}
	Person(String name){	//생성자에서 this를 이용해 생성자호출
		this(name, 1);
//		this.name = name;
//		this.age = 1;
		//System.out.println(this.info());
	}
	Person(){
		this("이름없음", 1);
	}
	
	String info() {
		return "이름: " + name + ", 나이: " + age;
	}
	
}




package super_.person;

/*
 * 다른 클래스로부터 멤버변수와 메서드를 물려받는 클래스를
 * 자식 클래스라고 부릅니다. 
 * 자식 클래스의 이름 뒤에 extends라는 키워드를 쓰고 
 * 물려받을 클래스의 이름을 써줍니다.
 */
public class Student extends Person {
	String stuID;
	
	Student(String name, int age, String str){
		super(name, age);
		this.stuID = str;
//		this.name = name;
//		this.age = age;
		
	}
	Student(){
		this("이름없음", 1, "학번없음");	//여기는 super()가 없음 어차피 this가면 거기에
					//결국 super()를 만나기때문
	}
	
	String info() {
		//return "이름: " + name + ", 나이: " + age + ", 학번: " + stuID;
		return super.info() +" 학번: " + stuID;
	}
	
}



package super_.person;

public class Teacher extends Person {
	
	String subject;
	
	Teacher(String name, int age, String subject){
		super(name, age);
		this.subject=subject;
	}
	
	String info() {
		return super.info() + subject;
	}
}







































































======================================================================================================
*21.09.09_13회차(13강)
======================================================================================================





















































######################################################################################################
개념정리_접근제한자

modifier		same class	same package	other package	other package
							& subclass(상속)	(universe)
public				o		o		o		o
package friendly		o		o		x		x
protected			o		o		o		x
	-p.f에서 class멤버생성자에대해 제한을걸었을때 해당하는것에대해 같은패키지가 아니면 지금 이것의 사용을 허락하지않겠다 라는뜻인데
		protected는 다른패키지 원칙적으로 안되는데 부모자식관계면 이해해주겠다 라는뜻으로 이해하면 됨.
private				o		x		x		x




* 접근 제한자(Access Modifier)

- 접근 제한자는 클래스와 멤버변수, 메서드, 생성자의 접근을 제어할 수 있는 제한자입니다.
- main() 메서드가 없는 클래스는 외부 클래스에서 이용할 목적으로 설계된 라이브러리 클래스입니다.
- 라이브러리 클래스를 설계할 때는 외부 클래스에서 접근할 수 있는 멤버와 접근할 수 없는 멤버로 구분해서 변수, 생성자, 메서드를 설계하는 것이 바람직합니다.
- 외부에서 객체 생성을 막기 위해 생성자를 호출하지 못하게 하거나 객체의 특정 데이터를 보호하기 위해 해당 멤버변수에  접근하지 못하도록 막는 것이 접근 제한자의 역할입니다.
- 클래스에는 접근 제한자를 public과 package friendly만 붙일 수 있습니다.
	-클래스에선 이거고 나머지 멤버변수 메서드 생성자는 다른것도가능
	
디폴트값: p.f

- 접근 제한자의 종류

1. public: 같은 클래스, 같은 패키지, 다른 패키지를 막론하고 접근이 가능.
1. protected: 같은 클래스, 같은 패키지는 접근이 가능하지만 다른 패키지에 속해있는 클래스인 경우 상속관계가 없으면 접근이 불가능.
1. package friendly(접근 제한자를 붙이지 않는 형태): 같은 클래스, 같은 패키지에서만 접근이 가능하며  패키지가 다를  경우 접근이  불가능.
1. private: 같은 클래스 내부가 아니면 접근이 불가능.


예시는 Day13의 아래 패키지들을 참고
클래스의 public, p.f 예시
	-modi.cls.pac1,2
	
생성자의 public, p.f, private 예시
	-modi.constructor.pac1,2

멤버의 public, p.f, private 예시
	-modi.member.pac1,2

protected에 대한 멤버, 생성자 적용 예시
	-modi.protec.pac1,2

######################################################################################################













######################################################################################################
개념정리_은닉

* 은닉(Encapsulation)

- 은닉은 사용자에게 상세한 내부 구현을 숨기고 필요한 부분만 보이게 하는 것입니다.
	-꽁꽁숨겨놓는 이 은닉을 캡슐화라 한다.
- 은닉을 사용하기 위해서는 클래스의 멤버변수의 접근제한자를 private으로 설정합니다.
- 은닉된 멤버변수에 접근하기 위해서는 공개된(public) 메서드를  통해서  접근할  수 있는데,  변수의  값을 변경시키는데 사용되는  메서드 는 setter메서드라고 부르며, 변수의 값을 얻어오는데 사용하는 메서드를 getter메서드라고 부릅니다.
- 이처럼 공개 메서드를 이용하여 데이터를 변경시킬 경우 메서드 내에 데이터 유효성을 검증할 수 있는 루틴을 넣을 수 있습니다.
- 뿐만 아니라 경우에 따라 접근 권한을 체크할 수 있는 로직을 포함시키면 인가되지 않은 사용자에게 중요한 데이터나 로직을 숨길 수 도 있고, 이를 제어할 수도 있습니다.
- 멤버변수만 private 제한자를 가지는 것은 아닙니다. 외부에 공개하고 싶지 않은 메서드들도 private으로 선언할 수 있습니다.

#setter/getter두는 이유
값의 유효성을 검증하기위해
위치를 왜 main에 안두는가?
	-> 추측) main에서 사용자가 입력하면 if로 처리할수도 있지만 그럼 모든 사용자가 사용하는 main코드에 중복코드가 발생하기도하고
	   main이 아닌 다른곳에서 사용하더라도 계속 적어야한다. 그래서 연관성이 있는 기능은 해당 클래스내에 넣는것이좋기때문에
		밖에서는아예 변수에 접근못하게하고 내부에서 값의 유효성검증을하고 저장하는 기능을가진 메서드를 만들어야하는것이다.

#참고: private로두고 생성자로만 값을 넣고싶은경우 setter/getter 안만들어도됨
#참고: 부모에서 은닉후 자식에서 제한자 정의할때 똑같거나 더 public하게 만들어야한다.

#참고: eclips 기능
	-생성자 자동생성 : alt shift S or 마우스 우클릭 source -> constructor
	-gettersetter만들기또한 동일경로
	-상속시 자식메서드에서 overriding 가능


######################################################################################################















######################################################################################################
개념정리_다형성

* 다형성(Polymorphism)

- 다형성이란 "객체가 여러 형태를 가진다"라는 의미로 해석되며, 하나의 객체가 여러가지 유형으로 사용되는 것을 의미합니다.
- 다형성은 상속을 전제조건으로 합니다.
- 다형성을 위해 자바는 자식클래스가 부모클래스의 타입을 가질 수 있도록 허용합니다. 즉, 부모 타입에 모든 자식객체가 대입될 수 있습니다.

- 객체의 교환성을 제고하기 위함이다.
- 상속을 전제로 서로의 타입을 교환하여 사용할수 있다.



package poly.basic;
/*
 * 하나의 클래스 파일안에 여러 클래스들을 선언할수 있다.
 * 단 파일명과 동일한 이름을 가진 클래스가 반드시 존재해야하며 해당 클래스만 public 제한자를 
 * 가질 수 있다.
 */

class A { 
//	int a;
//	public static void main(String[] args) {
//		Basic a = new Basic();
//		a.z = 4;
//	}
}
class B extends A {}
class C extends A {}
class D extends B {}
class E extends C {}


public class Basic {
//	private int z = 5;
	
	A a = new A();
	B b = new B();
	C c = new C();
	D d = new D();
	E e = new E();
//	public static void main(String[] args) {
//		A a = new A();
//		a.a = 4;
//	}

//	a.a = 4; 왜 접근을못할까? p.f일텐데 public으로 해도안되고 
	
	A a1 = b;	//자식객체가 부모객체로 자동 형변환되는것이다.
	A a2 = c;	//궁금: byte->int로 변경할때는 byte 크기가 작아서 자동형변환되는건데
			//부모객체는 코드양이나 멤버변수 등 메모리공간 자체가 더 작은데 왜 자동형변환되지?
	A a3 = new D();
	A a4 = e;
	
	Object o1 = new A();	//object는 모든 클래스의 부모이기때문에 모든 객체의 형변환
		//가능
	Object o2 = new String();
}



######################################################################################################






































































======================================================================================================
*21.09.10_14회차(14강)
======================================================================================================






















































######################################################################################################
개념정리_다형성


* 다형성(Polymorphism)

- 다형성이란 "객체가 여러 형태를 가진다"라는 의미로 해석되며, 하나의 객체가 여러가지 유형으로 사용되는 것을 의미합니다.
- 다형성은 상속을 전제조건으로 합니다.
- 다형성을 위해 자바는 자식클래스가 부모클래스의 타입을 가질 수 있도록 허용합니다. 즉, 부모 타입에 모든 자식객체가 대입될 수 있습니다.


* 이종모음(Heterogeneous Collection)

- 이종모음구조는 배열에 다형성을 적용시키는 이유입니다. 배열은 원래 동종모음 구조입니다.
- 예를 들어 int[] iArr = new int[10]; 이런 구조의 배열이 있다면 iArr배열에는 int형 정수 데이터만 저장할 수 있습니다.
- 하지만 다형성을 이용하면 이종모음 구조의 객체 배열이 생성 가능합니다.
- 아래처럼 학생,선생,회사원을 한번에 출력하고자할때 각 객체를 동종모음구조인 배열로 만들면 배열이 3개필요하다.
	그러면 포문도 3개인데 이때 다형성을 이용한 이종모음구조로 배열을 만들면 배열1개에 for문도1개라서 매우 편리해진다.

package poly.person;

public class MainClass {

	public static void main(String[] args) {
		// TODO Auto-generated method stub

//		Student hont = new Student("홍길동", 15, "32");
//		Student lee = new Student("이순신", 17, "21");
//		Student park = new Student("박찬호", 13, "61");
//		
//		Teacher kim = new Teacher("김철수", 26, "영어");
//		Teacher song = new Teacher("송영희", 29, "수학");
//		
//		Employee lim = new Employee("임꺽정", 45, "행정");
//		
//		
//		System.out.println(hont.info());
//		System.out.println(lee.info());
//		System.out.println(park.info());
//		System.out.println(kim.info());
//		System.out.println(song.info());
//		System.out.println(lim.info());
		
		
//		Student[] students = {hont, lee, park};
//		Teacher[] teachers = {kim, song};
//		Employee[] employees = {lim};
//		
//		System.out.println("==========================");
//		for(int i=0;i<students.length;i++) {
//			System.out.println(students[i].info());
//					
//		}
//		
//		System.out.println(hont);
//		System.out.println(students[0]);
//		System.out.println(hont==students[0]);

		
		Person hont = new Student("홍길동", 15, "32");
		Person lee = new Student("이순신", 17, "21");
		Person park = new Student("박찬호", 13, "61");
		
		Person kim = new Teacher("김철수", 26, "영어");
		Person song = new Teacher("송영희", 29, "수학");
		
		Person lim = new Employee("임꺽정", 45, "행정");
		
		
		System.out.println(hont.info());
		System.out.println(lee.info());
		System.out.println(park.info());
		System.out.println(kim.info());
		System.out.println(song.info());
		System.out.println(lim.info());

		System.out.println("==============================");
		Person[] people = {hont, lee, park, kim, song, lim};
		
		for(int i=0;i<people.length;i++) {
			System.out.println(people[i].info());
					
		}
	}

}

######################################################################################################



















######################################################################################################
개념정리_다형성의 문제점

package poly.promotion;

public class Parent {
	public void method1() {
		System.out.println("부모의 1번 메서드 호출!");
	}
	public void method2() {
		System.out.println("부모의 2번 메서드 호출!");
	}
}


package poly.promotion;

public class Child extends Parent{

	public void method2() {
		System.out.println("재정의된 2번 메서드 호출!");
	}
	
	public void method3() {
		System.out.println("자식의 3번 메소드 호출!");
	}
	
}



package poly.promotion;

public class MainClass {

	public static void main(String[] args) {
		// TODO Auto-generated method stub

		Parent p1 = new Parent();
		p1.method1();
		p1.method2();
		
		System.out.println("----------------");
		
		Child c1 = new Child();
		c1.method1();
		c1.method2();
		c1.method3();
		
		Parent p2 = c1;	//Child->Parent : promotion(자동형변환)
		System.out.println(c1==p2);
		
		p2.method1();
		p2.method2();	//parent가 아니라 Child의 메서드가 나온다.
//		p2.method3();	//본인건데 안써짐 부모한테 물려받은거만 써지는데 이러면 소용이없다.
					//그래서 다음 부분에서 방법이나온다.
	}

}



부모의 1번 메서드 호출!
부모의 2번 메서드 호출!
----------------
부모의 1번 메서드 호출!
재정의된 2번 메서드 호출!
자식의 3번 메소드 호출!
true
부모의 1번 메서드 호출!
재정의된 2번 메서드 호출!


######################################################################################################












######################################################################################################
개념정리_강제형변환


package poly.casting;

public class MainClass {

	public static void main(String[] args) {
		//promotion이 적용되면 자식클래스의 본래멤버를 참조할 수 없음
		Parent p = new Child();
		p.method1();
		p.method2();
//		p.method3();
		System.out.println("-----------------------");
		
		Child c = (Child)p;
		c.method3();
		
		/*
		 * 한번 promotion이 일어난 객체를 대상으로 강제타입변환을 사용할수있음
		 */
//		Child ccc = (Child)new Parent(); //parent를 만들고 child로 바꾼거임 이럼에러
	}

}


#for문돌리기위해 promotion(자동형변환)해서 이종모음구조로도 배열을 만들수 있게하고 그렇게된녀석은 자식의 메서드를 못쓰니까
 자식의메서드를 쓰기위할때는 다시 강제형변환해서 본인의 형태로해서 사용하는 형태이다. 그래서 자동형변환후에 강제형변환을한다.
	



* 강제 타입 변환(Type Casting)

- 강제 타입 변환은 부모 타입을 자식 타입으로 변환하는 것을 말합니다.
- 객체에서 타입 캐스팅을 사용하려면 우선 먼저 Promotion이 일어나야 합니다. 즉, 부모 타입으로 한번 형 변환이 된 자식 객체만 강      제 타입 변환을 사용할 수 있습니다.
- Promotion이 일어나면 자식 클래스가 가지고 있는 재정의되지 않은 메서드를 사용할 수 없다는 단점이 있었습니다. 
	이 단점을 극복  하기 위해 강제 타입 변환을 사용하여 자식 메서드를 호출하는 방법을 사용합니다.




불편함 => 편리함추구 => 다형성필요성제기 => 형변환발전(자식객체는 부모클래스를 자료형으로 둘수있게하는 형변환promotion 및 강제형변환) 
	=> 다형성구현 => 이종모음구조 객체 배열탄생 => 코드수줄음, 배열관리용이, 결과값출력용이 등

형변환방법
-대입연산자
-매개변수
-반환자료형 

######################################################################################################

















######################################################################################################
개념정리_매개변수의 다형성


* 매개 변수의 다형성

- promotion은 멤버 변수의 값을 대입할 때도 발생하지만, 메서드를 호출할 때 사용하는 매개 변수에도 발생할 수 있습니다.
- 보통 메서드를 호출할 때는 메서드 선언부에서 지정한 데이터 타입과 일치하는 매개값을 전달하여 호출하지만, 매개 변수에 다형성을 적용하면 자식 객체를 전달할 수도 있습니다.


#매개변수의 다형성필요이유

package poly.param;

public class Car {
	public void run() {
		System.out.println("차가 달립니다.");
	}
}

package poly.param;

public class Ferrari extends Car{


	public void run() {
		System.out.println("페라리가 달립니다.");
	}
	
}

package poly.param;

public class Sonata extends Car{

	
	public void run() {
		System.out.println("소나타가 달립니다.");
	}

}

package poly.param;

public class Driver {
	public void drive(Ferrari f) {
		f.run();
	}
	public void drive(Sonata f) {
		f.run();
	}
}




package poly.param;

public class MainClass {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Driver kim = new Driver();
		Ferrari f = new Ferrari();
		
		kim.drive(f);
		
		Sonata s = new Sonata();  //이렇게하면 kim.drive(s)가 안되는 문제가있다.
									//드라이버에 매개변수에 오버로딩해야함
								//하지만 차종류 300만대가 넘어가면 오버라이딩도 300만번
								//넘많음 ㅠㅠ 비효율적임 그래서 다형성을 사용한다!
		
		kim.drive(s);
		
	}

}





------------------------------------



package poly.instanceof_;

public class MainClass {

	public static void main(String[] args) {
		printPersonInfo(new Person("닭강정",22));
		printPersonInfo(new Student("김말이", 24, "44"));
		printPersonInfo(new Teacher("볶음밥", 33,"요리"));
		printPersonInfo(new Employee("떡볶이",21, "주방"));

	}
	
	
	public static void printPersonInfo(Person p) {
		if(p instanceof Student) {
			System.out.println("***********학생의 정보***********");
		}
		else if(p instanceof Teacher) {
			System.out.println("***********선생님의 정보***********");
		}
		else if(p instanceof Employee) {
			System.out.println("***********회사원의 정보***********");
		}
		else {
			System.out.println("***********사람의 정보***********");
		}
		
		System.out.println(p.info());
	}
}







* instanceof

- 자바의 키워드 중에서 instanceof 는 객체가 지정한 클래스의 인스턴스인지 아닌지 검사할 때 사용하는 연산자입니다.
- instanceof 연산자의 왼쪽 항의 객체가 오른쪽 항 클래스의 인스턴스 즉, 오른쪽 항의 객체가 생성되었다면 true를 리턴하고, 그렇지 않으면 false를 리턴합니다.
- ex) Person p = new Student();
p instanceof Student -> true




######################################################################################################














######################################################################################################
개념정리_static 공용변수(멤버변수)


#참고: 모든 instance field(일반변수)는 int a 와 같은 방식으로 만들지만 a앞에 모두 this.이 생략되어있는 것이다.

#static 변수 예시

package static_.field;

public class MainClass {
	public static void main(String[] args) {
		Count c1 = new Count();
//		c1.a = 4;
//		c1.b = 5;	에러는 아니지만 경고가뜸 즉 정적멤버변수로 접근할때는 클래스로 접근하는것을 권장
		//Count.b = 6;
		
		
		
		c1.a++;
		c1.b++;
		System.out.println("a : "+c1.a+ "b : "+c1.b);
		
		Count c2 = new Count();
		c2.a++;
		c2.b++;
		System.out.println("a : "+ c1.a++ + "b : "+c1.b);
	}
}

#스태틱 멤버(변수, 메소드) 찾기 응용
Math.random();
->Math는 객체가 아니다 new로 못만드니까 근데 메소드를부르니 random()메소드는 스태틱 메서드인거다.
Math.PI
->클래스.변수형태로 PI는 스태틱 멤버변수다.

######################################################################################################











######################################################################################################
개념정리_static 메소드호출, 메서드사용 이유 예시

#메서드호출
package static_.method;

public class MainClass {

	public static void main(String[] args) {
		/*
		 -static이 붙은 멤버는 개체 생성없이 클래스 이름으로 직접참조가능
		 */
		System.out.println(Count.method2());
		Count.b +=50;
		System.out.println(Count.method2());
		Count.b +=20;
		System.out.println(Count.method2());

	}

}

#메서드사용 이유 예시


package static_.calc;

public class Calculator {
	
	/*
	 -계산기별로 색깔이 다를수 있기때문에 color같은 변수는 데이터를 공유시켜서는 안됨
	 -하지만 pi같은 원주율값은 계산기마다 동일하기때문에 공유해서 사용하는것이 더 바람직함
	 */
	public String color;
	public static double Pi;
	
	/*
	 -일반 멤버변수를 사용하고있는 메서드는 정적메서드로 선언하면 안됨
	 */
	public void setColor(String color) {
		this.color = color;
	}
	public String getColor() {
		return color;
	}
	
	public static double areaCircle(int r) {
		return r* r* Pi;
	}
	
}

######################################################################################################












######################################################################################################
예제19)static 메소드

1)아래의 에러를 고쳐라

package static_.method;

public class Count {
	public int a;
	public static int b;
	
	//일반메서드 선언
	public int method1() {
		a=10;
		return a+b;
	}
	//일반메서드 안에서는 일반멤버변수와 정적멤버변수를 모두 참조할수 있음
	
	//정적메서드선언
	public static int method2() {
		a=10;
		return a+b;
	}
	/*
	 -static method 내부에서는 static이 붙은 변수나 메서드만 참조할 수 있씁니다.
	 -static 블록 내부에서 non-static멤버를 참조하려면 객체생성을 통해 참조해야 함
	 */
}



######################################################################################################

답:

package static_.method;

public class Count {
	public int a;
	public static int b;
	
	//일반메서드 선언
	public int method1() {
		a=10;
		return a+b;
	}
	//일반메서드 안에서는 일반멤버변수와 정적멤버변수를 모두 참조할수 있음
	
	//정적메서드선언
	public static int method2() {
		Count c = new Count();
		c.a=10;
		return c.a+b;
	}
	/*
	 -static method 내부에서는 static이 붙은 변수나 메서드만 참조할 수 있씁니다.
	 -static 블록 내부에서 non-static멤버를 참조하려면 객체생성을 통해 참조해야 함
	 */
}















































































======================================================================================================
*21.09.11_15회차(15강)
======================================================================================================









































































######################################################################################################
개념정리_사용 제한자(Usage Level modifier)

* static

- static 제한자는 변수, 메서드에 적용되는 자바의 키워드입니다.
- static 메서드나 변수는 해당 클래스의 객체 없이도 참조할 수 있습니다.
- static 블록(static 메서드, 정적 초기화자) 안에는 static 변수만 사용해야하고, static 메서드만 호출할  수 있습니다. 
	즉 static 블록에서 non-static 멤버를 객체 생성 없이 직접 참조할 수 없습니다.
- static 제한자는 지정된 변수와 메서드를 객체와 무관하게 만들어주기 때문에 this를 가질 수 없습니다.
- static 메서드는 non-static 메서드로 재정의(Overriding) 될 수 없습니다.
- 대표적인 static 메서드는 애플리케이션의 main() 메서드입니다.
- static에 단순히 블록({ })을 사용한 경우에는 정적 초기화자라고 부르며, static 변수를 초기화하는 역할을 가지고 클래스가 로딩될 때 main() 메서드가 있더라도 그보다 앞서 딱 한번 실행됩니다.



* 정적 변수(static field)

- static 변수는 모든 객체들이 공유하는 공유변수가 됩니다.
- 그리고 객체 생성 없이 클래스 이름만으로 참조가 가능합니다.
- 정적 변수는 객체를 만들어 참조할 수도 있지만, 객체를 만들지 않고 클래스 이름만으로도 참조가 가능하기 
	때문에 이를 "클래스 변수"라고도 부릅니다.



* 정적 메서드(static method)

- static 메서드는 static 변수와 마찬가지로 해당 클래스의 객체 생성 없이도 참조가 가능하게 해줍니다.
- static 메서드에서 멤버를 참조할 때 주의해야 할 사항은 "static 메서드 안에서는 non-static 멤버를 객체 생성 없이 직접 참조할 수  
	없다"는 것입니다.
- static 메서드 안에서는 static 변수를 선언할 수 없습니다.


* 정적 초기화자(static initializer)

- 정적 초기화자는 static 변수들의 초기화에 사용합니다. 
	일반 멤버변수는 생성자에서 초기화하지만 static 변수는 객체 생성 없이도 사 용해야하므로 생성자를 통해 초기화할 수 없습니다.
- 그래서 static 변수는 정적초기화자를 통해 초기화를 합니다.
- 정적 초기화자는 클래스가 로딩될 때 생성자와 main() 메서드에 앞서 오직 단 한번만  실행되기 때문에 애플리케이션 실행 중  
	반드시  한번만 실행되어야 할 로직이 있다면 이곳에 기술하여 사용할 수 있습니다.

package static_.init;

public class Computer {
	public static String company = "LG";
	public static String model = "gram";
	public static String info;
	public int price;
	
	public Computer() {
		System.out.println("생성자 호출!");
		this.price = 1000000;
		this.info = company + "-" + model;
		//스태틱변수를 사용할때는 생성자가 생성안될수있으니 생성자로 초기화를하면안된다.
	}
	//정적변수의 초기화를 위해서는 정적 초기화자를 이용해야한다.
	static { // 정적초기화자
		System.out.println("정적 초기화자 호출!");
		info = company + "-" + model;
		//price = 10; //스태틱변수만 사용가능
		//정적초기화자 생성시기: 클래스를 로딩시킬때 딱 한번 호출됨. 그후엔 호출할수없음
				//생성자와다르게 호출불가 생성자또한 생성시 1번호출되긴하지만 
				//그 한번일때 본인들끼리 호출을 할수있다.
		//클래스 로딩방법: 여러개가있지만 둘중 하나만 있어도 정적초기화자 작동됨
		//1.객체를 생성
		//2.클래스이름을 통해 정적멤버에 접근
	}
	
}


package static_.init;

public class MainClass {

	public static void main(String[] args) {
		Computer com = new Computer();
		System.out.println(com.info);
		//System.out.println(Computer.info);
		//스태틱변수를 사용할때는 생성자가 생성안될수있으니 생성자로 초기화를하면안된다.
		//정적변수의 초기화를 위해서는 정적 초기화자를 이용해야한다.
		//객체를 만드는순간 정적초기화자가 가장먼저 호출되고 그다음 생성자
		

	}

}



* 싱글톤 패턴(Singleton Pattern)

- 싱글톤 패턴은 어떤 클래스의 객체는 오직 하나임을 보장하며, 이 객체에 접근할 수 있는 전역적인 접촉점을 제공하는 패턴입니다.
- 클래스 객체를 유일하게 하나만 생성하여 모든 곳에서 하나의 객체에 접근하게 하여, 전역의 개념으로 객체를 사용할 수 있습니다.
- 싱글톤 패턴은 객체의 생성을 제한하기 위해 사용합니다.
	-DBA(databaseaccess)같은건 하나의 객체가 연결시키고관리하면되고 더이상 객체가 있을필요없으니 이럴때 사용


package static_.singleton;

public class Singleton {
	/*
	 -싱글톤 패턴 : 객체의 생성을 1개로 제한하기 위한 디자인 패턴
	 1.외부에서 이 클래스의 객체를 생성할수 없도록 생성자를 단 1개만 선언하고 private 제한을 붙임
	 */
	int a;
	
	private Singleton() {}
	
	/*
	 2.자신의 클래스 내부에서 스스로의 객체를 1개 생성
	 */
	
	private static Singleton instance = new Singleton();
	/*
	 3.외부에서 이 클래스의 객체 생성을 요구할 경우 2번에서 미리 만들어둔 단 하나의 객체를 공개된 메서드를
	  통해 제공함
	 */
	
	public static Singleton getInstance() {
		return instance;
	}
	
	/*
	4.static화 및 접근제한 
	 외부에서 만들어진 객체를 사용할수있도록 공개된 메서드를 통해 제공하지만 결국 객체가 안만들어지면
	 	못만든다. 그래서 static을 붙이면 객체를안만들고도 클래스의 메소드에 접근가능하고 그 메소드에는
	 	클래스에서 만들어놓은 단 하나의 객체를 참조하는 참조변수가 있으니 그것으로 객체를 사용할수있다.
	 	하지만 그 반환하는 객체또한 private static으로 해주어야한다.
	 	static내부에선 static으로만 직접적으로 사용할수있고 간접적으로 사용하려면 내부에 객체를
	 	만들어서 하는 방법도 있지만 getInstance라는 메소드의 기능적인측면에서 내부에 객체까지 생성
	 	한다는것은 부자연스러움으로 외부에 따로 생성한다.
	 	private는 함부러 instance에 접근하지 못하도록 하기위한 조치이다.
	 */
}


package static_.singleton;

public class MainClass {

	public static void main(String[] args) {
		//Singleton s = new Singleton();
		
		Singleton s1 = Singleton.getInstance();
		Singleton s2 = Singleton.getInstance();
		
		System.out.println(s1);
		System.out.println(s2);
		System.out.println(s1==s2);		
		
		s1.a = 45;
		Singleton.getInstance().a = 4;
		//Singleton.instance.a = 5; // 불가 
		
	}

}


######################################################################################################






















######################################################################################################
예제20)정적초기화자 

1)아래의 소스코드에서 다른 로직을 추가하여 출력결과를 만들어라.

package static_.init;

public class Computer {
	public static String company = "LG";
	public static String model = "gram";
	public static String info;
	public int price;
	
	public Computer() {
		System.out.println("생성자 호출!");
		this.price = 1000000;
		//this.info = company + "-" + model;
		//스태틱변수를 사용할때는 생성자가 생성안될수있으니 생성자로 초기화를하면안된다.
	}

	
}


package static_.init;

public class MainClass {

	public static void main(String[] args) {
		Computer com = new Computer();
		System.out.println(com.info);
	
	}

}


<출력결과>
정적 초기화자 호출!
생성자 호출!
LG-gram


######################################################################################################


답:



package static_.init;

public class Computer {
	public static String company = "LG";
	public static String model = "gram";
	public static String info;
	public int price;
	
	public Computer() {
		System.out.println("생성자 호출!");
		this.price = 1000000;
		this.info = company + "-" + model;
		//스태틱변수를 사용할때는 생성자가 생성안될수있으니 생성자로 초기화를하면안된다.
	}
	//정적변수의 초기화를 위해서는 정적 초기화자를 이용해야한다.
	static { // 정적초기화자
		System.out.println("정적 초기화자 호출!");
		info = company + "-" + model;
		//price = 10; //스태틱변수만 사용가능
		//정적초기화자 생성시기: 클래스를 로딩시킬때 딱 한번 호출됨. 그후엔 호출할수없음
				//생성자와다르게 호출불가 생성자또한 생성시 1번호출되긴하지만 
				//그 한번일때 본인들끼리 호출을 할수있다.
		//클래스 로딩방법: 여러개가있지만 둘중 하나만 있어도 정적초기화자 작동됨
		//1.객체를 생성
		//2.클래스이름을 통해 정적멤버에 접근
	}
	
}


package static_.init;

public class MainClass {

	public static void main(String[] args) {
		Computer com = new Computer();
		System.out.println(com.info);
		//System.out.println(Computer.info);
		//스태틱변수를 사용할때는 생성자가 생성안될수있으니 생성자로 초기화를하면안된다.
		//정적변수의 초기화를 위해서는 정적 초기화자를 이용해야한다.
		//객체를 만드는순간 정적초기화자가 가장먼저 호출되고 그다음 생성자
		

	}

}























######################################################################################################
예제21)singleton싱글톤


1)아래의 출력결과가 나오도록 소스코드작성하라
	-단, 객체를 하나만 생성할수있는 싱글톤 기법으로 클래스설계하라.
	-객체를 만들면 해당 주소를 저장하는 참조변수의 명은 instance로 하고 외부에서 접근못하도록 하라.

package static_.singleton;

public class Singleton {

}



package static_.singleton;

public class MainClass {

	public static void main(String[] args) {
		//Singleton s = new Singleton();
		
		Singleton s1 = Singleton.getInstance();
		Singleton s2 = Singleton.getInstance();
		
		System.out.println(s1);
		System.out.println(s2);
		System.out.println(s1==s2);		
		
		s1.a = 45;
		Singleton.getInstance().a = 4;
		//Singleton.instance.a = 5; // 불가 
		
	}

}

<출력결과>
static_.singleton.Singleton@7852e922
static_.singleton.Singleton@7852e922
true

######################################################################################################


답:





package static_.singleton;

public class Singleton {
	/*
	 -싱글톤 패턴 : 객체의 생성을 1개로 제한하기 위한 디자인 패턴
	 1.외부에서 이 클래스의 객체를 생성할수 없도록 생성자를 단 1개만 선언하고 private 제한을 붙임
	 */
	int a;
	
	private Singleton() {}
	
	/*
	 2.자신의 클래스 내부에서 스스로의 객체를 1개 생성
	 */
	
	private static Singleton instance = new Singleton();
	/*
	 3.외부에서 이 클래스의 객체 생성을 요구할 경우 2번에서 미리 만들어둔 단 하나의 객체를 공개된 메서드를
	  통해 제공함
	 */
	
	public static Singleton getInstance() {
		return instance;
	}
	
	/*
	4.static화 및 접근제한 
	 외부에서 만들어진 객체를 사용할수있도록 공개된 메서드를 통해 제공하지만 결국 객체가 안만들어지면
	 	못만든다. 그래서 static을 붙이면 객체를안만들고도 클래스의 메소드에 접근가능하고 그 메소드에는
	 	클래스에서 만들어놓은 단 하나의 객체를 참조하는 참조변수가 있으니 그것으로 객체를 사용할수있다.
	 	하지만 그 반환하는 객체또한 private static으로 해주어야한다.
	 	static내부에선 static으로만 직접적으로 사용할수있고 간접적으로 사용하려면 내부에 객체를
	 	만들어서 하는 방법도 있지만 getInstance라는 메소드의 기능적인측면에서 내부에 객체까지 생성
	 	한다는것은 부자연스러움으로 외부에 따로 생성한다.
	 	private는 함부러 instance에 접근하지 못하도록 하기위한 조치이다.
	 */
}







package static_.singleton;

public class MainClass {

	public static void main(String[] args) {
		//Singleton s = new Singleton();
		
		Singleton s1 = Singleton.getInstance();
		Singleton s2 = Singleton.getInstance();
		
		System.out.println(s1);
		System.out.println(s2);
		System.out.println(s1==s2);		
		
		s1.a = 45;
		Singleton.getInstance().a = 4;
		//Singleton.instance.a = 5; // 불가 
		
	}

}
















######################################################################################################
개념정리_final, static final(상수)

* final

- final 키워드는 클래스, 메서드, 변수에 적용되며 abstract와 동시에 사용될 수 없습니다.
- final 클래스의 경우에는 상속이 안됩니다. 즉 서브클래스를 가질 수 없습니다.
- final 메서드는 재정의를 할 수 없습니다.
- final 변수는 값을 변경할 수 없습니다.


* final class

- 클래스 선언 시 final을 사용하면 그 클래스는 상속이 불가능해집니다.
- final 클래스는 자식 클래스를 가질 수 없고, 오직 외부에서 객체 생성을 통해서만 사용할 수 있습니다.
- final 클래스의 대표적인 예가 String 클래스입니다. 사용자가 임의로  String 클래스를 상속받아  메서드를  재정의하는  것을 방지하기 위한 것입니다.
- JAVA API DOCUMENT
--> https://docs.oracle.com/javase/8/docs/api

package final_.cls;

public final class Parent {

}
package final_.cls;

public class Child extends Parent{ //에러남 Parent에 final 이 붙었기 때문에 상속불가

}



* final 변수

- final 변수는 한번 값을 할당하면 그 값을 변경할 수 없습니다.
- final 변수는 선언시에 초기화하는 방법과 생성자를 통하여 초기화하는 방법이 있는데 만약 초기화하지 않고 남겨두면 컴파일 에러가 발생합니다.
	-private과 final의 차이 : 변경 공간	/ 공통점 : 값이 안정해져있는 상황에서 외부에서 생성자호출시에 초기화가능, 값변경 불가
		-private: 내부에서는 계속 변경가능	
			-private는 값이 정해져있어도 외부에서 생성자 호출시에 초기화가능
		-final : 내부에서도 한번 값이 정해지면 변경불가능

package final_field;

public class Person {
	public final String nation = "대한민국";
	public final String name;	//아래 생성자에 name값 초기화 안해주면 이거 에러남
		//final을 붙이면 값이한번 저장되면 변경할수 없는 변수로 만들어진다.
		//근데 이녀석은 값을 한번 저장을 안했으니 에러가 나는것
		//자동으로 null이 되긴 하지만.. 그건 final에선 값을 한번 넣은걸로 안치는 듯
	//그럼에도불구하고 이렇게 해야하는경우는 객체별로 이름을 따로 관리하고 싶은 경우 등의 상황일텐데
		//이런경우에는 한번넣겠다고 안심을 시켜주면됨 안심시키는 방법은 생성자를 이용

	/*
	 -final 변수는 한번 값이 대입되면 값을 변경할수 없는 특징이 있기때문에 선언시 직접초기화하거나
	  생성자를 통한 초기화 로직을 작성하여 데이터가 반드시 한번 저장될수 있게해야함
	  #요약
	   final 변수 사용할때 한번 값넣는 방법 2가지
	   	-선언과 동시에 초기화
	   	-선언후 생성자에서 초기화
	 */
	
//	public Person() {
//		this.name = "안녕";
//	}
	public Person(String name) {
//		this();
		this.name = name;	//위 주석이 풀리면 에러난다. 왜냐면 안녕이라고 값이 한번 들어갔기
					//때문이다.
//		this.name = "hi";	//에러
//		this.nation = "중국"; //에러
	}
	
	
}


* 상수(static final)

- 자바에서는 불변의 값을 저장하는 필드를 상수(constant)라고 부릅니다.
- 상수는  객체마다 저장할 필요가 없는 공용성을 가져야 하며, 여러가지 값으로 초기화될 수 없기때문에 static과 final 제한자를 동시   
  에 붙여 선언합니다.
- 상수 이름은 모두 대문자로 작성하는 것이 관례입니다. 카멜케이스 적용이 안되기때문에 연결된 단어라면 (_)로 단어들을 연결해줍니다.
						

#내생각
-final을 붙이고 선언과 동시에 초기화를했다면 이건 이미 상수화가 된것이다.
하지만 상수는 객체가 생성될때 만들어진다.
어떤 객체가 생성이되어도 항상 같은 값이라면 static으로 두어서 객체가 생성되기전에도 존재하도록 두는 것이 낫다.
그래서 final에 static까지 붙은듯 
 ex)final붙이고 선언과동시에 초기화하니 모든 객체에서 공용적으로 같은 값을지닌 변수를 사용할수있네?
   근데 어차피 똑같으면 객체생성전에 만들어서 혹시나 다른곳에서도 쓸수있는 클래스변수로 만들면 안될까?
	즉, 공용성을 객체뿐아닌 외부로까지 확대하면 안될까?
   static으로 만들자! 그렇게하면 객체 생성전에도 static final을 한후 선언과 동시에 초기화를 하면 가능하겠네.      
  이렇게되면 객체를 안만들어도 쓸수 있고 객체를 만들어도 쓸수있으니까 공용성이 확장되었네. 이전엔 공용성이 제한적이었으니까(객체생성유무)
   그럼 앞으로 final만 붙이고 선언과동시에 초기화한놈은 상수라고 부르지말자! 괜히 헷갈리니까!
	오케이 그럼 앞으로 상수는 static final을 붙인것만 상수다!


package final_.constant;

public class Earth {
	public static final double EARTH_RADIUS = 6400;
	public static final double EARTH_SURFACE_AREA;
	//굳이 상수를 생성과 동시에 초기화 안하겠다면 static 초기화자를 사용할수 있다.
	//하지만 정말 생성과 동시에 초기화를 안할 필요가 없다. 왜냐면 그냥 final일때는
	//생성자에서 초기화를할때 객체에 따라 final의 처음저장하는 값이 변경될수 있어서 
	//선언과 동시에 초기화를 안했다지만 지금 이건 static초기화자를 사용하든 선언과동시에 초기화를
	//하든 결과가 무조건 같다. 상수가 아닌 final이라면 결과가 달라질수있어서 사용하지만 이건의미없다.
	static {
		EARTH_SURFACE_AREA = 
				4 * EARTH_RADIUS * EARTH_RADIUS * Math.PI; 
	}
	
	public static void main(String[] args) {
		System.out.println("지구의 반지름 : " + Earth.EARTH_RADIUS + "km");
		System.out.println("지구의 표면적 : "+ Earth.EARTH_SURFACE_AREA + 
				"km^2");
	}
}

  

* final method

- final 메서드는 자식 클래스에서 부모 클래스의 메서드를 재정의하지 못하게 합니다.
- 하지만 클래스에 final이 붙지 않는다면 상속은 가능하므로 자식 클래스에서 final 메서드의 참조는 가능합니다.
		-final 메서드의 참조는 가능하다는 뜻은 부모의 메서드를 사용은 할수있되 재정의만 못할뿐이라는 뜻임 (아래예시)
- 자식 클래스에서 반드시 부모의 메서드를 기능의 변경없이 사용하도록 강요할 경우에 final 메서드를 선언합니다.
	-야 딴건 다~~ 괜찮은데 이 메서드만은 재정의하지마라 이미 완벽하다 더만지면 문제생긴다! 이런식의 뜻
- final 클래스는 자식클래스를 가질 수 없고, 오직 외부에 객체 생성을 통해서만 사용가능
- final 클래스의 대표적인 예가 String 클래스임. 사용자가 임의로 String 클래스를 상속받아 메서드를 재정의 하는 것을 방지하기 위한 것



package final_.method;

public class Parent {
	public void method1() {}
	public void method2() {}
	public final void method3() {}
	//메서드에 final붙으면 재정의 불가
}




package final_.method;

public class Child extends Parent{

	public void method1() {
		super.method1();
		System.out.println("hi재정의완료");
	}

	public void method2() {
		super.method2();
		System.out.println("hi재정의완료");
	}
	//public void method3() {}
	//Parent의 method3는 재정의불가
	
	
	public Child() {
		method1();
		method2();
		method3();
		//재정의가 불가한거지 상속받은 method3을 얼마든지 사용가능하다.
	}
}


#참고: 앞으로 api를 어떻게 사용하는지 미래의 방법을 알려주는거
- JAVA API DOCUMENT : 자바 api에 대한 사용법을 알려주는 문서사이트이다.
---> https://docs.oracle.com/javase/8/docs/api
	-구글에 java api 입력 해서 페이지 나오면 packages에 java.lang 클릭->String클릭
		string 실제 입력방법나옴 실제론 다르게입력해야하는데 new 치고 워낙많이쓰니까 스트링만 대입연산자로 허용을 해준거
	-그후 Math 패키지에서 random메서드를 찾아라

developer.naver.com : 기업들이 오픈소스로 제공하는 api를 받는방법

실력 : 적재적소에 이런 api를 가지고 집어넣어 개발하는 것

######################################################################################################







######################################################################################################
예제22)final field

1)파이널 변수를 생성후 
nation : 국적을 넣는 변수, 값은 대한민국, 선언과 동시에 초기화
name : 이름을 넣는 변수, 값은 객체에 따라 달라지도록 설계
	-단, 선언과 동시에 초기화하지말것
패키지명: final_.field
클래스명: Person
실행클래스명: MainClass




package final_.field;

public class MainClass {
	
	public static void main(String[] args) {

		
		Person kim = new Person("김한국");
		
//		kim.nation = "미국"; //에러
//		kim.name = "김마이클"; //에러
		kim.age = 17;
		kim.age = 27;
		System.out.println("국적: "+kim.nation);
		System.out.println("이름: "+kim.name);
		System.out.println("나이: "+kim.age);
		
		Person park = new Person("박중국");
		park.age = 30;
		System.out.println("국적: "+park.nation);
		System.out.println("이름: "+park.name);
		System.out.println("나이: "+park.age);
		
	}
}


<출력결과>

국적: 대한민국
이름: 김한국
나이: 27
국적: 대한민국
이름: 박중국
나이: 30

######################################################################################################


답:

package final_.field;

public class Person {
	public int age;
	public final String nation = "대한민국";
	public final String name;	//아래 생성자에 name값 초기화 안해주면 이거 에러남
		//final을 붙이면 값이한번 저장되면 변경할수 없는 변수로 만들어진다.
		//근데 이녀석은 값을 한번 저장을 안했으니 에러가 나는것
		//자동으로 null이 되긴 하지만.. 그건 final에선 값을 한번 넣은걸로 안치는 듯
	//그럼에도불구하고 이렇게 해야하는경우는 객체별로 이름을 따로 관리하고 싶은 경우 등의 상황일텐데
		//이런경우에는 한번넣겠다고 안심을 시켜주면됨 안심시키는 방법은 생성자를 이용

	/*
	 -final 변수는 한번 값이 대입되면 값을 변경할수 없는 특징이 있기때문에 선언시 직접초기화하거나
	  생성자를 통한 초기화 로직을 작성하여 데이터가 반드시 한번 저장될수 있게해야함
	  #요약
	   final 변수 사용할때 한번 값넣는 방법 2가지
	   	-선언과 동시에 초기화
	   	-선언후 생성자에서 초기화
	 */
	
//	public Person() {
//		this.name = "안녕";
//	}
	public Person(String name) {
//		this();
		this.name = name;	//위 주석이 풀리면 에러난다. 왜냐면 안녕이라고 값이 한번 들어갔기
					//때문이다.
//		this.name = "hi";	//에러
//		this.nation = "중국"; //에러
	}
	
	
}



















######################################################################################################
예제23)final 클래스 & method

1)파이널 클래스
Parent 및 Child 만들고 
Parent를 final 클래스로 변경한후
Child클래스가 Parent 클래스를 상속받도록하여 에러가 발생함을 확인하라
내부정의필요없고 안된다는것을 확인하는것이 궁극적 목적
	-클래스는 완벽하다 바꾸지마라~ 라는 뜻



2)파이널 메서드
부모클래스명: Parent
자식클래스명: Child

Child
-부모클래스 3개다 재정의(불가능한게 있는지 확인)
-부모클래스의 재정의가 안되는것확인하고 그것이 사용은 되는지 또 확인
	-확인은 생성자만들어서하던가 다른 메소드 만들어서하던가~~ 알아서

package final_.method;

public class Parent {
	public void method1() {}
	public void method2() {}
	//final 메서드인 method3선언(구현부는 블록만두고 아무것도넣지말고 위의형식과같이한다.
}

######################################################################################################


답:




2)파이널 메서드

package final_.method;

public class Parent {
	public void method1() {}
	public void method2() {}
	public final void method3() {}
	//메서드에 final붙으면 재정의 불가
}


package final_.method;

public class Child extends Parent{

	public void method1() {
		super.method1();
		System.out.println("hi재정의완료");
	}

	public void method2() {
		super.method2();
		System.out.println("hi재정의완료");
	}
	//public void method3() {}
	//Parent의 method3는 재정의불가
	
	
	public Child() {
		method1();
		method2();
		method3();
		//재정의가 불가한거지 상속받은 method3을 얼마든지 사용가능하다.
	}
}
















######################################################################################################
예제24)final을 이용한 상수화 => static final

클래스명 Earth
심폴릭상수명(public) : EARTH_RADIUS, EARTH_SURFACE_AREA
	-상수는 무조건 대문자로 적어야함. 카멜케이스안되니 단어연결시엔 언더바이용
EARTH_RADIUS는 6400으로 선언과동시에 초기화하라, EARTH_SURFACE_AREA는 선언 후 다른방식을이용하여 초기화(자동초기화는 초기화로안침)
						값: 4 * EARTH_RADIUS * EARTH_RADIUS * Math.PI

Earth 클래스에 main함수 넣어라. 아래처럼.(MainClass만들기 귀찮으니까 이렇게한듯)  

	public static void main(String[] args) {
		System.out.println("지구의 반지름 : " + Earth.EARTH_RADIUS + "km");
		System.out.println("지구의 표면적 : "+ Earth.EARTH_SURFACE_AREA + 
				"km^2");
	}

<출력결과>
지구의 반지름 : 6400.0km
지구의 표면적 : 5.147185403641517E8km^2
######################################################################################################


답:




package final_.constant;

public class Earth {
	public static final double EARTH_RADIUS = 6400;
	public static final double EARTH_SURFACE_AREA;
	//굳이 상수를 생성과 동시에 초기화 안하겠다면 static 초기화자를 사용할수 있다.
	//하지만 정말 생성과 동시에 초기화를 안할 필요가 없다. 왜냐면 그냥 final일때는
	//생성자에서 초기화를할때 객체에 따라 final의 처음저장하는 값이 변경될수 있어서 
	//선언과 동시에 초기화를 안했다지만 지금 이건 static초기화자를 사용하든 선언과동시에 초기화를
	//하든 결과가 무조건 같다. 상수가 아닌 final이라면 결과가 달라질수있어서 사용하지만 이건의미없다.
	static {
		EARTH_SURFACE_AREA = 
				4 * EARTH_RADIUS * EARTH_RADIUS * Math.PI; 
	}
	
	public static void main(String[] args) {
		System.out.println("지구의 반지름 : " + Earth.EARTH_RADIUS + "km");
		System.out.println("지구의 표면적 : "+ Earth.EARTH_SURFACE_AREA + 
				"km^2");
	}
}
















######################################################################################################
개념정리_abstract

* abstract

- abstract 키워드는 클래스와 메서드에 적용됩니다.
- 추상(abstract) 클래스는 실체 클래스들의 멤버변수와 메서드들의 이름을 통일할 목적으로 사용합니다.
	- 반드시 상속을 받아서 사용하도록 한다.
- 추상(abstract) 메서드가 있는 클래스는 반드시 추상 클래스여야 합니다.
- 그러나 추상 클래스에 반드시 추상 메서드만 선언할 필요는 없고 일반 메서드도 선언할 수 있습니다.



* 추상 클래스

- 추상 클래스는 new 키워드를 이용해서 객체를 만들지 못하고 오직 상속을 통해서 자식 클래스로 구체화 시켜야 합니다.
- 추상 클래스도 일반 클래스와 마찬가지로 멤버변수, 생성자, 메서드를 선언할 수 있습니다.
- new를 사용하여 직접 생성자를 호출할 수는 없지만 자식 객체가 생성될 때 super()를 호출하여 
	추상 클래스 객체를 생성하므로 추상 클래스도 생성자가 반드시 있어야 합니다.

* 추상 메서드

- 추상 메서드는 추상 클래스 내에서만 선언할 수 있습니다.
- 추상 메서드는 메서드의 선언부만 있고 메서드 실행 내용이 들어가는 중괄호 {}가 없는 메서드를 말합니다.
	-메서드의 구현부분이 없다.
- 추상 클래스를 설계할 때 자식 클래스가 반드시 실행 내용을 채우도록 강요하고 싶은 메서드가 있을 경우, 해당 메서드를 추상 메서 드로 선언합니다.
	-cpp에서 순수가상함수랑 비슷한듯?
- 자식 클래스에서 반드시 부모 추상클래스의 추상 메서드를 재정의하여 실행 내용을 작성해야  합니다.  그렇지  않으면  컴파일  에러가 납니다.
-추상메서드를 하나라도 포함하는 클래스는 추상클래스가 되어야한다.
 그러나 추상클래스가 반드시 추상메서드를 가질 필요는 없다.
 

본사에서 과일주문이 들어왔을때 가격을 보여주는 프로그램을 틀을 짜서 줬다.
하지만 지사마다 가격이 다달라서 가격은 지사 개발팀에서 상속받아서 재정의를 해서 가격을 넣어주어야한다.

package abs.badcase;

public class HeadStore {
	public void orderApple() {
		System.out.println("0원입니다. 가게에서 가격을 정해주세요.");
	}
	public void orderBanana() {
		System.out.println("0원입니다. 가게에서 가격을 정해주세요.");
	}
	public void orderGrape() {
		System.out.println("0원입니다. 가게에서 가격을 정해주세요.");
	}
	public void orderMelon() {
		System.out.println("0원입니다. 가게에서 가격을 정해주세요.");
	}
	
}

package abs.badcase;

public class Store extends HeadStore{
	public void orderApple() {
		System.out.println("사과 쥬스의 가격은 3000원입니다.");
	}
	public void orderBanana() {
		System.out.println("바나나 쥬스의 가격은 2800원입니다.");
	}
	public void orderGrape() {
		System.out.println("포도 쥬스의 가격은 3200원입니다.");
	}
	/*
	public void orderMelon() {
		System.out.println("멜론 쥬스의 가격은 4000원입니다.");
	}
	*/
}

package abs.badcase;

public class MainClass {
	public static void main(String[] args) {
		Store s = new Store();
		s.orderApple();
		s.orderBanana();
		s.orderGrape();
		s.orderMelon();
		
	}
}

위처럼된이유 : 사장이 깜빡하고 메론의 정보를 입력안함

위처럼되면 main에서 실행했을때 melon의 가격은 0원으로 나온다.
그럼 손님은 가격확인용 포스기에서 0원으로 봤으니 메론을 받고 그냥 가려고한다.(가격만 볼수있는 포스기)
사장이 막는다. 왜 오천원안주세요? 손님: 포스기에 0원이라 뜨길래 주문을한거다. 행사인줄알았다. 행사아닌줄 알았으면 안시켰다 하고 감
사장이 본사에 연락함.
왜 이거 입력안되면 주문 프로그램자체가 에러나게 제한을 안걸어주냐?
그대로 나오면 사장들이 실수로 입력안하면 0원나올거아냐 .
그냥 안되게 하던가 ㅡㅡ 

본사: 하 .. 이렇게까진 안하려했는데 .. 그럼 하나라도 입력안하면 무조건 에러나게 해드릴게요.
	(추상클래스와 추상메서드를 통해 오버라이딩을 강제화시켜야겠다. 오버라이딩(가격재설정)안하면 에러나도록.)

package abs.goodcase;

public abstract class HeadStore {
	
	/*
	 1.메서드에 abstract를 붙이면 해당 메서드는 추상메서드가 되며 이 메서드는 상속을 통해 자식 클래스에서
	 반드시 오버라이딩을 해야함. 그렇지 않으면 에러가 발생함
	 2.추상메서드는 실체가 존재하지 않는 메서드의 틀 역할을 하기때문에 메서드의 바디부분 {}이 없고 세미클론
	 으로 선언을 마감함.
	 3.일반 클래스에서는 추상메서드를 선언할수 없음 추상메서드가 하나라도 존재하는
	 	클래스는 반드시 추상클래스가 되어야함
	 4.추상클래스 내부에서는 추상메서드만을 선언할 필요는 없습니다.
	 	일반메서드도 모두 선언할수 있습니다.
	 */
	public abstract void orederApple();
	public abstract void orederBanana();
	public abstract void orederGrape();
	public abstract void orederMelon();//가격 재정의 안하면 에러
	
	public void orderWaterMelon() {//가격 재정의 안해도 에러안남
		System.out.println("수박 쥬스의 가격은 4000원입니다.");
	}
	public final void orderPeach() {//가격재정의 불가
		System.out.println("복숭아의 가격은 2000원입니다.");
	}
}



######################################################################################################








######################################################################################################
개념정리_abstract


추상클래스 및 추상메서드 용도
1)재정의 누락 방지
	-강제오버라이딩하도록하여 오버라이딩 안하면 프로그램실행안되도록하여 초기값입력 실수를 방지하기위함
2)메서드 이름오타 방지
	-회사에서 클래스를 만들때 메서드 이름을 문서로 전달하면 오타우려가있는데 추상클래스를 만들고 거기에
	 추상 메서드들을 입력하여 추상클래스를 뿌린후 상속받아 사용하면 반드시 해당이름으로 오타없이(있더라도 에러가나니까 고친다) 
	 메서드 입력 가능


#제한자
-접근제한자
	-public, package friendly, private, protected
-사용제한자
	-abstract, final, static

#클래스에 적용가능한 제한자
-접근제한자
	-public, package friendly
-사용제한자
	-abstract, final

######################################################################################################

















######################################################################################################
예제25)클래스 및 메소드 추상화(강제오버라이딩)


아래의 코드는 지점주인이 본사에 항의하는 코드이다.
실수로 지점주인이 오버라이딩을 안했을시 실행자체가 안해달라는 요구가 있다.
1)강제 오버라이딩 하도록 소스코드를 수정하라.
2)본사클래스에서 WaterMelon이라는 메소드와 Peach라는 메소드를 추가한다.(가격은 자유롭게/수박쥬스,복숭아)
	단, WM은 지점주인의 마음에따라 물가를 바꿀수있도록하고 
	Peach는 지점주인이 가격을 바꾸고싶어도 절대못바꾸도록 하라

package abs.badcase;

public class HeadStore {
	
	
	public void orderApple() {
		System.out.println("0원입니다. 가게에서 가격을 정해주세요.");
	}
	public void orderBanana() {
		System.out.println("0원입니다. 가게에서 가격을 정해주세요.");
	}
	public void orderGrape() {
		System.out.println("0원입니다. 가게에서 가격을 정해주세요.");
	}
	public void orderMelon() {
		System.out.println("0원입니다. 가게에서 가격을 정해주세요.");
	}
	
}

package abs.badcase;

public class Store extends HeadStore{
	public void orderApple() {
		System.out.println("사과 쥬스의 가격은 3000원입니다.");
	}
	public void orderBanana() {
		System.out.println("바나나 쥬스의 가격은 2800원입니다.");
	}
	public void orderGrape() {
		System.out.println("포도 쥬스의 가격은 3200원입니다.");
	}
	/*
	public void orderMelon() {
		System.out.println("멜론 쥬스의 가격은 4000원입니다.");
	}
	*/
}


package abs.badcase;

public class MainClass {
	public static void main(String[] args) {
		Store s = new Store();
		s.orderApple();
		s.orderBanana();
		s.orderGrape();
		s.orderMelon();
		
	}
}


#제한자
-접근제한자
	-public, package friendly, private, protected
-사용제한자
	-abstract, final, static

#클래스에 적용가능한 제한자
-접근제한자
	-public, package friendly
-사용제한자
	-abstract, final
######################################################################################################






답:






package abs.goodcase;

public abstract class HeadStore {
	HeadStore(){
		System.out.println("HEADStore생성자호출!");
	}
	/*
	 1.메서드에 abstract를 붙이면 해당 메서드는 추상메서드가 되며 이 메서드는 상속을 통해 자식 클래스에서
	 반드시 오버라이딩을 해야함. 그렇지 않으면 에러가 발생함
	 2.추상메서드는 실체가 존재하지 않는 메서드의 틀 역할을 하기때문에 메서드의 바디부분 {}이 없고 세미클론
	 으로 선언을 마감함.
	 3.일반 클래스에서는 추상메서드를 선언할수 없음 추상메서드가 하나라도 존재하는
	 	클래스는 반드시 추상클래스가 되어야함
	 4.추상클래스 내부에서는 추상메서드만을 선언할 필요는 없습니다.
	 	일반메서드도 모두 선언할수 있습니다.
	 */
	public abstract void orderApple();
	public abstract void orderBanana();
	public abstract void orderGrape();
	public abstract void orderMelon();//가격 재정의 안하면 에러
	
	public void orderWaterMelon() {//가격 재정의 안해도 에러안남
		System.out.println("수박 쥬스의 가격은 4000원입니다.");
	}
	public final void orderPeach() {//가격재정의 불가
		System.out.println("복숭아의 가격은 2000원입니다.");
	}
}



package abs.goodcase;

public class Store extends HeadStore{
//	
//	Store(){
//		super();	//자식클래스의 생성자는 항상 부모클래스의 생성자를 호출할수있다.
//					//통상적으로 마지막으로 호출되는 생성자에는 반드시 super()가 있다.
//					//그럼 추상클래스의 자식이라하더라도 부모의 생성자를호출한다.
//					//그럼으로 부모의 생성자를 부모클래스에서 설계해야한다.
//	}
//	
	public void orderApple() {
		System.out.println("사과 쥬스의 가격은 2800원입니다.");
	}
	public void orderBanana() {
		System.out.println("바나나 쥬스의 가격은 2800원입니다.");
	}
	public void orderGrape() {
		System.out.println("포도 쥬스의 가격은 2800원입니다.");
	}
	public void orderMelon() {
		System.out.println("멜론 쥬스의 가격은 2800원입니다.");
	}
	
	@Override
	public void orderWaterMelon() {
		// TODO Auto-generated method stub
		super.orderWaterMelon();
	}
//	public void orderPeach() { //에러남 final 메서드이기때문임
//		// TODO Auto-generated method stub
//		super.orderWaterMelon();
//	}
	

}





package abs.goodcase;

public class MainClass {
	public static void main(String[] args) {
		//HeadStore h = new HeadStore();//HeadStore타입으로 객체를 구체화불가하다
									//는 문구와 함꼐 에러남 -> 추상클래스이니까^^
		//추상클래스는 스스로 객체생성불가(꿈을 객체로 만들지못함)
		//반드시 상속을통해 클래스를 구체화시켜야함(설계가 안끝났는데 어떻게 객체를 만들겠냐~)
//		Store s = new Store();
		HeadStore s = new Store();
		s.orderApple();
		s.orderWaterMelon();
		s.orderPeach();
		//다형성기능 사용가능, 객체를 만드는것만 불가능하지 추상클래스로 다형성기능인 프로모션가능
		
	}
}





























































































======================================================================================================
*21.09.12_16회차(16강)
======================================================================================================









































































######################################################################################################
개념정리_인터페이스

* 인터페이스(Interface)
	-상속을해야 다형성구현이가능한데 관계없는녀석들끼리 다형성구현이 필요한경우 이때도 굳이 상속을해야하나? 이런생각으로 시작되어 생성
	-다형성과 추상클래스개념이 섞여있데

- 자바의 인터페이스는 객체의 사용 방법을 정의한 타입으로 객체의 교환성을 높여주기 때문에 다형성을 구현하는 매우 중요한 역할을 합니다.
- 인터페이스를 선언할 때는 interface 키워드를 사용하며, 클래스에서 인터페이스를 구현할 때는 
	클래스 이름 뒤에 implements 키워드를 사용하여 구현합니다.
- 클래스는 멤버변수, 생성자, 메서드를 구성 멤버로 가지지만 인터페이스는 상수와 추상메서드만을 구성멤버로 가집니다.
- 인터페이스는 데이터를 저장할 수 없기 때문에 데이터를 저장할 객체 또는 정적 변수를 선언할 수 없습니다.
- 따라서 인터페이스 선언된 변수는 public static final을 생략하더라도 컴파일 과정에서 자동으로 붙게 됩니다.
- 인터페이스의 메서드를 추상메서드 형식으로 선언하면 abstract를 붙이지 않더라도 자동으로 컴파일 과정에서 붙게 됩니다.
- 클래스가 상속 가능한 것처럼 인터페이스도 extends 키워드를 사용하여 인터페이스 간의 상속을 구현할 수 있으며. 
	다중 상속도 표현 할 수 있습니다.


//interface의 이름을 만들때는 앞에 I를 붙인다
	-자바든 클래스이든 .java로 확장자가 같기때문에 구분할게 있어야함

#자바에서 다형성을 가지기위한방법
-상속 : 자식(본인)객체가 부모클래스의 타입을 물려받을수있다.
-interface : 본인객체가 interface의 타입을 물려받을수 있다.


package inter.basic;

public interface Inter2 {
	int ABC = 10;
	void method2();
	
}

package inter.basic;

/*
 * 1.인터페이스를 사용하려면 클래스에서 해당 인터페이스를 구현해야 함.
 * 2.인터페이스를 구현하는 키워드는 implements임
 * 3.인터페이스를 상속과 달리 여러 인터페이스들을 동시에 다중구현할수있음
 * 4.인터페이스를 구현할때 인터페이스 내부에 선언된 추상메서드들을 반드시 전부 재정의해야함
 */



#interface특징
-단일상속으로 표현할수 없는 부분을 인터페이스로 채워넣을수 있다.
-인터페이스의 메서드는 추상메서드여야함
-인터페이스의 변수는 자동으로 상수가 됨
-인터페이스를 구현할때는 implements
-인터페이스를 여러개 implements할수 있다.
-인터페이스는 다른 인터페이스를 여러개 extends할수 있다.
	-인터페이스끼리 상속이 가능하다.
		-다중상속가능
-강제오버라이딩을 통해 기능의 명세를 위해 사용
######################################################################################################




<예시코드>


package inter.basic;

public interface Inter1 {
	//인터페이스에 변수를 서언하면 자동으로 상수 취급한다.
	//디폴트값이 상수라는 뜻
	public static final double INCH = 2.54;
//	double HI = 3.4;
	
	//인터페이스에 메서드를 선언하면 추상메서드로 취급됨
	//즉 객체를 만들수없다. 다형성을 만들기위한 거기때문에 그럼
	abstract void method1();
//	void method2();
}



package inter.basic;

public interface Inter2 {
	int ABC = 10;
	void method2();
	
}


public class InterClass implements Inter1, Inter2{
	public void method1() {
		System.out.println("Inter1의 메서드구현");
	}
	public void method2() {
		System.out.println("Inter2의 메서드구현");
	}
	public void method3() {
		System.out.println("클래스의 메서드호출!");
	}
}


package inter.basic;

public class MainClass {

//	public static final int a = 4;
	public static void main(String[] args) {
		//인터페이스는 객체를 생성할 수 없음
//		Inter1 i = new Inter1();
		InterClass ic = new InterClass();
		
		System.out.println(Inter1.INCH);
		System.out.println(Inter2.ABC);
//		System.out.println(ic.INCH);	//객체로도 접근가능하지만 저둘은 상수처리되었으니
//		System.out.println(ic.ABC); 	//객체가없어도 만들수있음으로 공용성있게 inter
										//face를 이용해서 호출한다.
										//즉 상수들을 모아놓고 사용할때 유용하게 취급됨
		System.out.println(ic.INCH);
		//ic.INCH; 이렇게 sys없이 선언만 해두면 에러남 상수특징인가?> 실험해보니 특징인듯(a)
		
//		System.out.println("a");
		
		ic.method1();
		ic.method2();
		ic.method3();

		/*
		 * -인터페이스 이름도 하나의 타입으로 취급가능
		 * -인터페이스를 통해 상속 없이도 다형성 구현 가능
		 * 	원래다형성 뜻 : 부모클래스의 타입을 자식객체가 사용할수있다.
		 */
		
		Inter1 i1 = ic;
		Inter2 i2 = new InterClass();
		
		
		i1.method1();
//		i1.INCH;
		i2.method2();
//		i2.ABC;
		
//		i2.method1();
//		i2.method3();
//		i2.INCH;
		
		
		InterClass icc = (InterClass)i1;
		InterClass icc2 = (InterClass)i2;
		
		icc.method1();
		icc.method2();
		icc.method3();
		icc2.method1();
		icc2.method2();
		icc2.method3();
		
		
		
	}

}































######################################################################################################
예제26)interface를 구현하고 상속을 이용해서 java의 단일상속의 부족한부분을 보완하기


pacage : inter.pet
0)IPet interface를 구현한 클래스로 만들어진 객체에 대해 돌본다는 메세지를 출력하는 기능 하나만 가진 class: PetShop
	-메서드명 : void carePat


1)class: Animal 
추상메서드 void eat 선언

2)class: Fish
추상메서드 void swim 선언

3)interface: Ipet
추상메서드 void play 선언

4)Animal을 상속받고 interface인 Ipet을 구현하는 클래스 : Dog, Cat
	-Animal만 상속받는 클래스 : Tiger(Ipet 구현 x)
-Dog
	-play(밖)와 eat(사료) 재정의
-Cat
	-play(방)와 eat(생선) 재정의
-Tiger
	-eat(고기) 재정의

5)Fish를 상속받고 interface인 Ipet을 구현하는 클래스 : GoldFish
	-Fish만 상속받는 클래스 : Shark(Ipet 구현 x)

-GoldFish
	-play(어항), swim(강)
-Shark
	-swim(바다) 

6)MainClass 
-Dog 객체 baduk 생성
-Cat 객체 nabi 생성
-Tiger 객체 hodol 생성

-다형성적용하여 이종모음 배열변수 animals 선언, 공간생성, 동시에 주소값 초기화
-향상된 포문을 이용해서 animals에 있는 객체들이 뭘 먹는지 각각 출력
-System.out.println("---------------------------"); 출력

-interface IPet배열타입 변수 pets 선언 및 공간생성(IPet공간 3개로 이루어진 공간)
-기본값으로 들어가있는 곳에 3개다 animals의 값들로 값 초기화 (안되는거 하나 확인)
-GoldFish() 공간만들고 안됐던 칸에 공간의 주소를 저장
-IPet 배열변수 pets가 저장하는 배열의 주소들을 참조하여 해당 객체들이 뭘하고 노는지 확인

-System.out.println("--------------------------");

-PetShop 객체 생성 후 내부 메서드 carePet의 매개변수를 이용한 다형성적용으로 baduk, nabi, GoldPish를 그대로 넣어도 이상없이
	뭘돌보는지 출력하도록 할것
	-그이후 nabi를 선언부로 올라가서 Animal으로 참조변수의 타입을 변경함으로 다형성 적용후 carePet메서드 정상작동되도록 해봐라
		-한마디로 upcasting 됐던거를 다시 downcasting 해보라는거임 downcasting을 안하면 carePet이 에러나니까.

######################################################################################################






답:



package inter.pet;

public interface IPet {
	public abstract void play();
}




package inter.pet;

public abstract class Animal {
	public abstract void eat();
}


package inter.pet;

public class Cat extends Animal implements IPet {

	public void play() {
		System.out.println("고양이는 방에서 놀아요~");
	}
	public void eat() {
		System.out.println("고양이는 생선을 먹어요~");
	}

}

package inter.pet;

public class Dog extends Animal implements IPet {
	
	public void play() {
		System.out.println("강아지는 밖에서 놀아요~");
	}
	public void eat() {
		System.out.println("강아지는 사료를 먹어요~");		
	}
	

}

package inter.pet;

public class Tiger extends Animal {

	public void eat() {
		System.out.println("호랑이는 고기를 먹어요.");
	}

}



package inter.pet;

public abstract class Fish {
	public abstract void swim();
}

package inter.pet;

public class GoldFish extends Fish implements IPet {

	
	public void play() {
		System.out.println("금붕어는 어항에서 놀아요~");

	}

	
	public void swim() {
		System.out.println("금붕어는 강에서 헤엄쳐요~");

	}

}


package inter.pet;

public class Shark extends Fish {
	public void swim() {
		System.out.println("상어는 바다에서 헤엄쳐요~");
	}

}



package inter.pet;

public class PetShop {
	public void carePet(IPet pet) {
		if(pet instanceof Dog) {
			System.out.println("강아지를 돌봅니다.");
		} else if (pet instanceof Cat) {
			System.out.println("고양이를 돌봅니다.");
		} else if (pet instanceof GoldFish) {
			System.out.println("금붕어를 돌봅니다.");
		}
	}
}




package inter.pet;

public class MainClass {

	public static void main(String[] args) {
		Dog baduk = new Dog();
		Animal nabi = new Cat(); //여기는 상관없지만 아래 pets[1]에서 에러남
			/*
			 * animal과 ipet은 상관이 없기때문에 아래에서 ipet이 animal부분을 담을수없음
			 * 애초에  nabi가 Cat으로 만들어지면 interface의 상수와 메소드부분을 가지고,
			 * 부모의 멤버와 생성자를 가진다. 그러다가 다형성으로 Cat이 Animal이 되면
			 * Animal클래스가 가진 멤버와 생성자밖에 못쓰고 Cat의 고유한 멤버는 사용할수없다.
			 * 이는 interface도 마찬가지다. 
			 */
		//위에 Animal nabi했을때 아래에서 에러안나게하려면 강제형변환해주면됨
		
		//Cat nabi = new Cat();
		
		Tiger hodol = new Tiger();
		
		Animal[] animals = {baduk, nabi, hodol};
		
		for(Animal a : animals) {
			a.eat();
		}
		System.out.println("---------------------------");
		IPet[] pets = new IPet[3];
		
		pets[0] = baduk;
//		pets[1] = nabi;
//		pets[1] = (Cat)nabi;
		pets[1] = (IPet)nabi;
		
		
//		pets[2] = hodol; //Tiger 클래스는 interpace로 IPet을 상속받지 않았다.그래서
			//다형성불가
//		pets[2] = (IPet)hodol;	//컴파일에러는 안뜨지만 런타임에러가 뜸
						//hodol이는 interpace가 구현되지 않았기 때문임
		
		//pets[2] = new Shark();
		
		pets[2] = new GoldFish();
		
		for(IPet pet: pets) {
			pet.play();
		}
		
		System.out.println("--------------------------");
		
		PetShop shop = new PetShop();
		shop.carePet(baduk);
		System.out.println("--------------------------");
		shop.carePet((IPet)nabi);
		shop.carePet(pets[2]);
	}

}



































######################################################################################################
개념정리_예외처리

#error 종류
-serious error
	-컴퓨터사항이 낮은걸로 돌려서나는 에러라든지 프로그램의 문제가 아닌것으로 나는 오류
-mild error
	-프로그램의 문제
	-checked exception(대부분이 문법적에러, 컴파일에러라고도 한다)
	-unchecked exception(컴파일에는 문제없는데 실행하다가 오류가난경우, runtime 에러라한다)
	-위 2가지를 예외라한다.

-예외클래스
	object(클래스)

	Throwable(클래스)

error(클래스)	exception(클래스)
serious에대한	unchecked exception(runtimeException(클래스))
에러를 담고있는클래스	checked exception(컴파일에러와 관련된것을 담고있는 클래스들이 있음)


* 예외 처리(Exception)
	
- 에러에는 심각한 에러(serious error)와 가벼운 에러(mild error)가 있습니다. 
	심각한 에러는 시스템 상의 문제로 인한 에러로 개발자가 처리할 수 없는 에러를 말합니다. 
	가벼운 에러는 개발자가 코드를 통해 처리할 수 있는 에러를 말하며 이 방식을 예외처리라고 합니다.
- 예외에는 컴파일러 체크 예외와 실행 예외(Runtime Exception)가 있습니다.
- 컴파일러 체크 예외는 자바 소스를 컴파일하는 과정에서 예외 처리 코드를  검사하여 예외 처리 코드가 없다면 컴파일 오류가 발생합니다.
- 실행 예외는 컴파일하는 과정에서 예외처리 코드를 검사하지 않는 예외를 말합니다.
- 예외 처리는 컴파일 예외와 실행 예외에 대한 대처방법입니다.
- 예외 처리는 시스템 스스로 오류를 복구하는 것이 아니고 오류 발생 가능성이 있는 부분에 대한 처리를 미리 프로그래밍 해주는 것입니다.
- 프로그램에서 문제가 될만한 부분을 예상하여 사전에 "문제가 발생하면 이렇게 처리하라" 라고 프로그래밍 하는 것을 예외 처리라고합니다.



#예외처리 문법
	-사용가능 위치 : 생성자 내부 혹은 메서드 내부만 가능
		-클래스 내부에 직접적으로 사용 불가

try{
	예외발생 가능성이 있는 코드
} catch(Exception e){
	예외 발생시 실행할 코드
}

예외가 발생하면 트라이 종료 후 catch실행
예외가 발생안하면 케치실행안하고 트라이블록 실행

package exception.trycatch;

public class TryCatchExample1 {
	public static void main(String[] args) {
		
		int i = 10;
		int j = 0;	//0이면 반드시 에러남 즉 에러가능성이있는코드라서 예외 가능성이있다고함			
		
		System.out.println(i*j);
		try {
			System.out.println(i/j);
			//예외가 발생한곳에서 바로 catch로 가기때문에 아래 코드 실행안됨
			System.out.println("예외 발생시 이 텍스트는 출력되지 않음");
		}catch(Exception e) {
			System.out.println("0으로 나눌 수 없습니다.");
		}
		System.out.println(i+j);
		System.out.println(i-j);
	}
}




######################################################################################################
































######################################################################################################
개념정리_runtime exception


* 실행 예외(Runtime Exception)

- 실행 예외는 컴파일러가 예외 처리 코드를 체크하지 않기 때문에 오로지 개발자의 경험에 의해서 예외 처리 코드를 삽입해야 합니다.
- 만약 개발자가 실행 예외에 대해 예외처리 코드를 넣지 않았을 경우 해당 예외가 발생하면 프로그램은 곧바로 종료됩니다.
	-0으로 나누면 에러나는거같은걸 말하는거다. 실행중에 발생하는 예외
- 주요 실행 예외

1. NullPointerException
- 객체 참조가 없는 상태, 즉 null 값을 갖는 참조 변수로 객체 접근 연산자인 dot(.)를 사용했을 때 발생합니다.

2. ArrayIndexOutOfBoundsException
- 배열에서 인덱스 범위를 초과하여 사용할 경우 발생합니다.
	-배열의 범위를 넘어선 참조

3. NumberFormatException
- 문자열로 되어 있는 데이터를 숫자로 변경하는 경우에 발생합니다.

4. ClassCastException
- 형 변환은 부모 클래스와 자식 클래스간에 발생하고 구현 클래스와 인터페이스 간에도 발생합니다. 이러한 관계가 아니라면 다른 클     래스로 타입을 변환할 수 없습니다.
- 상속관계나 인터페이스 관계가 없는 클래스들을 억지로 형 변환 할 경우 발생합니다.

5. ArithmeticException
-0으로 나누는경우 발생



######################################################################################################






































######################################################################################################
예제27)기본적인 RunTimeException case 



1. 
- 객체 참조가 없는 상태, 즉 null 값을 갖는 참조 변수로 객체 접근 연산자인 dot(.)를 사용했을 때 발생합니다.


package exception.runtime_exception;

public class ? {
	public static void main(String[] args) {
		String a = "15";
		String b = "13";
		
		System.out.println(a+b);
		
		//문자열 수치변환
		//str -> int 변환
		//Integer.parseInt(문자열) 메서드 이용
		
		int i = Integer.parseInt(a);
		int j = Integer.parseInt(b);
		System.out.println(i+j);
	
		
		//parseInt는 문자열 내부에 순수한 정수가 들어있어야만 변환을 실행하며  정수값이 아닐
		//경우 NumberFortmatException이 발생함
		
		String str = "hello";
//		int e = Integer.parseInt(str);	//에러
		
		
	}
}



2. 
- 배열에서 인덱스 범위를 초과하여 사용할 경우 발생합니다.
	-배열의 범위를 넘어선 참조

package exception.runtime_exception;

public class ? {

	public static void main(String[] args) {
		int[] arr = {3, 6, 9};
		System.out.println(arr[2]);
//		System.out.println(arr[3]); //분명 없는 인덱스를 []에 넣었는데도 checked
			//exception이 발생안함. 즉 컴파일에러가 안뜸 근데 이건 돌리면에러가남
		//이게바로 runtime error이면서 unchecked exception
	}

}




3. 
- 문자열로 되어 있는 데이터를 숫자로 변경하는 경우에 발생합니다.



package exception.runtime_exception;

public class ?{
	public static void main(String[] args) {
		String a = "15";
		String b = "13";
		
		System.out.println(a+b);
		
		//문자열 수치변환
		//str -> int 변환
		//Integer.parseInt(문자열) 메서드 이용
		
		int i = Integer.parseInt(a);
		int j = Integer.parseInt(b);
		System.out.println(i+j);
	
		
		//parseInt는 문자열 내부에 순수한 정수가 들어있어야만 변환을 실행하며  정수값이 아닐
		//경우 NumberFortmatException이 발생함
		
		String str = "hello";
//		int e = Integer.parseInt(str);	//에러
		
		
	}
}






4. 
- 형 변환은 부모 클래스와 자식 클래스간에 발생하고 구현 클래스와 인터페이스 간에도 발생합니다. 이러한 관계가 아니라면 다른 클래스로 
	타입을 변환할 수 없습니다.
- 상속관계나 인터페이스 관계가 없는 클래스들을 억지로 형 변환 할 경우 발생합니다.
	-upcasting된 부모타입객체의 원객체(자식객체)가 아닌데 타 자식객체가 부모타입객체를 다시 downcating한 경우
		-부모가 같은 자식 a,b 객체중에 b객체참조변수에 부모로 upcasting한 주소 저장
		-b객체참조변수가 참조하는 객체를 a로 downcasting할때 이런 경우가 일어남 b에는 b와 부모꺼만있는데 a껄하면 당연히안되지
	-근데 착각하는경우: 다형성에서 upcasinting이 되기전에 downcasting될수는 없다.(부모객체로 만들고 자식타입으로 다형성구현불가)
			이건 문법으로 정해진것이다. up되기전에 down이 되면 다른검사없이 바로 컴파일에러를띠운다.
			그래서 이경우는 컴파일이 뜬다. 컴파일이뜨니까 어뭐야 이럼 실행예외가 아니잖아? 라고 생각하지 않길 바란다.


package exception.runtime_exception;

class Animal {}
class Dog extends Animal {}
class Cat extends Animal {}

public class ?{
	public static void main(String[] args) {
		Dog d = new Dog();
		Animal da = d;
		d = (Dog)da;
		System.out.println("타입변환 성공!");
		
		Animal c = new Cat();
	//	Cat c = new Cat();
//		Dog d2 = (Dog)c; 이건 컴파일에러가 잡아냄
		Dog d2 = (Dog)c;	//이건 컴파일에러가 안잡힘 animal이라는 동일부모 공통점이있어서
							//그런건가? 한번 업캐스팅이 된녀석을
							//다운캐스팅하는거니까 업캐스팅된게 Dog였는줄아는건가
						//Cat c를 하면 upcasting이 안일어났는데 downcasting
		//하려고해서 컴파일이 이건 잡는거고 두번째는 up후 down이고 부모가 같아서 그거까진
		//못잡아내나봄 컴파일이?
		System.out.println("타입변환");
		
	}
}




5.
- 0으로 나누는경우 발생


package exception.trycatch;

public class TryCatchExample1 {
	public static void main(String[] args) {
		
		int i = 10;
		int j = 0;	//0이면 반드시 에러남 즉 에러가능성이있는코드라서 예외 가능성이있다고함			
		
		System.out.println(i*j);
		try {
			System.out.println(i/j);
			//예외가 발생한곳에서 바로 catch로 가기때문에 아래 코드 실행안됨
			System.out.println("예외 발생시 이 텍스트는 출력되지 않음");
		}catch(Exception e) {
			System.out.println("0으로 나눌 수 없습니다.");
		}
		System.out.println(i+j);
		System.out.println(i-j);
	}
}


######################################################################################################






답:


1. NullPointerException
- 객체 참조가 없는 상태, 즉 null 값을 갖는 참조 변수로 객체 접근 연산자인 dot(.)를 사용했을 때 발생합니다.

2. ArrayIndexOutOfBoundsException
- 배열에서 인덱스 범위를 초과하여 사용할 경우 발생합니다.
	-배열의 범위를 넘어선 참조

3. NumberFormatException
- 문자열로 되어 있는 데이터를 숫자로 변경하는 경우에 발생합니다.

4. ClassCastException
- 형 변환은 부모 클래스와 자식 클래스간에 발생하고 구현 클래스와 인터페이스 간에도 발생합니다. 이러한 관계가 아니라면 다른 클래스로 
	타입을 변환할 수 없습니다.
- 상속관계나 인터페이스 관계가 없는 클래스들을 억지로 형 변환 할 경우 발생합니다.

5. ArithmeticException
-0으로 나누는경우 발생









































######################################################################################################
개념정리_finally

try{
}catch(){

}finally{

}

finally 
-예외 발생여부와 관계없이 항상 실행할 코드
-입력후 객체반납 



* try~ catch~ finally
	
- 프로그램에서 예외가 발생했을 경우 프로그램의 갑작스러운 종료를 막고, 정상 실행을 유지할 수 있도록 처리하는 코드를 예외 처리  코드라고 합니다.
- try~ catch ~ finally 블록은 생성자 내부나 메서드 내부에서  작성되어 컴파일  예외와 실행  예외가 발생할 경우에  예외  처리를  할 수  있게 해줍니다.
- try 블록에는 예외 발생 가능성이 있는 코드를 작성합니다. try 블록의 코드가 예외 발생 없이 정상 실행되면 catch 블록은 실행되지 않습니다.
- try 내부에서 예외가 발생하면 즉시 실행을 멈추고 catch 블록으로 이동하여 예외 처리 코드를 실행합니다.
- 예외 발생 여부와 상관없이 항상 실행할 내용이 있다면 finally 블록 내부에 실행 내용을 작성합니다.




* finally 구문이 실행되지 않는 경우

1. finally 구문 이전에 System.exit() 구문을 호출했을 시
1. 컴퓨터가 꺼져서 시스템이 멈추었을 시
1. finally 블록 내부에서 예외가 발생했을 시(내부에 try catch를 넣어줌)
######################################################################################################







































######################################################################################################
예제28)try~catch~finally

1)아래의 코드에서 예외처리하라
	-단, System.out.println("이문장은 항상 실행됨^_^"); 코드는 실행예외의 여부와 관계없이 실행되도록 하라

package exception.trycatch;

public class TryCatchExample2 {
	public static void main(String[] args) {
		String[] greetings = {"안녕", "헬로", "니하오"};
		int i =0;
		while(i<4) {
			System.out.println(greetings[i]);
			i++;
		}
		System.out.println("프로그램 정상실행종료!");
	}
}



* finally 구문이 실행되지 않는 경우

1. finally 구문 이전에 System.exit() 구문을 호출했을 시
1. 컴퓨터가 꺼져서 시스템이 멈추었을 시
1. finally 블록 내부에서 예외가 발생했을 시(내부에 try catch를 넣어줌)

######################################################################################################






답:


package exception.trycatch;

public class TryCatchExample2 {
	public static void main(String[] args) {
		String[] greetings = {"안녕", "헬로", "니하오"};
		int i =0;
		while(i<3) {
			try {
				System.out.println(greetings[i]);				
			} catch(Exception e) {
				System.out.println("배열의 참조범위를 벗어남");
			} finally {
				System.out.println("이문장은 항상 실행됨^_^");
			}
			System.out.println("이문장도 항상 실행되지않나?");
			i++;
		}
		System.out.println("프로그램 정상실행종료!");
	}
}











































######################################################################################################
개념정리_MultiCatchException

* 다중 catch

- try 블록 내부는 다양한 종류의 예외가 발생할 수 있습니다. 예외가 여러 가지 발생한다면 다중 catch 블록을 작성하여 예외들을 처리합니다.
- 다중 catch 블록을 작성할 때 주의할 점은 상위 예외 클래스가 하위 예외 클래스보다 아래쪽에 위치해야 합니다.
- catch 블록은 위에서부터 차례대로 검색되므로 상위 예외 클래스의 catch 블록이 위에 있다면 하위 예외 클래스의 catch블록은 실행되지 않습니다.
- 자바 7 버전부터 하나의 catch 블록에서 여러 개의 예외를 처리할 수 있도록 기능이 추가되었습니다.
- catch() 괄호 안에 동일하게 처리하고 싶은 예외를 | 로 연결하면 됩니다. 이 방식을 사용할 때는 두 예외가 상속 관계가 있으면 안됩 니다.




######################################################################################################



































######################################################################################################
예제29)MultiCatchExample


0)멤버변수선언
String data1, data2;
int val1, val2;
int result;
Scanner sc;

1)데이터입력
"1번째 데이터 : "
"2번째 데이터 : "

위 형식으로 숫자로만 구성된 문자열 데이터 입력받아서 1번째 데이터는 data1, 2번째 데이터는 data2에 저장

2)데이터타입변경하여 숫자로 만들기
-위에 입력받은 데이터들을 각각 반환하여 int형 데이터로 변경한 후 아래의 관계로 val1, val2에 저장

data1 -> val1
data2 -> val2

3)사칙연산수행
-val1을 val2로 나누어 몫을 반환
-반환된값을 result에 저장

4)출력
-"val1 / val2 = result"의 형태로 출력
	-val1,val2,result의 자리는 실제 변수에서 반환된 값이 들어가야함

5)예외처리
ㄱ.예외발생 가능성 있는 구간 : 1), 3)
-1) : NumberFormatException
-3) : ArithmeticException

ㄴ.예외발생시 처리
-1) : "데이터를 숫자만 넣어주세요." 출력 후 다음 영역실행
-3) : "0으로 나눌 수 없습니다." 출력 후 다음 영역실행
-추가로 예기치 못한 에러발생시 :

ㄷ.반드시 수행해야할 것
-입력할때 사용한 객체자원 반환
-그밖의 자원반납

+예기치못한에러는 위에꺼 다실행하고 아래의 테스트코드 넣어서 실험해본다.(NullPointerException)

위치 : 3)아래에 넣음
String str = null;
str.charAt(0);


######################################################################################################






답:







package exception.multy;

import java.util.Scanner;

public class MultiCatchExample {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		
		try {
			System.out.print("1번째 데이터: ");
			String data1 = sc.next();
			System.out.print("2번째 데이터: ");
			String data2 = sc.next();
			
			
			//NumberFormat 발생가능
			int val1 = Integer.parseInt(data1);
			int val2 = Integer.parseInt(data2);
			
			//Arithmetic 발생가능
			int result = val1/val2;
			System.out.println(val1 + " / " + val2 + " = " + result);
			
			//exception 클래스는 모든 예외를 일괄처리할 수 있음 다형성임
			//그래서 모든녀석 Exception이라해도되는데 다중처리를 할때는 자식클래스명칭을
			//명확하게 적어야함
		} catch(NumberFormatException e) {
			System.out.println("데이터를 숫자만 넣어주세요.");
		} catch(ArithmeticException e) {
			System.out.println("0으로 나눌 수 없습니다.");			
		} finally {
			sc.close();
		}
	}
}












































































======================================================================================================
*21.09.13_17회차(17강)
======================================================================================================





























































































######################################################################################################
개념정리_throws

package exception.throws_;

public class ThrowsExample1 {
	public static String[] greetings = {"안녕", "니하오", "헬로"};
	public static void main(String[] args) {
		/*
		 * thorws가 붙어 있는 메서드나 생성자를 호출할때는 반드시 try블록 내부에서 호출하여
		 * 예외처리를 진행해야함
		 * 또는 다시 throws하여 예외처리를 다시 한 번 떠넘길수 있음
		 */
		try {			
			greet(3);
		} catch(Exception e) {
			e.printStackTrace();
			System.out.println("안녕");
			/*
			 * printStackTrace()는 예외발생 경로를 추적하는 메시지를 출력함
			 * 주로 개발과정에서 예외의 원인을 찾을때 유용하게 사용함
			 */
		}
		
		System.out.println("프로그램 정상종료!!");
		
		
	}
	/*
	 * 예외의 원인이 메서드 선언부가 아닌 호출부에 있을 경우 예외 처리를 메서드
	 * 호출자에게 떠넘기는 방식을 throws라 함
	 * 메서드나 생성자 호출 시 예외처리를 강요하고 싶을 때 사용합니다.
	 */
	public static void greet(int index) throws Exception{
		//내부에서 에러가나면 내가 잘못한게아니고 호출부에서 잘못이 있는거니까 
		//너 무조건 try해라  try안하면 나못쓴다. 
		//난 호출부의 상황에 따라 에러가 날 가능성이 높다. 그러니 안전하게 try안하면 안시켜준다.
//		try {
//			System.out.println(greetings[index]);
//		} catch(Exception e) {
//			System.out.println("배열의 참조범위를 벗어남!");
//		}
		System.out.println(greetings[index]);	
	}
}

######################################################################################################





















######################################################################################################
예제30)throws 떠넘기기

1)아래의 에러코드를 메인에서 최종적으로 해결하는 형태로 만드시오

package exception.throws_;

public class ThrowsExample2 {
	public void aaa(int n) throws Exception{
		System.out.println("aaa 호출!");
		int i = 10 / n;
		System.out.println("계산결과: "+i);
		System.out.println("aaa 실행종료!");
	}
	

	public void bbb() Exception{
		System.out.println("bbb 호출!");
		aaa(0);
		System.out.println("bbb 실행 종료!");
	}
	
	public void ccc() Exception{
		System.out.println("cccc 호출!");
		bbb();
		System.out.println("cccc 실행종료!");
	}
	
	public ThrowsExample2() Exception{
		System.out.println("생성자 호출!!");
		ccc();
		System.out.println("생성자 종료!!");
	}
	
	public static void main(String[] args) {		
		ThrowsExample2 te = new ThrowsExample2();
		e.printStackTrace();
		System.out.println("hihi");
	}
}


######################################################################################################






답:

package exception.throws_;

public class ThrowsExample2 {
	public void aaa(int n) throws Exception{
		System.out.println("aaa 호출!");
		int i = 10 / n;
		System.out.println("계산결과: "+i);
		System.out.println("aaa 실행종료!");
	}
	

	public void bbb() throws Exception{
		System.out.println("bbb 호출!");
		aaa(0);
		System.out.println("bbb 실행 종료!");
	}
	
	public void ccc() throws Exception{
		System.out.println("cccc 호출!");
		bbb();
		System.out.println("cccc 실행종료!");
	}
	
	public ThrowsExample2() throws Exception{
		System.out.println("생성자 호출!!");
		ccc();
		System.out.println("생성자 종료!!");
	}
	
	public static void main(String[] args) {
		try {			
			ThrowsExample2 te = new ThrowsExample2();
		} catch(Exception e) {
			e.printStackTrace();
		}
		System.out.println("hihi");
	}
}


















######################################################################################################
개념정리_throw-throws, 사용자정의 예외




* 예외 강제 발생시키기(throw)

- 사용자가 직접 선언한 예외 클래스나 자바가 제공하는 예외 API에서 예외를 강제 발생시키려면 throw라는 키워드를 이용합니다.




package exception.throw_;

public class ThrowExample {
	public static int calcSum(int n) throws Exception{
	/*
	 * 프로그램이 throw구문을 만나는 순간 즉시 예외를 강제로 발생시키게 되며
	 * 해당 예외를 처리해줄 catch블록을 검색합니다.	
	 * throw가 메서드 내에 포함되는 순간 반드시 해당 메서드는 throws를 붙여야한다.
	 * 의식흐름: 야 이건 우리안에서 에러를 발생시키는건데 만약에 밖에서 try처리를 안해주면
	 * 우리때매 프로그램터지잖아!! 그러니까 안전빵으로 밖에서 try안하면 우리 사용도못하도록
	 * throws붙이자 안붙였다가 징계먹을수도있어!
	 */
		if(n<=0) {
//			System.out.println("매개값을 양수로 전해주세요");
			throw new Exception(); // 프로그램은 에러라생각하지않지만 개발자는에러라고
			//생각하는 상황에서 개발자가 강제로 에러를 발생시키는 것이 throw다.
		}
		int sum = 0;
		for (int i=1;i<=n;i++) {
			sum+=i;
		}
		return sum;
	}
	
	
	public static void main(String[] args) {
		
		try {
			int a = 2;
			System.out.println("성공!");
		} catch(Exception e) {
			System.out.println("에러가발생할수있는코드라했는데 발생하지 않는코드가 문제는 안생기네");
		}
		
		try {
			int result1 = calcSum(100);
			System.out.println("1~100까지의 누적합 : " + result1);
			
			int result2 = calcSum(-100);	//음수가 나오면안되는데 나와서 값이 0이됨
			//설계자의의도 n은 양수만와야함
			System.out.println("1~100까지의 누적합 : " + result2);			
		} catch(Exception e) {
			System.out.println("매개값을 양수로 전달해주세요.");
		}
		
	}
}



package exception.throw_;

public class Account {
	private long balance;
	public long getBalance() {
		return balance;
	}
	
	public void deposit(int money) {
		balance += money;
	}
	
	public void withDraw(int money) throws Exception{
		if(balance<money) {
			throw new Exception(); //잔액이 출금액보다 작으면 음수로처리하면되잖아?
							//즉 이블록에는 에러가 없어! 라고 얘기해서 해당 조건식만으로는
						//에러가안난다. 하지만 우리가 볼때 세상에 음수인돈은 없다.
			//그래서 개발자가 강제로 throw를 이용하여 에러를 발생시킨다. 그리고 해당되는것은
			//호출부에서 try로 받아야한다.
		}
		balance -= money;
	}
}







* 사용자 정의 예외

- 프로그램을 개발하다보면 자바 표준 API에서 제공하는 예외 클래스만으로 다양한 종류의 예외를 표현할 수 없습니다.
- 개발자가 만든 어플리케이션에서 자체적으로 생길 수 있는 예외는 개발자가 직접 예외 클래스를 정의해서 만들어야 합니다.
- 사용자 정의 예외 클래스는 일반 예외로 선언할 경우 Exception 클래스를 상속하여 사용하고, 
	실행 예외로 선언할 경우  RuntimeException 클래스를 상속하면 됩니다.
- 사용자 정의 예외 클래스의 이름은 Exception으로 끝나는 것이 좋습니다.



######################################################################################################
















######################################################################################################
예제31)throw - throws

1)아래의 상황에서 n은 음수가 못들어오도록 하라
	-return으로 종료할수없는 상황이니 강제로 에러를 발생시켜야한다.

package exception.throw_;

public class ThrowExample {
	public static int calcSum(int n) {
		int sum = 0;
		for (int i=1;i<=n;i++) {
			sum+=i;
		}
		return sum;
	}
	public static void main(String[] args) {
		
		int result1 = calcSum(100);
		System.out.println("1~100까지의 누적합 : " + result1);

		int result2 = calcSum(-100);	//음수가 나오면안되는데 나와서 값이 0이됨
		System.out.println("1~100까지의 누적합 : " + result2);
		
	}
}

######################################################################################################






답:



package exception.throw_;

public class ThrowExample {
	public static int calcSum(int n) throws Exception{
	/*
	 * 프로그램이 throw구문을 만나는 순간 즉시 예외를 강제로 발생시키게 되며
	 * 해당 예외를 처리해줄 catch블록을 검색합니다.	
	 * throw가 메서드 내에 포함되는 순간 반드시 해당 메서드는 throws를 붙여야한다.
	 * 의식흐름: 야 이건 우리안에서 에러를 발생시키는건데 만약에 밖에서 try처리를 안해주면
	 * 우리때매 프로그램터지잖아!! 그러니까 안전빵으로 밖에서 try안하면 우리 사용도못하도록
	 * throws붙이자 안붙였다가 징계먹을수도있어!
	 */
		if(n<=0) {
//			System.out.println("매개값을 양수로 전해주세요");
			throw new Exception(); // 프로그램은 에러라생각하지않지만 개발자는에러라고
			//생각하는 상황에서 개발자가 강제로 에러를 발생시키는 것이 throw다.
		}
		int sum = 0;
		for (int i=1;i<=n;i++) {
			sum+=i;
		}
		return sum;
	}
	
	
	public static void main(String[] args) {
		
		try {
			int a = 2;
			System.out.println("성공!");
		} catch(Exception e) {
			System.out.println("에러가발생할수있는코드라했는데 발생하지 않는코드가 문제는 안생기네");
		}
		
		try {
			int result1 = calcSum(100);
			System.out.println("1~100까지의 누적합 : " + result1);
			
			int result2 = calcSum(-100);	//음수가 나오면안되는데 나와서 값이 0이됨
			//설계자의의도 n은 양수만와야함
			System.out.println("1~100까지의 누적합 : " + result2);			
		} catch(Exception e) {
			System.out.println("매개값을 양수로 전달해주세요.");
		}
		
	}
}







######################################################################################################
예제32) throw - throws 2

1)아래 코드에서 출금액이 계좌액보다 클경우 강제로 에러를 발생시키시오.
mainclass나 main메서드 없이 메서드내에서 구현만 하면됨



package exception.throw_;

public class Account1 {
	private long balance;
	public long getBalance() {
		return balance;
	}
	
	public void deposit(int money) {
		balance += money;
	}
	
	public void withDraw(int money) throws Exception{
		balance -= money;
	}
}



######################################################################################################


답:


package exception.throw_;

public class Account1 {
	private long balance;
	public long getBalance() {
		return balance;
	}
	
	public void deposit(int money) {
		balance += money;
	}
	
	public void withDraw(int money) throws Exception{
		if(balance<money) {
			throw new Exception(); //잔액이 출금액보다 작으면 음수로처리하면되잖아?
							//즉 이블록에는 에러가 없어! 라고 얘기해서 해당 조건식만으로는
						//에러가안난다. 하지만 우리가 볼때 세상에 음수인돈은 없다.
			//그래서 개발자가 강제로 throw를 이용하여 에러를 발생시킨다. 그리고 해당되는것은
			//호출부에서 try로 받아야한다.
		}
		balance -= money;
	}
}















######################################################################################################
예제33)사용자정의 예외클래스를 만들어 특정프로그램에서 날수있는 에러를 제어하기(개발자가 규정한 에러, 런타임에러는 아님 그래서 예외클래스가없음)

1)위 문제의 것을 복사하여 Account2를 만들고 위와같이 기본 에러만 발생시키는것이아니라 
 사용자정의 예외클래스를 만들어서 특정 메서드를(printStackTrace말고, 이것도해보긴해라) 통해 세부적인 규정한 에러의 내용을 볼수있도록 하라
-사용자정의 예외클래스로 객체를만들때 message를 직접넣는 생성자로 해보고
 기본생성자로 해라. 출력결과는 같게 하라.

######################################################################################################


답:


package exception.throw_;
/*
 * 사용자정의 예외클래스를 만들려면 Exception클래스나 RUntimeException 클래스를
 * 상속해야한다.
 */
public class BalanceInsufficientException extends Exception{
	/*
	 * 일반적으로 사용자 정의 예외 클래스를 만들때는 
	 * 기본 생성자와 예외 원인 메시지를 매개값으로 받는 생성자를
	 * 선언함 
	 * 매개값은 Exception의 생성자로 보내야함
	 */
	public BalanceInsufficientException() {
		super("잔고가 부족합니다.기본생성자");
	}
	public BalanceInsufficientException(String message) {
		super(message);
	}
}


package exception.throw_;
/*
 * account1에서 exception으로 throwthrows를 이용해 강제에러를 발생시켰는데
 * 개발자가 더 완벽하게 에러를 띄우고 싶다.
 */
public class Account2 {
	private long balance;
	public long getBalance() {
		return balance;
	}
	
	public void deposit(int money) {
		balance += money;
	}
	
	public void withDraw(int money) throws BalanceInsufficientException{
		if(balance<money) {
			//throw new BalanceInsufficientException("잔고가 부족합니다.");
			throw new BalanceInsufficientException();
		}
		balance -= money;
	}
}

package exception.throw_;

public class MainClass {

	public static void main(String[] args) {
		Account2 acc = new Account2();
		
		acc.deposit(10000);
		System.out.printf("입금 후 잔액: %d원\n", acc.getBalance());
		
		try {			
			acc.withDraw(70000);
		} catch(BalanceInsufficientException e) {
			//e.printStackTrace();
			/*
			 * -예외 클래스가 제공하는 getMessage() 메서드는 예외의 원인 메시지를 String 
			 * 타입으로 리턴함.
			 * 자바 표준 API에서 제공하는 다양한 예외클래스들은 각각의 예외 원인 메시지가
			 * 기본적으로 객체안에 저장되어있음(기본생성자안에 super로보낼 메세지에 기본값으로
			 * 정해두는 거임 
			 */
			System.out.println(e.getMessage());
		}
		System.out.printf("출금 후 잔액 :  %d원\n", acc.getBalance());
	}

}





















################################################################################################
개념정리_API


* JAVA API(Application Programming Interface)

- API는 라이브러리라고 부르며 프로그램 개발에 자주 사용되는 클래스 및 인터페이스의 모음을 말합니다.
- 자바 표준 API 문서 주소: https://docs.oracle.com/javase/8/docs/api
	-구글에 java api라 검색하면나옴

* java.lang 패키지

- java.lang 패키지는 자바 프로그램의 기본적인 클래스들을 담고 있는 패키지입니다. 
	그렇기 때문에 java.lang 패키지에 있는 클래스와 인터페이스는 import 구문 없이 사용할 수 있습니다.

- java.lang 패키지 주요 클래스

1. Object: 자바 클래스의 최상위 클래스
2. System: 표준 입력장치(키보드)로부터 데이터를 입력받거나 표준 출력장치(모니터)로 출력하기 위해 사용
3. Class: 클래스를 메모리에 로딩할 때 사용
4. String: 문자열을 저장하고 문자열의 여러 가지 정보를 얻을 때 사용
5. StringBuffer, StringBuilder: 문자열을 저장하고 내부 문자열을 조작할 때 사용
6. Math: 수학 함수를 이용할 때 사용
7. Wrapper(Byte, Short, Integer, Long, Float, Double, Boolean, Character)
	: 기본 데이터 타입의 객체를 만들 때 사용

* Object 클래스

- 클래스를 선언할 때 extends 키워드로 다른 클래스를 상속하지 않으면 묵시적으로 Object 클래스를 상속하게  됩니다.  
	따라서 모든 자바의 클래스는 Object 클래스의 자식이거나 자손클래스입니다.
- 모든 클래스가 Object를 상속하기 때문에 Object의 메서드는 모든 클래스에서 사용이 가능합니다.


################################################################################################













######################################################################################################
예제34) 자바 표준api인 lang 라이브러리의 대표 클래스


1. : 자바 클래스의 최상위 클래스
2. : 표준 입력장치(키보드)로부터 데이터를 입력받거나 표준 출력장치(모니터)로 출력하기 위해 사용
3. : 클래스를 메모리에 로딩할 때 사용
4. : 문자열을 저장하고 문자열의 여러 가지 정보를 얻을 때 사용
5. , : 문자열을 저장하고 내부 문자열을 조작할 때 사용
6. : 수학 함수를 이용할 때 사용
7. (Byte, Short, Integer, Long, Float, Double, Boolean, Character)
	: 기본 데이터 타입의 객체를 만들 때 사용

######################################################################################################


답:





1. Object: 자바 클래스의 최상위 클래스
2. System: 표준 입력장치(키보드)로부터 데이터를 입력받거나 표준 출력장치(모니터)로 출력하기 위해 사용
3. Class: 클래스를 메모리에 로딩할 때 사용
4. String: 문자열을 저장하고 문자열의 여러 가지 정보를 얻을 때 사용
5. StringBuffer, StringBuilder: 문자열을 저장하고 내부 문자열을 조작할 때 사용
6. Math: 수학 함수를 이용할 때 사용
7. Wrapper(Byte, Short, Integer, Long, Float, Double, Boolean, Character)
	: 기본 데이터 타입의 객체를 만들 때 사용














################################################################################################
개념정리_API_system





* System 클래스

- 자바 프로그램은 운영체제상에서 바로 실행되는 것이 아니라 JVM  위에서  실행됩니다. 
	따라서 운영체제의 모든 기능을 자바 코드로 직접 접근하기는 어렵습니다.
- 하지만 System 클래스를 이용하면 운영체제의 일부 기능을 이용할 수 있습니다. 
	프로그램 종료, 키보드로 입력, 모니터로 출력, 메모 리 정리, 현재 시간 읽기 등이 가능합니다.
- System 클래스의 모든 멤버는 static으로 구성되어 있어 클래스 이름으로 바로 접근이 가능합니다.

- System 클래스 주요 메서드
1. exit(): 현재 실행하고 있는 프로세스를 강제 종료시킵니다. 정상 종료일경우 매개값으로 0을  주고, 비정상 종료인경우 0 이외에
 다른 값을 줍니다.

2. currentTimeMillis(), nanoTime()
: 컴퓨터의 시계로부터 현재 시간을 읽어서 밀리세컨드(1/1000초) 단위와 나노세컨드(1/10^9초)단위의 long값을 리턴합니다. 
주로 프 로그램의 실행 소요 시간 측정으로 성능을 테스트할 때 사용합니다.

package api.lang.system;

public class SystemTime {

	public static void main(String[] args) {
		/*
		 * currentTimeMillis()와 nanoTime() 메서드는 1970년 1월 1일
		 * 자정부터 현재까지의 시간을 초로 변환한
		 * 에폭시간을 각각 long타입의 밀리초(1/1000), 나노초(1/10^9)로 리턴함
		 */
		
		long start = System.currentTimeMillis();
		long sum =0;
		for(long i=1;i<1000000L;i++) {
			sum += i;
		}
		long end = System.currentTimeMillis();
		
		System.out.println("계산에 소요된 시간 : "+(end-start)*0.001+"초");
		
	}

}


3. getProperty(): JVM이 시작할 때 자동 설정되는 시스템의 속성값을 구합니다.
	-표준 자바 api문서에서 찾아봐라 키값확인

4. gc(): Garbage Collector를 실행시킵니다. (좀더 메모리해제를 빨리 하기 위한 것)
자바는 c처럼 포인터를 사용자가 사용불가(객체데이터를 메모리에서 지워버릴 수 없음 기다려야함) 
힙영역의 쓰레기 영역 데이터를 빨리 지우라고 독촉할 수 있음(c처럼 즉시 안됨)
	-과거 안드로이드일때는 자바로 코딩할때 계속 독촉함. 하드웨어가 소프트웨어를 못버티니 계속 메모리에 자원을 반납해야함
	-지금은 이정도아님
################################################################################################











######################################################################################################
예제35) lang 라이브러리 시간측정


1)표준 라이브러리 lang의 클래스 2개를 이용해서 1에서부터 1000까지의 누적합계를 구하는 연산속도를 측정하시오.
	-출력할때는 초단위로 출력하시오

######################################################################################################


답:






package api.lang.system;

public class SystemTime {

	public static void main(String[] args) {
		/*
		 * currentTimeMillis()와 nanoTime() 메서드는 1970년 1월 1일
		 * 자정부터 현재까지의 시간을 초로 변환한
		 * 에폭시간을 각각 long타입의 밀리초(1/1000), 나노초(1/10^9)로 리턴함
		 */
		
		long start = System.currentTimeMillis();
		long sum =0;
		for(long i=1;i<1000000L;i++) {
			sum += i;
		}
		long end = System.currentTimeMillis();
		
		System.out.println("계산에 소요된 시간 : "+(end-start)*0.001+"초");
		
	}

}









################################################################################################
개념정리_API_String


* String 클래스

- String은 생성자를 사용해서 객체를 만들 필요 없이 기초 데이터를 사용할 때처럼 바로 초기화해서 사용할 수 있습니다.
- String 클래스의 주요 메서드

1. charAt(): 특정 인덱스의 글자를 리턴.
2. indexOf(): 문자열에서 특정문자의 시작 인덱스 값을 반환합니다. 만약 주어진 문자열이 포함되어 있지 않으면 -1을 리턴합니다.
3. length(): 문자열의 길이를 알려줍니다.
package api.lang.string;

public class StringIndexOf {
	public static void main(String[] args) {
		String sbj = "자바 프로그래밍"; //8글자
		//문자열의 문자개수(길이)를 리턴하는 length()
		
		System.out.println("sbj의 길이: "+ sbj.length());
		
		//문자열의 특정 인덱스 문자를 추출하는 charAt()
		System.out.println(sbj.charAt(6));
		
		//문자열의 특정 문자의 인덱스 번호를 리턴하는 indexOf()
		int location = sbj.indexOf("프");
		System.out.println("프의 인덱스번호 : "+location);

	}
}


4. replace(): 특정 문자열을 변경합니다.
package api.lang.string;

public class StringReplace {
	public static void main(String[] args) {
		String str1 = "자바는 객체지향 언어입니다. 자바는 풍부한 API를 지향합니다.";
		String str2 = str1.replace("자바는 ", "JAVA");
		System.out.println(str1);
		System.out.println(str2);
	}
}


5. substring(): 인덱스를 기준으로 그 앞의 문자열을 잘라줍니다. 만약 매개값으로 인덱스를 2개 주면 처음 매개값 이상 두 번째 매개    
      값 미만의 문자열을 제외하고 나머지를 삭제합니다.

package api.lang.string;

public class StringSubstring {
	/*부분문자*/
	//단일문자 : charAt();
	
	public static void main(String[] args) {
		String ssn = "040404-3412343";
		System.out.println(ssn);
		
		
		/*
		 * substring() 메서드에 매개값으로 인덱스를 1개 지정하면
		 * 해당 인덱스부터 끝까지의 문자를 추출함
		 */
		String last = ssn.substring(7);
		System.out.println(last);
		
		
		/*
		 * substring()메서드에 2개를 입력하면 1번째 매개변수부터 2번째매개변수 미만의 범위까지
		 * 문자를 출력해라는 거임
		 */
		String first = ssn.substring(0, 6); //0번인덱스 이상 6번인덱스 미만
		System.out.println(first);
		
	}
}



6. toUpperCase():  문자열을  대문자로 치환합니다.
7. toLowerCase():  문자열을  소문자로 치환합니다.
8. trim(): 문자열의 앞, 뒤 공백을 제거합니다.
9. equals(): 문자열의 값을 비교합니다.
10. valueOf(): 기본 데이터 타입의 값들을 문자열로 변환합니다.
package api.lang.string;

public class StringValueOf {
	public static void main(String[] args) {
		int a = 10;
		double b = 8.79;
		System.out.println(a+b);
		
		String str1 = String.valueOf(a);
		String str2 = String.valueOf(b);
		System.out.println(str1+str2);
		//String.valueof(정수형데이터) 반대관계
		//Integer.perseInt(문자열)
	}
}




* String 클래스의 단점

- String 클래스는 아주 많이 쓰이고 좋은 기능들을 많이 가지고 있지만 메모리를 과소비한다는 문제점이 있습니다.
- String 객체는 처음 초기화된 데이터에 변화가 생기면 기존 객체를 재활용하지 않고 새로운 객체를 생성합니다.

################################################################################################













######################################################################################################
예제36) String 메서드

api.lang.string 패키지를 만들고 아래 클래스를만들어서 내부에 들어갈 함수들을 분류하고 뜻을적은 뒤 해당 메서드들을 사용해봐라

1)StringIndexOf
2)StringReplace
3)StringSubstring
4)StringValueOf

그밖에 써볼 메서드
toUpperCase
toLowerCase
equals : 문자열비교
trim : 문자열의 앞뒤 공백제거

######################################################################################################


답:


1)StringIndexOf
	charAt() : 특정인덱스의 문자반환
	indexOf() : 문자열에서 특정 문자의 인덱스값을 반환
	length() : 문자열의 길이를 반환
2)StringReplace
	replace() : 문자열의 부분 또는 전체 문자열에 해당하는 부분을 다른 문자열로 변경가능
3)StringSubstring
	substring() : 특정 인덱스 앞의 문자열을 모두 자른 후 남은걸 반환함, 
			전달인덱스가 2개인경우 1번째인자이상 2번째인자미만인덱스까지 잘라서 반환함
4)StringValue
	valueOf() : 기본타입의 값들을 문자열로 바꿈


