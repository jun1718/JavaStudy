21.0918_22회차(복습)
======================================================================================================
*복습(11일치 복습) 15강까지
======================================================================================================






######################################################################################################
예제7) switch ~ case


1)case 변수를 정수타입으로 두기
	아래 방식으로 swtich ~ case를 만들어서 효율성을 if보다 좋게하라

90점이상 100점이하 A 출력
	100점초과시 점수잘못입력함을 출력
80점이상 B 출력
70점이상 C 출력
60점이상 D 출력
50점이상 D 출력
import java.util.Arrays;
import java.util.Scanner;

public class MainClass {

	public static void main(String[] args) {
		
		int score = 69;
		
		switch (score/10) {

		case 10:
			System.out.println("A");
			break;
		case 9:
			System.out.println("A");
			break;
		case 8:
			System.out.println("B");
			break;
		case 7:
			System.out.println("C");
			break;
		default:
			System.out.println("꽝");
		}		
	}
}

2)case변수 문자열타입으로 두기
	아래처럼 출력되게 해봐라

배열이름 : foods
	배열변수 자료형 : String배열타입

정수난수 0~4를 만든뒤 해당 난수를 이용해서 switch에 접목하라(switch변수의 자료형은 Styring이다.)

비빔밥, 사시미, 북경요리, 카레, 똠양꼼
한식	일식	중식  기타해외요리입니다.
import java.util.Arrays;
import java.util.Scanner;

public class MainClass {

	public static void main(String[] args) {

		String[] foods = new String[] {"비빔밥", "사시미", "북경요리", "카레", "똠양꼼"};
		int r = (int)(Math.random()*5);
		
		switch(r) {
		case 0:
			System.out.println(foods[r]+", 한식입니다.");
			break;
		case 1:
			System.out.println(foods[r]+", 일식입니다.");
			break;
		case 2:
			System.out.println(foods[r]+", 중식입니다.");
			break;
		default:
			System.out.println(foods[r]+", 기타해외요리입니다.");
		}


	}
}


######################################################################################################




답:




1)case 변수를 정수타입으로 두기
	아래 방식으로 swtich ~ case를 만들어서 효율성을 if보다 좋게하라

import java.util.Scanner;

public class _3SwitchExample1 {
	public static void main(String[] args) {
		Scanner scan = new Scanner(System.in);
		System.out.print("점수 : ");
		int point = scan.nextInt();
		
		/*
		 * switch 키워드 뒤에 나오는 변수나 연산식은 결과값이 반드시 문자나 정수타입이어야함
		 */
		switch(point/10){
 			//case 뒤에는 반드시 상수를 적어야함
		case 10:
		case 9:	//90~99
			if (point > 100) {
				System.out.println("점수잘못입력함.");
			} else {
				System.out.println("당신의 학점은 A입니다.");	
			}
			break;
		case 8:	
			System.out.println("당신의 학점은 B입니다.");
			break;
		case 7:
			System.out.println("당신의 학점은 C입니다.");
			break;
		case 6: //50 ~ 69 D
		case 5:
			System.out.println("당신의 학점은 D입니다.");
			break;
		default:
			System.out.println("당신의 학점은 F입니다.");
		}
		
		
		scan.close();
	}

}





2)case변수 문자열타입으로 두기
	아래처럼 출력되게 해봐라

public class _3SwitchExample2 {
	public static void main(String[] args) {
		String[] foods = {"비빔밥", "사시미", "북경오리", "카레", "똠양꼼"};
		//index(0~4) 범위 난수 발생
		int idx = (int)(Math.random() * 5);
		System.out.println("선택된 음식 : " + foods[idx]);
		
		switch(foods[idx]) { //문자나 정수만가능 foods는 String배열타입, idx를하니 char
								//문자타입 그래서 가능
		case "비빔밥":
			System.out.println("한식입니다.");
			break;
		case "사시미":
			System.out.println("일식입니다.");
			break;
		case "북경오리":
			System.out.println("중식입니다.");
			break;
		default:
			System.out.println("기타 해외요리입니다.");
		}
	}//end main
}//end class


















######################################################################################################
예제8) switch ~ case 출력결과만으로 유추하여 실행하기(심화)

<출력결과>
직급을 입력하세요.
[사원,대리,과장,차장,부장]
> 사워
사워은(는) 없는 직급입니다.
직급을 다시 입력해주세요.


직급을 입력하세요.
[사원,대리,과장,차장,부장]
> 대리
대리의 급여는 300만원입니다.
		//이런식으로 각 월급을 알려줘라 월급은 맘대로 설정



import java.util.Arrays;
import java.util.Scanner;

public class MainClass {

	public static void main(String[] args) {
		String[] str = {"사원", "대리", "과장", "차장", "부장"};
		System.out.println("직급을 입력하세요.");
		System.out.println(Arrays.toString(str));
		System.out.print("> ");
		
		Scanner scan = new Scanner(System.in);
		String position = scan.next();
		
		switch (position) {
		case "사원":
			System.out.println("사원의 급여는 100만원 입니다.");
			break;
		case "대리":
			System.out.println("대리의 급여는 200만원 입니다.");
			break;
		case "과장":
			System.out.println("과장의 급여는 300만원 입니다.");
			break;
		case "차장":
			System.out.println("차장의 급여는 400만원 입니다.");
			break;
		case "부장":
			System.out.println("부장의 급여는 500만원 입니다.");
			break;
		default:
			System.out.println(position+"은(는) 없는 직급입니다.\n직급을 다시 입력해 주세요.");		
		}
	}
}


######################################################################################################




답:


import java.util.Arrays;
import java.util.Scanner;

public class _4SwitchQuiz {
	public static void main(String[] args) {
		
		System.out.println("직급을 입력하세요.");
		System.out.println("[사원, 대리, 과장, 차장, 부장]");
		System.out.print("> ");
		
		Scanner scan = new Scanner(System.in);
		String position = scan.next();
		
		switch(name){
		case "사원":
			System.out.println(position+"의 직급은 100만원입니다.");
			break;
		case "대리":
			System.out.println(position+"의 직급은 200만원입니다.");
			break;
		case "과장":
			System.out.println(position+"의 직급은 300만원입니다.");
			break;
		case "차장":
			System.out.println(position+"의 직급은 400만원입니다.");
			break;
		case "부장":
			System.out.println(position+"의 직급은 500만원입니다.");
			break;
		default:
			System.out.println(position+"은(는) 없는 직급입니다.");
			System.out.println("직급을 다시 입력해주세요.");
		}
	}//end main
}//end class
















######################################################################################################
개념정리_while

* 반복문 while

- while문은 조건식을 만족하는 동안 반복문을 실행하는데, 조건식을 검사해서 조건식이 참이면 실행문을 반복하고, 거짓이면 while문 을 빠져나옵니다.

- while문에 들어가는 조건식도 if문과 마찬가지로 반드시 boolean타입으로 결과를 반환해야 합니다.

- 조건식 안에 true를 넣으면 무한루프가 발생하기 때문에 반드시 탈출구문을 넣어야 합니다.




public class _5WhileExample1 {
	public static void main(String[] args) {
		//1~10까지의 누적합계를 구하는 로직
		int sum = 0; //합계를 저장할 변수
		int n=1; //제어변수 : 반복문의 횟수를 제어할 변수
		
		while(n <= 10) {
			sum += n;
			n++;
		}
		System.out.println("1부터 10까지의 합 : "+ sum);
		
	}//end main
}//end class


######################################################################################################
























######################################################################################################
예제9) while 응용(소수판별로직)

소수를 판별하는 while 제어문을 작성하시오.

import java.util.Arrays;
import java.util.Scanner;

public class MainClass {

	public static void main(String[] args) {
		
		Scanner scan = new Scanner(System.in);
		
		while(true) {
			System.out.println("수 입력하세요.(종료시 0입력)");
			System.out.print("> ");
			int num = scan.nextInt();
			
			if(num==0) {
				System.out.println("프로그램을 종료합니다.");
				System.exit(0);
			}

			if(num<=2) System.out.println(num+"은 소수가 아닙니다.");
			
			boolean check = true;
			
			for(int i=2;i<num;i++) {
				if(num%i==0) {
					System.out.println(num+"은 소수가 아닙니다.");					
					check=false;
					break;
				} 
			}
			if(check==true) {
				System.out.println(num+"은 소수입니다.");				
			}
		}
	}
}



import java.util.Arrays;
import java.util.Scanner;

public class MainClass {

	public static void main(String[] args) {
		
		Scanner scan = new Scanner(System.in);
		
		while(true) {
			System.out.println("\n수 입력하세요.(종료시 0입력)");
			System.out.print("> ");
			int num = scan.nextInt();
			System.out.println();
			
			if(num==0) {
				System.out.println("프로그램 종료");
				System.exit(0);
			}
			
			int i = 2;
			
			while(i<num) {
				if(num%i == 0) {
					break;
				}
				i++;
			}
			
			if(i==num) {
				System.out.println(num+"은(는) 소수입니다.");
			} else {
				System.out.println(num+"은(는) 소수가 아닙니다.");
			}
		}
	}
}

######################################################################################################




답:



import java.util.Scanner;

public class _5WhileExample2 {
	public static void main(String[] args) {
		//정수를 이력받아서 해당 정수가 소수인지 판별
		Scanner scan = new Scanner(System.in);
		System.out.print("정수를 입력: ");
		int num = scan.nextInt();
		
		int i=2;
		while (num%i != 0) {
			i++;
		}
		if (i == num) {
			System.out.println(num + "은 소수입니다.");
		}
		else {
			System.out.println(num + "은 소수가 아닙니다.");			
		}
	}
}
















######################################################################################################
개념정리_do while, for

#차이점
while : 시작값이 false면 0회실행
do while : 시작값이 false면 1회실행

#for(초기값;boolean형 조건식;반복표현식(증감식)){
	실행문
}//초기값은 반드시 한번실행된다.

#for예문

public class _2ForExample1 {
	public static void main(String[] args) {
		int sum=0;
		for(int n=1; n<=10;n++) {
			sum += n;
		}
		
		System.out.println("누적합: " + sum);
	}
}


public class _2ForExample2 {
	public static void main(String[] args) {
		//7~100까지의 정수중 7의 배수를 모두 가로로 출력
		for(int i=7; i<101; i++) {
			System.out.print(i+ " ");
		}
		System.out.println("\n--------------------");
		
		//1~100가지의 정수중 6의 배수를 모두 가로로 출력
		for(int i = 1; i < 101; i++) {
			if(i%6==0) {
				System.out.print(i + " ");
			}			
		}
		System.out.println("\n--------------------");
		
		//1~100가지 정수중 8의 배수이면서 동시에 16의 배수가 아닌수를 모두 가로로 출력
		for(int i=1;i<101;i++) {
			if(i%8==0 && i%16!=0)
				System.out.print(i + " ");
		}
		System.out.println("\n--------------------");
		
		//1~850까지의 정수중 9의 배수의 개수를 출력
		int n=0;
		for(int i=1;i<851;i++) {
			if(i%9==0)
				n++;
		}
		System.out.println("9의 배수의 개수: " + n);
	}
}


public class _3ForQuiz {
	public static void main(String[] args) {
		int dan = (int)(Math.random()*8)+2;
		System.out.println("랜덤 구구단 " + dan + "단");
		System.out.println("--------------------------");
		for(int i=1;i<10;i++) {
			System.out.println(dan + " x " + i + " = " + dan*i);
		}
	}
}




######################################################################################################














######################################################################################################
예제10) do while

1)정수를 입력받아 1부터 입력받은 숫자까지의 누적합을 구하는 로직을 통해 while로 구현하고
 do while로 구현해서 차이점을 확인하라


import java.util.Arrays;
import java.util.Scanner;

public class MainClass {

	public static void main(String[] args) {
		
		Scanner scan = new Scanner(System.in);
	
		System.out.print("정수입력 : ");
		int num = scan.nextInt();
		int i = 1;
		int sum=0;
		
//		while(num>=i) {
//			sum+= i;
//			i++;
//		}
		
//		System.out.printf("1부터 %d까지의 누적합계: %d", num, sum);
		
		do {
			sum+= i;
			i++;
		} while(num>=i);
		System.out.printf("1부터 %d까지의 누적합계: %d", num, sum);
	}
}

######################################################################################################


답:

0을넣어서 확인해야함 0을 넣었을때 while은 1번도안해서 sum=0 dowhile은 1번해서 sum=1이됨

import java.util.Scanner;

public class _1DoWhileExample {
	public static void main(String[] args) {
		//정수를 입력받아 1부터 입력받은 숫자까지의 누적합을 구하는 로직
		Scanner scan = new Scanner(System.in);
		System.out.print("정수: ");
		int target = scan.nextInt();
		int sum = 0;
		int n=1;
		
//		while(n<=target) {
//			sum+=n;
//			n++;
//		}
//		System.out.println("1부터 " + target + "까지의 누적합계  : " + sum);
		
		do {
			sum += n;
			n++;
		}while(n<=target);
		
		System.out.println("1부터 " + target + "까지의 누적합계  : " + sum);
	}
}











######################################################################################################
예제11) 별짓기



*****
 ****
  ***
   **
    *

import java.util.Arrays;
import java.util.Scanner;

public class MainClass {

	public static void main(String[] args) {
		int n = 100;
		
		for(int i=0;i<n;i++) {
			for(int j=0;j<i;j++) {
				System.out.print(" ");
			}
			for(int j2=0;j2<n-i;j2++) {
				System.out.print("*");
			}
			
			System.out.println();
		}
		
		
	}//main
}//class


    *
   ***
  *****
 *******
*********
import java.util.Arrays;
import java.util.Scanner;

public class MainClass {

	public static void main(String[] args) {
		int n = 20;
	
		for(int i=0;i<n;i++) {
			for(int j2=0;j2<n-1-i;j2++) {
				System.out.print(" ");
			}

			for(int j=0;j<(2*i)+1;j++) {
				System.out.print("*");
			}
			
			System.out.println();
		}
		
	}//main
}//class



*********
 *******
  *****
   ***
    *

i 	*
0	9	2*4+1
1	7	2*3+1
2	5	2*2+1
3	3
4	1

(2*(n-1-i))+1


import java.util.Arrays;
import java.util.Scanner;

public class MainClass {

	public static void main(String[] args) {
		int n = 10;
	
		for(int i=0;i<n;i++) {
			for(int j=0;j<i;j++) {
				System.out.print(" ");
			}
			for(int j2=0;j2<(2*(n-1-i))+1;j2++) {
				System.out.print("*");
			}
			System.out.println();
		}
		
	}//main
}//class


######################################################################################################


답:




*****
 ****
  ***
   **
    *
i	" "	*
0	0	5	
1	1	4
2	2	3
3	3	2
4	4	1
"":i
*: 5-i



public class _5ForStarEx1 {
	public static void main(String[] args) {
		for(int i=0;i<5;i++) {
			for(int j=0;j<i;j++) {
				System.out.print(" ");
			}
			for(int j=0;j<5-i;j++) {
				System.out.print("*");
			}
			System.out.println();
		}
	}
}



    *
   ***
  *****
 *******
*********

" "	*
4	1
3	3
2	5
1	7
0	9

"":j<4-i
* :j<(i*2)+1


public class _5ForStarEx2 {
	public static void main(String[] args) {
		for(int i=0;i<5;i++) {
			for(int j=0;j<4-i;j++) {
				System.out.print(" ");
			}
			for(int j=0;j<(i*2)+1;j++) {
				System.out.print("*");
			}
			System.out.println();
		}
	}
}



*********
 *******
  *****
   ***
    *


""	*
0	9	8 (2*4) +1
1	7	6 (2*3) +1
2	5	4    2
3	3	2
4	1	0 

"":j<i
* :j<2*(4-i)+1




public class _5ForStarEx3 {
	public static void main(String[] args) {
		for(int i=0;i<5;i++) {
			for(int j=0;j<i;j++) {
				System.out.print(" ");
			}
			for(int j=0; j<(2*(4-i)+1); j++) {
				System.out.print("*");
			}
			System.out.println();
		}	
	}
}
















######################################################################################################
개념정리_향상된 for문
#enhanced for(강화된 포문, 향상된 포문)

for(엘리먼트 선언: 배열또는 컬렉션의 레퍼런스->배열변수말하는거임){
	실행문;
}

엘리먼트: 배열변수에서 나오는 0번인덱스값부터를 받을 변수
레퍼런스: 배열변수 또는 컬렉션변수 


public class _1EnhancedForLoop {
	public static void main(String[] args) {
		 String[] weekDay = {"일", "월", "화", "수", "목", "금", "토"};
//		 for(int i=0;i<weekDay.length;i++) {
//			 System.out.println(weekDay[i] + "요일");
//		 }
		 for(String day:weekDay) {
			 System.out.println(day+"요일");
		 }

	}
}



######################################################################################################


























######################################################################################################
예제12) enhanced for문
향상된 for문을 사용하여 총점과 평균을 출력

import java.util.Arrays;
import java.util.Scanner;

public class MainClass {

	public static void main(String[] args) {
		int[] scores = new int[] {20, 30, 40, 50};
		
		int sum = 0;
		double avg = 0;
		
		
		for(int i : scores) {
			sum += i;
		}
		
		avg = sum / (double)scores.length;
		
		System.out.println(avg);
	}//main
}//class

######################################################################################################


답:


public class _1EnhancedForLoop {
	public static void main(String[] args) {

		 //향상된 for문을 사용하여 총점과 평균을 출력
		 int sum=0;
		double avg=0;
		
		for(int i:scores) {
			sum += i;
		}
		avg = (double)sum / scores.length;
		System.out.println(avg);
	}

}

















######################################################################################################
예제13)loop+제어문+탈출문
1)아래의 출력결과가 되도록하라
	-커피는 최초 5잔이다.
돈넣어라 : 500
커피를 한잔드리겠습니다.
남은 커피 : 4잔
돈넣어라 : 700
커피를 한잔드리겠습니다.
남은 커피 : 3잔
잔돈 : 200원입니다.
돈넣어라 : 600
커피를 한잔드리겠습니다.
남은 커피 : 2잔
잔돈 : 100원입니다.
돈넣어라 : 400
500원이상넣어라
돈넣어라 : 500
커피를 한잔드리겠습니다.
남은 커피 : 1잔
돈넣어라 : 700
커피를 한잔드리겠습니다.
남은 커피 : 0잔
잔돈 : 200원입니다.
음료수가 다떨어졌습니다. 판매를 중지합니다.



import java.util.Arrays;
import java.util.Scanner;

public class MainClass {

	public static void main(String[] args) {
		Scanner scan = new Scanner(System.in);
		int coffee = 5;
		int money = 0;
		
		while(true) {
			System.out.print("\n돈넣어라 : ");
			money += scan.nextInt();
			
			if(money>=500) {
				System.out.println("커피를 한잔 드리겠습니다.");
				money -= 500;
				coffee--;
				System.out.println("현재 남은금액 : "+money);
				System.out.println("현재 남은커피 : "+coffee+"잔");
			} else {
				System.out.println("잔액이 부족합니다.\n"+(500-money)
						+"원 더 넣으세요.");
			}
			
			if(coffee==0) {
				System.out.println("음료수가 다 떨어졌습니다. 판매를 중지합니다.");
				break;
			}
			
		}
	}//main
}//class


######################################################################################################




답:





import java.util.Scanner;

public class _2LoopQuiz {
	public static void main(String[] args) {
		Scanner scan = new Scanner(System.in);
		int coffee=5;
		
		while(true) {
			System.out.print("돈넣어라 : ");
			int money=scan.nextInt();
			if(money<500) {
				System.out.println("500원이상넣어라");
			}else if(money==500){
				System.out.println("커피를 한잔드리겠습니다.");
				coffee--;
				System.out.println("남은 커피 : " + coffee + "잔");
				if(coffee==0) {
					System.out.println("음료수가 다떨어졌습니다. 판매를 중지합니다.");
					break;
				};
			}else if(money>500){
				System.out.println("커피를 한잔드리겠습니다.");
				coffee--;
				money-=500;
				System.out.println("남은 커피 : " + coffee + "잔");
				System.out.println("잔돈 : " + money + "원입니다.");
				if(coffee==0) {
					System.out.println("음료수가 다떨어졌습니다. 판매를 중지합니다.");
					break;
				};
			}
		}
	}
}









######################################################################################################
개념정리_메서드 및 매개변수 개념


함수: 클래스가 아닌 전역에 선언되고 정의된함수
메서드: 클래스안에 선언되고 정의된 함수

자바: 클래스밖에없기때문에 함수가없고 모두 메서드라부름

*메서드(method) : 코드반복을 막기위함
-메서드는 정의하는 과정과 호출하는 과정이 있음
-메서드 선언은 메서드 내부에서는 할수없음 반드시 메서드블록 외부에서만 선언가능
	-main안에서 못만든단소리
	-class내부에서만가능
-메서드 내부에서는 다른 메서드의 호출만 가능
-호출하는 과정은 메서드를 사용하는 과정이며 해당메서드가 필요로하는 데이터(매개값)를 메서드 내부로 전달하면서 해당 메서드는
 매개값을 통해 처리한 결과값을 호출부로 다시 반환해줌


public class _1MethodExample1 {
	public static int calcSum(int num){
		int sum=0;
		for(int i=1;i<=num;i++) {
			sum+=i;
		}//endFor
		return sum;
	}//endMethod
	public static int calcSum2(int begin, int end) {
		int sum=0;
		//short sum=0;가능 왜냐면 반환될때 int로 자동형변환되기때문임 작은놈->큰놈
		for(int i=begin;i<=end;i++) {
			sum+=i;
		}
		return sum;
	}
	
	public static void main(String[] args) {
		System.out.println("1~10까지 누적합: "+calcSum(10));
		System.out.println("1~20까지 누적합: "+calcSum(20));
		int result = calcSum(100);
		System.out.println("1~100까지 누적합: "+result);
		System.out.println(0+"~"+100+"까지의 누적합: "+calcSum2(0,100));
		
	}//endMain
}//endClass


#매개변수
-매개변수는 메서드를 호출할때 실행에 필요한값들을 메서드 내부로 전달하기위한 매개체
-메서드 호출부에서 어떤매개값을 전달하느냐에 따라 메서드의 실행결과가 달라짐
-매개변수를 몇개전달받을지는 메서드를 선언할때 선언부에서 결정해야함
-매개변수를 하나도 선언하지 않을수 있으며 이때는 메서드 선언부의 ()를 비워둠 그리고 호출시에도 ()를 비워서 호출함





public class _1MethodExample2 {
	public static void main(String[] args) {
		System.out.println(calcSum());
		System.out.println(calcSum());
		System.out.println(calcSum());
		System.out.println(calcSum());
		System.out.println("이번에 획득한 무기: "+randomWeapon());
	}
	
	public static int calcSum() {
		int sum=0;
		for(int i=1;i<=100;i++) {
			sum+=i;
		}
		return sum;
	}
	public static String randomWeapon() {
		double d=Math.random();
		if(d>0.66) return "단검";
		else if(d>0.33) return "장궁";
		else return "지팡이";
	}
}




######################################################################################################


















######################################################################################################
개념정리_반환값 개념

#반환유형(return type)

1.반환값은 메서드를 호출한 곳으로 메서드의 최종실행 결과를 전달하는 값임
2.매개변수는 여러개 존재할수있지만 반환값은 오직 하나여야함
3.return이라는 키워드를 사용하여 return 뒤에 전달할 값을 지정
4.전달할 값의 데이터 타입을 반환유형이라고 하며 메서드를 선언할때 메서드 이름 앞에 반환유형을 명시해야함
5.반환값이 있는 메서드는 호출문이 하나의 값이 되기때문에 반화된 값을 다른변수에 대입할수도있고 다른 메서드의 매개값으로 사용할수도
	있음

6.모든 메서드가 반환값이 필요한것은 아님 메서드 실행 이후에 반환값이 없다면 return을 사용하지 않아도 된다.
	-이때는 반환유형을 선언시에 void라 해야함
7.모든 메서드는 return키워드를 만나면 강제로 종료됩니다. 따라서 return문 이하에 코드를 작성할수 없음
8.반환값이 없는 메서드는 반드시 단독호출해야함
	-변수에 저장하거나 다른 메서드의 매개값으로 사용불가




import java.util.Scanner;

public class _1MethodExample3 {
	public static int add(int n1, int n2) {
		return n1 + n2;
	}//add
	public static int[] totalOperate(int n1, int n2){
		int[] total= {n1+n2,n1-n2,n1*n2,n1/n2};
		return total;
	}//totalOperate
	public static void callMyName(String name) {
		if(name.length()<2) {
			System.out.println("이름은 2글자 이상으로 입력하세요!");
			return;
		}
		System.out.println("내 이름은 "+name+"입니다.!!");
	}//callMyName
	
	public static void main(String[] args) {
		int r = add(3,5);
		System.out.println(r);
		
		int r2=add(add(4,6), add(8,7));
		System.out.println(r2);
		
		int[] tot=totalOperate(30,5);
		System.out.println("30 + 5 = "+tot[0]);
		System.out.println("30 - 5 = "+tot[1]);
		System.out.println("30 * 5 = "+tot[2]);
		System.out.println("30 / 5 = "+tot[3]);
		callMyName("리덕화");
		
		System.out.println("---------------------------");
		Scanner sc = new Scanner(System.in);
		System.out.print("이름 입력: ");
		String name = sc.nextLine();
		callMyName(name);
	}//main
}//class


######################################################################################################

















######################################################################################################
개념정리_string mainpulate


#대소문자 변경 / Stirng 문자열에서 특정문자 반환(변수, 버퍼)

public class StringMainPulate {
	public static void main(String[] args) {
		String str = "iNSERT";
		System.out.println(str);
		
		//문자열을 일괄적으로 소문자로 변환하는 메서드는 toLowerCase()
		str = str.toLowerCase(); //반대 : toUpperCase()
		System.out.println(str);
		
		str = str.toUpperCase();
		System.out.println(str);
		
		//문자열에서 특정 문자 하나만 가져오는 메서드는 charAt(문자열인덱스번호)입니다.
		char c = str.charAt(0);			//str이란 변수에서 0번인덱스 가져오기
		System.out.println(str.charAt(0));
		System.out.println(c);
		
	}//main
}//class



char gender = scan.next().charAt(0);	//버퍼에서 바로 0번인덱스만 가져오기


######################################################################################################



























######################################################################################################
예제14)고객관리프로그램



#요구사항정의
-고객의 정보는 이름,성별,이메일,출생년도가 있습니다. 고객의 정보를 입력받아 배열에 저장해야합니다. 이름은 문자열로 저장하며, 
 성별은 남자는 M, 여자는 F로 저장합니다. 이메일은 문자열로 저장하며 태어난 출생년도는 정수로 저장합니다.
-고객관리프로그램은 고객의 정보를 저장, 조회, 수정, 삭제할 수 있는 기능이 있어야 합니다. 고객 정보를 파일에 저장하는 기능을 구현하지 않아도 
 됩니다.
-I를 눌러 고객의 정보를 입력받도록 하며, 저장된 고객정보는 P또는 N을 눌러 이전 고객정보 또는 다음 고객정보를 조회할수 있어야합니다.
 조회한 고객정보는 U를 눌러 새로운 정보로 수정할수 있어야합니다. D를 누르면 조회한 고객 정보를 배열에서 삭제해야 합니다. 프로그램의 
 종료는 Q를 누릅니다.

***현재인덱스 값이 previous, next, currently, update, delete등 기능의 모든 기준이된다.
현재 인덱스값을 기준으로 previous면 이전데이터, next면 다음데이터, update면 현재 인덱스위치의 데이터를 변경, 삭제도 현재 인덱스위치 데이터


//각 함수에대한 조건은 모두 switch에 넣어라(함수에 탈출조건넣지마라는소리임)
insertData();
printData();
updateData();	
deleteData();
menu();

<메뉴함수 출력결과>

<명령어 목록>
현재 count: 0, 현재 index: -1
Insert, Previous, Current, Next, Update, Delete, Quit
명령어 입력: 




package customer_manager;

import java.util.Scanner;

public class CustomerManager {
	private String[] nameList = new String[100];
	private char[] genderList = new char[100];
	private String[] emailList = new String[100];
	private int[] yearList = new int[100];

	public static int count = 0;
	public static int index = -1;
	public static Scanner scan = new Scanner(System.in);
	
	public char menu() {
		System.out.println("\n<명령어 목록>");
		System.out.printf("현재 count : %d, 현재 index : %d\n", count, index);
		System.out.println("[I]nsert, [P]revious, [C]urrent, [N]ext,"
				+ "[U]pdate, [D]elete, [Q]uit");
		System.out.print("명령어 입력: ");
		char menu = scan.next().toUpperCase().charAt(0);
		return menu;
	}
	
	public void insertData() {
		System.out.print("고객 이름입력: ");
		String name = scan.next();
		
		System.out.print("고객 성별입력(M/W): ");
		char gender = scan.next().toUpperCase().charAt(0);
		
		System.out.print("고객 이메일입력: ");
		String email = scan.next();
		
		System.out.print("고객 출생년도입력: ");
		int year = scan.nextInt();
		
		nameList[count] = name;
		genderList[count] = gender;
		emailList[count] = email;
		yearList[count] = year;
		
		count++;
		index = count-1;
		System.out.println(name+"님의 고객정보 입력을 완료했습니다.");
	}
	
	public void printData() {
		System.out.println("=============고객정보 조회=============");
		System.out.println("이름 : "+nameList[index]);
		System.out.println("성별 : "+genderList[index]);
		System.out.println("메일 : "+emailList[index]);
		System.out.println("출생년도 : "+yearList[index]);
		System.out.println("==================================");
	}
	
	public void updateData() {
		System.out.print("고객 이름입력: ");
		String name = scan.next();
		
		System.out.print("고객 성별입력(M/W): ");
		char gender = scan.next().toUpperCase().charAt(0);
		
		System.out.print("고객 이메일입력: ");
		String email = scan.next();
		
		System.out.print("고객 출생년도입력: ");
		int year = scan.nextInt();
		
		nameList[index] = name;
		genderList[index] = gender;
		emailList[index] = email;
		yearList[index] = year;
	}
	
	public void deleteData() {
		for(int i=index;i<count-1;i++) {
			nameList[i] = nameList[i+1];
			genderList[i] = genderList[i+1];
			emailList[i] = emailList[i+1];
			yearList[i] = yearList[i+1];
		}
		count--;
	}
}



package customer_manager;

public class MainClass {

	public static void main(String[] args) {
	
		CustomerManager m = new CustomerManager();
		
		while(true) {
			char menu = m.menu();
			
			switch (menu) {
			
			
			case 'I':
				System.out.println("\n***고객정보 입력을 시작합니다***");
				m.insertData();
				break;
				
				
			case 'P':
				System.out.println("\n***이전고객의 정보를 조회합니다.***");
				if(CustomerManager.count == 0) {
					System.out.println("데이터부터 입력하세요.");
					continue;
				}
				if(CustomerManager.index == 0) {
					System.out.println("현재 인덱스가 첫번재 데이터입니다.");
					continue;
				}
				CustomerManager.index--;
				m.printData();
				break;
				
				
			case 'C':
				System.out.println("\n***현재 고객의 정보를 조회합니다.***");
				if(CustomerManager.count == 0) {
					System.out.println("데이터부터 입력하세요.");
					continue;
				}
				m.printData();
				break;
				
				
			case 'N':
				System.out.println("\n***다음고객의 정보를 조회합니다.***");
				if(CustomerManager.count == 0) {
					System.out.println("데이터부터 입력하세요.");
					continue;
				}
				if(CustomerManager.index == CustomerManager.count-1) {
					System.out.println("현재 인덱스가 마지막 데이터입니다.");
					continue;
				}
				CustomerManager.index++;
				m.printData();
				break;
				
				
			case 'U':
				System.out.println("\n***고객정보를 수정합니다***");
				m.updateData();
				break;
				
				
			case 'D':
				System.out.println("\n***고객정보를 삭제합니다***");
				m.deleteData();
				break;
				
				
			case 'Q':
				System.out.println("\n***프로그램을 종료합니다.***");
				System.exit(0);
				break;
				
				
			default:
				System.out.println("I,P,C,N,D,Q 중에서 하나만 입력하세요.");
			}
			
			
		}
	}

}

######################################################################################################




답:






import java.util.Scanner;

public class CustomerManagement {
//variable
	static String[] nameList = new String[100];
	static char[] genderList = new char[100];
	static String[] emailList = new String[100];
	static int[] birthList = new int[100];
	
	static int count = 0;
	static int index = -1;
	
	static Scanner scan = new Scanner(System.in);
	
//userDefinedMethod
	public static void insertData() {
		System.out.print("이름입력 : ");
		nameList[count] = scan.next();
		
		System.out.print("성별입력(M/W) : ");
		genderList[count] = scan.next().toUpperCase().charAt(0);

		System.out.print("이메일입력 : ");
		emailList[count] = scan.next();
		
		System.out.print("출생년도입력 : ");
		birthList[count] = scan.nextInt();
		
		count++;
	}
	public static void updateData() {
		System.out.printf("이름입력(%s) : ", nameList[index]);
		nameList[index] = scan.next();
		
		System.out.printf("성별입력(%c) : ", genderList[index]);
		genderList[index] = scan.next().toUpperCase().charAt(0);

		System.out.printf("이메일입력(%s) : ", emailList[index]);
		emailList[index] = scan.next();
		
		System.out.printf("출생년도입력(%d) : ", birthList[index]);
		birthList[index] = scan.nextInt();
	}
	public static void printData() {
		System.out.println("=============고객정보 조회=============");
		System.out.println("이름 : " + nameList[index]);
		System.out.println("성별 : " + genderList[index]);
		System.out.println("e메일 : " + emailList[index]);
		System.out.println("출생년도 : " + birthList[index]);
		System.out.println("==================================");
	}
	public static void deleteData() {
		for(int i=index;i<count-1;i++) {
			nameList[i] = nameList[i+1];
			genderList[i] = genderList[i+1];
			emailList[i] = emailList[i+1];
			birthList[i] = birthList[i+1];
		}
		count--;
	}
	public static char menu() {
		System.out.println("\n<명령어 목록>");
		System.out.printf("현재 count: %d, 현재 index: %d\n", count,index);
		System.out.println("Insert, Previous, Current"
				+ ", Next, Update, Delete, Quit");
		
		System.out.print("명령어 입력: ");
		char menu = scan.next().toUpperCase().charAt(0);
		
		return menu;
	}
	public static void menuProcessor(char menu) {
		switch(menu) {
		case 'ㅑ':
		case 'I':
			System.out.println("\n고객의 정보 추가을 실시합니다.");
			insertData();
			break;
			
		case 'ㅔ':
		case 'P':
			System.out.println("\n이전 정보를 조회합니다.");
			if(count==0) {
				System.out.println("데이터를 입력하세요.");
				break;
			}
			if(index<=0) {
				System.out.println("인덱스값을 변경하세요.");
				break;
			}
			index--;
			printData();
			break;
			
		case 'ㅊ':
		case 'C':
			System.out.println("\n현재 정보를 조회합니다.");
			if(count==0) {
				System.out.println("데이터를 입력하세요.");
				break;
			}
			if(index<0) {
				System.out.println("인덱스값을 변경하세요.");
				break;
			}
			printData();
			break;
			
		case 'ㅜ':
		case 'N':
			System.out.println("\n다음 정보를 조회합니다.");
			if(count==0) {
				System.out.println("데이터를 입력하세요.");
				break;
			}
			if(index==count-1) {
				System.out.println("인덱스값을 변경하세요.");
				break;
			}
			index++;
			printData();
			break;
			
		case 'ㅕ':
		case 'U':
			if(count==0) {
				System.out.println("데이터를 입력하세요.");
				break;
			}
			if(index<0) {
				System.out.println("인덱스를 변경하세요.");
				break;
			}
			System.out.println("\n"+nameList[index]+"님의 정보를 수정합니다.");
			updateData();
			break;
			
		case 'ㅇ':
		case 'D':
			if(count==0) {
				System.out.println("데이터를 입력하세요.");
				break;
			}
			if(index<0) {
				System.out.println("인덱스를 변경하세요.");
				break;
			}
			System.out.println("\n정보 삭제를실시합니다.");
			deleteData();
			break;
			
		case 'ㅂ':
		case 'Q':
			System.out.println("\n고객관리 매니저를 종료합니다.");
			System.exit(0);
			break;
			
		default:
			System.out.println("명령어를 잘못 입력하셨습니다.");
		}//switch
	}//menuProcessor

//main
	public static void main(String[] args) {
		while(true) {
			char menu = menu();
			menuProcessor(menu);
		}
	}//main
}//class























######################################################################################################
개념정리_배열의 삭제


#배열 {1,2,3,4}가 있을때 1번인덱스를 삭제하면
 1,3,4,4가 되도록 삭제해야하고 사용자한테는 시스템상 마지막 4를 안보이게해서 논리적으로는 사라진것처럼 보이게해야한다.
	??궁금:근데 왜 굳이 마지막거 널로 안채우지? 널로채우면 더 직관적이고 좋은듯한데
 

import java.util.Arrays;

public class _4ArrayDelete {
	public static void main(String[] args) {
		int[] iArr = {1,3,5,7,9,11,13};
		System.out.println(Arrays.toString(iArr));
		
		int index=3;
		for(int i=index;i<iArr.length-1;i++) {
			iArr[i] = iArr[i+1];
		}
		System.out.println(Arrays.toString(iArr));
		String[] nameList = new String[100];
		nameList[0]="홍길동";
		nameList[1]="신사임당";
		nameList[2]="이순신";
		nameList[3]="강감찬";
		System.out.println(Arrays.toString(nameList));
		//||nameList[i+1]!="0"
		
		int count = 4;
		for(int i=1;i<count-1;i++) {
			nameList[i] = nameList[i+1];			
		}
		System.out.println(Arrays.toString(nameList));
	}
}





######################################################################################################




















######################################################################################################
개념정리_실행파일만들기

<eclips->.jar만들기>
실행중인 소스코드중지
프로젝트우클릭
export
java디렉터리클릭
Runnable JAR file 클릭 -next 클릭
Launch configuration에서 빼고싶은 class 클릭
저장위치및 이름선택
finish
ok

<window>
해당위치에 생겼는지확인
jsmooth 설치

<jsmooth>
skeleton
selection의 none이라 되어있는곳 클릭
console wrapper 클릭
	-console wrapper : 도스프로그램만들때
	-windowed wrapper : 윈도우그래픽프로그램만들때

excutable클릭
excutable binary에서 .jar클릭-클릭 후 binary에 경로가 입력되는데 .jar를 .exe로 수동변경할것
	-어떤파일을 실행가능하게 만들것이냐 묻는거임
		-내생각에는 excuta에서는 exe로 만들때 이름뭘로할건지 묻는거고 그파일이름 다쓰기힘드니까 그냥 .jar가져와서
			.exe로만 바꾸는듯

2번째칸에서 실행파일의 아이콘이될 사진클릭
current directory에 '.'기호 하나만 표시

application클릭
embedded jar의 경로에 .jar클릭
	-use an embedded jar 클릭
main class위치에서 프로젝트 내 실제 실행파일로만들 클래스를 찍어줌

위에 톱니바퀴아이콘클릭
	-이때만들어지는파일은 해당 프로젝트의 클래스들을 언제든지 만들기위한 바로가기역할인가?


######################################################################################################






















######################################################################################################
개념정리_클래스 배경 및 기본코드


#객체
속성: 멤버변수, 필드
기능: 메서드



#아래 add함수를 3개 result를 3개만든것처럼 계속 코드를 재작성해야하는데 이게 낭비다(시간,인력,리소스)
	-그래서 하나의 설계를 만들어놓고 함수처럼 매번 재작성하는게 아니라 객체를 클래스로 찍어내자는것

public class _1Object_Basic1 {
	static int result1 = 0;
	static int result2 = 0;
	static int result3 = 0;
	public static int add1(int n) {
		result1 += n;
		return result1;
	}
	public static int add2(int n) {
		result2 += n;
		return result2;
	}
	public static int add3(int n) {
		result2 += n;
		return result2;
	}
	public static void main(String[] args) {
		System.out.println("1번 계산기 계산결과!");
		System.out.println("=======================");
		System.out.println(add1(6));
		System.out.println(add1(14));
		System.out.println(add1(140));
		
		System.out.println("2번 계산기 계산결과!");
		System.out.println("=======================");
		System.out.println(add2(64));
		System.out.println(add2(10));
	}
}


----------------------------------------------------


#위의 낭비를 해결(시간낭비,인력낭비,리소스낭비_코드영역) + 관리용이 (절차지향은 위처럼 모든걸 함수나 코드로 작성해야해서
							1번계산기로 넣으려면 또 배열을 만들어서 추가적으로 변수들을
							입력해 모아두어야한다. 구조체를 만들던가. 그러면 그변수와
							그변수에 맞는 함수를 외우고서 같이 실행해야하는데
							클래스는 그러한것을 모두 없애준다)


public class _2Calculator {
	int result = 0;
	int add(int n) {
		result += n;
		return result;
	}
	int sub(int n) {
		result-=n;
		return result;
	}
	int mul(int n) {
		result*=n;
		return result;
	}
	
}

public class _3CalMain {
	public static void main(String[] args) {
		_2Calculator c1 = new _2Calculator();	//1번계산기 생성
		_2Calculator c2 = new _2Calculator();	//2번계산기 생성
		
		c1.add(14);
		c1.sub(7);
		c1.mul(6);
		
		c2.add(5);
		c2.sub(4);
		c2.mul(6);
		
		System.out.println("1번계산기 결과값: "+c1.result);
		System.out.println("2번계산기 결과값: "+c2.result);		
	}
}


######################################################################################################


















######################################################################################################
개념정리_객체지향프로그래밍 

클래스 내부에 속성(멤버변수)과 기능(함수)

Marker rPen = new Marker();
c와다르게 자바는 rPen앞에 에스크립터를붙여서 포인트변수화 하지 않아도 자동으로
포인트변수화시킨뒤 주소를 저장하나보다.
그럼 배열과마찬가지로 객체를 스택에서 구현은불가능한가?

modifire: 접근제한자

#객체 이용
아래보면 blackPen을 포인터변수화안해도 자동 포인트변수화가된다.
왜냐면 스택에 어차피 클래스를 만들지 못하니 무조건 포인트변수화해놓은듯하다
그럼 마찬가지로 스택에 없으니 .을 찍는경우도 *없이 .만찍어도된다.
스택이 있으면 구분하기위해 스택에선 그냥 .만찍고 포인터변수인경우 차이를 구분하기위해 *.을 찍는데
어차피 모두다 포인터로 *을 찍을거면 찍지말자고 합의했나보다.
안찍어도 그건 포인터밖에 없으니까
즉 -> .*이 무의미해졌고 .하나가 모두 함축한다는 뜻이다.


//설계용 클래스(라이브러리 클래스)는 메인메서드를 작성하지 않는다.
public class Pen {
	//객체의 속성을 나타내는것을 필드(멤버변수)라고 부름
	String color;
	int price;
	
	//객체의 기능을 나타내는 것을 메서드(멤버함수)라고 부름
	void write() {
		System.out.println(color + "색 글을 씁니다.");
	}
	
	void info() {
		System.out.println("----------pen's Info------------");
		System.out.println("색상: "+color);
		System.out.println("가격: "+price);
		//배열은 동종모음구조라 지금처럼 여러 형태의 데이터를 저장불가능하며 기능함수를
		//묶을수없다.
		
		
	}

}

public class PenMain {
	public static void main(String[] args) {
		//Pen의 기능과 속성을 사용하려면 설계용 클래스를 로딩시켜 pen 객체를 생성해야함
		Pen blackPen = new Pen();
		blackPen.color = "검정";
		blackPen.price = 400;
		
		blackPen.write();
		blackPen.info();
		
		Pen redPen = new Pen();
		redPen.color = "빨강";
		redPen.price = 600;
		redPen.write();
		redPen.info();
		
		
		System.out.println(blackPen);
		System.out.println(redPen);
				
		
		Pen bluePen = new Pen();
		bluePen.color = "파랑";
		bluePen.price = 500;
		
		bluePen.write();
		bluePen.info();
		
	
	}

}



######################################################################################################








######################################################################################################
개념정리_변수

#매개변수에 디폴트값을 넣는다고해서 c처럼 디폴트매개변수가 되지 않는다. 그런건 지원안함


public class Variable {
	//필드(멤버변수) 선언.
	int a; //초기화하지 않으면 기본값으로 자동 초기화
	
	//메서드 선언
	void printNumber(int c) {
		//지역변수 b와 매개변수 c를 선언
		int b=0;
		
		System.out.println("멤버변수: "+a);
		System.out.println("지역변수: "+b); //멤버, 매개는 초기화안되어있어도
										//출력등 사용가능한데 지역변수는 반드시
								//초기화해야 출력가능하다. 멤버나 매개는 밖에서
								//들어올것을 알기때문이다.
								//멤버변수는 초기화하지 않아도 기본값으로 자동초기화된다
								//매개는 반드시 밖에서 들어온다
		System.out.println("매개변수: "+c);
		
	}
	
	public static void main(String[] args) {
		Variable  v = new Variable();
		v.printNumber(5);
	}
}
 

######################################################################################################




















######################################################################################################
예제15)계좌관리프로그램

offshoot의 AccountManager.exe와 똑같이 프리코딩하시오.

클래스명: Account 
	멤버변수 : name, password(int), balance(int)->계좌내 잔액
	멤버함수 : 출금(withDrawMoney), 입금(deposit), 잔액조회(getBalance)
	
main클래스: AccountManager
	멤버변수 : 알아서
	멤버함수 : 알아서
package AccountManager;

import java.util.Scanner;

public class Account {
	private String name;
	private int password;
	private int balance;
	private Scanner scan = new Scanner(System.in);

	Account(){
		System.out.println("계좌를 등록합니다.");

		System.out.print("이름 : ");
		setName(scan.next());

		System.out.print("비밀번호 : ");
		setPassword(scan.nextInt());

		System.out.print("입금액 : ");
		setBalance(scan.nextInt());
	}

	public int menu() {
		System.out.println("\n메뉴를 입력하세요.");
		System.out.println("1.예급 / 2.출금 / 3.잔액조회 / 4.종료");
		System.out.print("> ");
		int menu = scan.nextInt();

		return menu;
	}


	public boolean pwCheck() {
		System.out.println("\n계좌 비밀번호를 입력하세요.");
		System.out.print("> ");
		int pw = scan.nextInt();

		if(pw != password) {
			System.out.println("비밀번호가 틀렸습니다. 메뉴로 돌아갑니다.");
			return false;
		}

		return true;
	}
	
	
	public void deposit() {
		boolean check = pwCheck();
		if(!check) return;
		
		System.out.println("\n입금액을 입력하세요.");
		System.out.print("> ");
		int money = scan.nextInt();			
		balance+=money;
		System.out.println(money+"원 입금되었습니다.");
		System.out.println("잔고: "+balance);
	}
	
	
	public void withDrawMoney() {
		boolean check = pwCheck();
		if(!check) return;

		System.out.println("\n출금액을 입력하세요.");
		System.out.print("> ");
		int money = scan.nextInt();
		
		if(money>balance) {
			System.out.println("얌마 돈 더넣고와 돈도 없는게 돈달래~");
			return;
		}
		
		balance-=money;
		System.out.println(money+"원 출금되었습니다.");
		System.out.println("잔고: "+balance);
	}


	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public int getPassword() {
		return password;
	}
	public void setPassword(int password) {
		this.password = password;
	}
	public int getBalance() {
		return balance;
	}
	public void setBalance(int money) {
		this.balance += money;
	}


}



package AccountManager;

public class MainClass {
	public static void main(String[] args) {
		Account a1 = new Account();
		
		while(true) {
			int menu = a1.menu();
			
			if(menu==1) {
				a1.deposit();
				continue;
			}
			
			if(menu==2) {
				a1.withDrawMoney();
			}
	
			if(menu==3) {
				System.out.println("\n계좌를 조회합니다.");
				boolean check = a1.pwCheck();
				if(!check) continue;
				
				System.out.println("\n계좌잔고 : "+a1.getBalance()+"원");
			}
	
			if(menu==4) {
				System.out.println("\n프로그램을 종료합니다^_^");
				break;
			}
		}
		
		
	
	}
}

######################################################################################################




답:






public class Account {
	String name;
	int password;
	int balance;
	
	void deposit(int money) {
		balance += money;
		System.out.println(money+"원 입금되었습니다.");
	}
	void withDrawMoney(int money) {
		balance -= money;
		System.out.println(money+"원 출금되었습니다.");
	}
	int getBalance() {
		return balance;
	}
}


=====================================


import java.util.Scanner;

public class AccountManagerReview {
	static Scanner scan = new Scanner(System.in);
	
	public static int pwCheck(Account p1) {
		System.out.println("계좌 비밀번호를 입력하세요.");
		System.out.print("> ");
		int password = scan.nextInt();
		if(p1.password!=password) {
			System.out.println("비밀번호가 틀렸습니다.\n메뉴로 돌아갑니다.");
		}
		return password;
	}
	
	
	
	
	public static void accountAccounting(Account p1) {
		System.out.println("계좌를 등록합니다.");
		System.out.print("이름: ");
		p1.name = scan.next();
		
		System.out.print("비밀번호: ");
		p1.password = scan.nextInt();
		
		System.out.print("처음 입금액: ");
		p1.balance = scan.nextInt();
	}
	public static int menu() {
		System.out.println("\n메뉴를 입력하세요.");
		System.out.println("1.예금 / 2.출금 / 3.잔액조회 / 4.종료");
		System.out.print("> ");
		int menu = scan.nextInt();
		
		return menu;
	}
	public static void deposit(Account p1) {
		if(pwCheck(p1)==p1.password) {	
			System.out.print("입금액 입력: ");
			int money = scan.nextInt();
			p1.deposit(money);
		}
	}
	public static void withDrawMoney(Account p1) {
		if(pwCheck(p1)==p1.password) {	
			System.out.print("출금액 입력: ");
			int money = scan.nextInt();
			
			if(money>p1.balance) {
				System.out.println("잔액부족입니다! 슈퍼가서 돈넣고 오세요^^");
				return;
			}
			
			p1.withDrawMoney(money);
		}
	}	
	public static void getBalance(Account p1) {
		if(pwCheck(p1)==p1.password) {			
			System.out.println(p1.name+"님의 계좌잔액은 "+p1.getBalance()+"원입니다.");
		}
	}
	
	public static void main(String[] args) {
		Account p1 = new Account();
		accountAccounting(p1);	
		
		while(true) {
			int menu = menu();
			
			if(menu==1) {
				deposit(p1);
			}
			if(menu==2) {
				withDrawMoney(p1);
			}
			if(menu==3) {
				getBalance(p1);
			}
			if(menu==4) {
				System.out.println("\n프로그램을 종료합니다.");
				System.exit(0);
			}
		}
	}
}




































######################################################################################################
개념정리_동적할당해제개념 및 패키지



* Garbage Collecting

- 객체를 생성하는데 사용되는 키워드는 new이지만, 생성된 객체를 메모리에서 해제시키는 키워드는 존재하지 않습니다.
- 그 이유는 자바에서는 자바 가상머신(JVM)이 알아서 메모리를 관리해주며, 이를 가비지 컬렉팅이라 합니다.
- 객체가 더 이상 프로그램에서 사용되지 않으면 가비지 컬렉터가 스스로 판단해서 메모리를 해제하고 수거합니다.

	-장점: 개발자가 해제를 신경쓰지 않아도된다.
	-단점: 시시각각 메모리를 제어하지 못한다.
		-마린태어나고죽고 계속관리해야하는데 그래서 게임을 c++로 만든다.

* 패키지(package)

- 클래스는 크게 2종류가 있습니다. 하나는 개발자가 직접 만들어 사용하는 사용자 정의  클래스이고,  다른  하나는 JDK(Java Development Kit)안에 포함되어 있거나, 다른 개발자들이 미리 만들어 놓은 클래스들이 있습니다.
- 그런데 이런 클래스들은 매우 종류가 많고 비슷한 기능들을 분류시켜야 할 필요성이 있기 때문에 서로 관계가 있는 클래스들을 패키지로 묶어서 관리합니다.
- 현재 클래스에서 다른 패키지의 외부 클래스를  사용하고 싶은 경우에  import 키워드로 해당 클래스의 전체 경로(패키지  명까지 포함)를 지정해줘야 합니다.

ex) import java.util.Scanner;

- 만약 해당 패키지 안에 들어있는 모든 클래스를 사용하고 싶다면 * 기호를 넣어주면 됩니다.     ex) import java.util.*;

- package 선언 방법

1. 사용자가 임의로 패키지를 만드려면 클래스의 가장 윗부분에 패키지 구문을 포함시키면 됩니다.    ex) package store;
1. 패키지 이름은 영문 소문자로 지정하는 것을 권장합니다.
1. 대분류와 소분류 패키지를 구분할 때는 .(dot)을 사용합니다.
1. 최상위 패키지의 이름은 java로 시작할 수 없습니다. java패키지는 표준 API들의 모음을 구성해놓은 패키지입니다.
1. 자바의 키워드들도 패키지이름으로 사용할 수 없습니다.



######################################################################################################







######################################################################################################
개념정리_변수 타입

변수의 타입에는 기본타입, 참조타입이 있다.

참조타입
-배열타입
-클래스타입
-인터페이스타입

String s1 = "안녕"
String s2 = "안녕"
s1 == s2 
동일클래스라면 주소가 같게 입력되서 true
	-저장한걸또저장하네? -> cpp의 참조변수개념으로 저장됨 공간을 공유함
다른클래스라면 주소가 다르게 입력되서 false

그럼 문자열은 비교어떻게해?
아래처럼 해!

객체동등비교 메서드 : eqauls()


s1.equals(s2)
	-맞으면 트루
	-틀리면 폴스 불린자료형을 반환함
package str_equals;

public class User {
	public static void main(String[] args) {
		String id="맹탕구리";
		String id2="맹탕구";
		String pw;
		System.out.println(id.equals(id2));
		System.out.println(id.equals("맹탕구리"));
		System.out.println("랑낭".equals("랑낭1"));
	}

}




######################################################################################################












######################################################################################################
개념정리_기본 및 참조타입 개념, equals

* 기본 타입(primitive type) vs 참조 타입(reference type)

- 기본 타입이란 정수, 실수, 문자, 논리 값을 저장하는 데이터 타입입니다.
- 참조 타입이란 객체의 주소를 참조하는 타입으로 배열, 클래스, 인터페이스 타입을 말합니다.
- 기본 타입으로 선언된 변수는 실제 값(value)을 변수 안에 저장하지만, 참조 타입으로 선언된 변수는 메모리의 주소값을 변수 안에 저장합니다.
- 참조 타입으로 선언된 변수는 스택(stack)영역에 주소값을 저장하고 내부의 실제 값은 힙(heap)영역에 저장합니다.



* 참조 타입 String과 객체 동등 비교 메서드 equals()

- 자바는 문자열이 동일하다면 String 객체를 공유하도록 되어있습니다.
그래서 단순히 문자열을 String 변수에 할당한다면 같은 주소값을 갖게 됩니다.

ex) String str1 = "Hello"; String str2 = "Hello";
--> str1 == str2 -> true

- 그러나 new키워드를 사용해서 String객체를 직접 heap영역에 생성한다면 문자열의 내용이 같더라도 다른 주소값을 가지게 되므로 동등, 비동등 연산자(==, !=)의 결과가 false로 나오게 됩니다.

ex) String str3 = new String("Hello"); String str4 = new String("Hello");
--> str3 == str4 -> false

- 그래서 동일 String객체이든 다른 String 객체이든 상관없이 문자열의 내용 값 그자체를 비교할 때는 equals()  메서드를 사용해야 합    니다.


######################################################################################################


package other;

public class MainClass{
	public static void main(String[] args) {
		String str1 = "hello";
		String str2 = "hello";
		
		System.out.println(str1==str2);
		
		String str3 = new String("hello");
		String str4 = new String("hello");
		
		System.out.println(str3==str4);
		System.out.println(str1==str3);
		System.out.println(str1==str4);
		System.out.println(str2==str3);
		System.out.println(str2==str4);
		
		System.out.println(str1);
		System.out.println(str2);
		
		str1 += "hi";
		System.out.println(str1==str2);
		System.out.println(str1);
		System.out.println(str2);
		
	}
}









######################################################################################################
개념정리_객체지향 기술, 상속개념

* 객체 지향 프로그래밍 기술

- OOP 기술에는 은닉(캡슐화:Encapsulation), 상속(Inheritance), 다형성(Polymorphism)이 있습니다.


* 상속(Inheritance)

- OOP에서 상속은 기존의 클래스를 확장하여 새로운 클래스를 이끌어내는 것을 의미합니다.
- 상속 관계는 is a 관계를 만족하는 관계입니다.
ex) 돌고래 is a 포유류 --> 돌고래는 포유류의 속성을 가지고 있다.
- 상속은 기존의 코드를 재사용함으로써 불필요한 코드를 재작성하는 번거로움을 없앨 수 있고, 새로운 클래스를 만드는 시간과 노력을       줄일 수 있습니다.
- 자바에서는 C++에서 사용했던 다중상속의 문제점때문에 단일상속만을 지원합니다.
	-다이아몬드구조 
- 어떤 클래스가 다른 클래스로부터 상속을 받아 만들어지면 새롭게 만들어진 클래스를 자식(child or sub)클래스라고 부르며, 멤버변수       와 메서드를 물려준 클래스는 부모(parent or super)클래스라고 부릅니다.
- 상속을 하면 부모클래스의 멤버변수와 메서드가 자식클래스에 상속이 됩니다. 그러나 부모클래스의 생성자는 상속이 되지 않습니다.
- 상속을 사용하는 키워드는 extends 입니다.
- 상속을 하더라도 부모 클래스에서 private 접근제한을 갖는 멤버변수와 메서드는 상속대상에서 제외됩니다.
- 자바의 모든 클래스는 Object 클래스를 상속받고 있습니다. Object클래스는 자바의 최상위 클래스입니다.





#상속형태
-자식클래스의 이름 뒤에 extends라는 키워드를 쓰고 물려받을 클래스의 이름을 씀
	-다른클래스로부터 멤버변수와 메서드를 물려받는 클래스를 자식클래스라함

public class Student extends person {

};

#클래스를만들면서 상속만드는법
-클래스 마들때 superclass에 상속받을 클래스이름을 적으면됨


#object : 상속을 따로 지정하지 않으면 모두 object로 상속받게된다.
	-증거: 클래스만들려고키면 java.lang.Object라고 뜬다.
######################################################################################################












######################################################################################################
예제16)패키지생성 및 내부 클래스 불러오기

패키지생성
1)class에서 패키지만들기
-hello라는 package를 class에서 만들어라
	-hello하위에 bye패키지와 hi패키지를 만들고 각 패키지 내부에 패키지와 같은 이름의 class를 만들어라
		-각 패키지들은 모두 마우스로 만들어라.
2)공백 패키지만들기
-nulll(공백이란의미) 패키지를 만들어라.(클래스가 하나도 없는상태)
3)공백패키지만들고 내부에도 공백패키지만들기
	-flat, hierarchical두개로 보기좋게 해봐라


패키지이용(임폴트)
1)fruit이란 패키지를만들고 내부에 apple과 banana클래스를 만들어라.(내부설계할필요없음 임폴트만 시험할거니까)
	test란 패키지를 만들고 내부에 test란 파일을 만들어라.
2)import_ex란 패키지를만들고 내부에 ImportExample클래스를 만들어라
3)importexample클래스에서 fruit과 test패키지 내의 클래스들의 객체를 모두 만들어라.
apple과 banana는 동시에 import하고 너머지는 직접 하나하나 import하여 객체를 만들수있게하라



package import_ex;

import fruit.Apple;
import fruit.Banana;

import test.*;

public class ImportExample {
	public static void main(String[] args) {
		Apple a1 = new Apple();
		Banana b1 = new Banana();
		Test t1 = new Test();
		
		
		
		
		
	}
}

######################################################################################################




답:




package day0907.fruit;

public class Apple {

}

package day0907.fruit;

public class Banana {

}

package day0907.hello.bye;

public class Bye {

}

package day0907.hello.hi;

public class Hi {

}

package day0907;

import day0907.fruit.*;
//import day0907.fruit;
import day0907.hello.hi.Hi;
import day0907.hello.bye.Bye;

public class MainClass {
	Apple ap = new Apple();
	Banana bn = new Banana();
	Bye b = new Bye();
	Hi hi = new Hi();
}
























######################################################################################################
예제17)상속

inherit패키지내부에 phone 패키지를 만드는데 두개를 동시에 만들어라.
그리고 phone패키지 내부에 DmbPhone, MainClass, Phone 3개의 클래스를 만들어라
그후 아래 폼을 이용해서 출력결과가 실행되게하라(Phone과 DmbPhone 클래스를 설계하라!)

Phone클래스 멤버변수: String model, String color
Phone클래스 메서드(멤버함수): powerOn, powerOff, ring(벨울리는기능_전화오는기능), hangUp(전화끊는기능)

package inherit.phone;

public class MainClass {
	public MainClass() {
		//Dmb폰 객체 생성
		DmbPhone dp = new DmbPhone("햅틱", "메탈그레이", 10);
		
		//dmb폰 객체에서 상속받은 Phone클래스의 멤버변수에 접근
		System.out.println("모델 : "+dp.model);
		System.out.println("색상 : "+dp.color);
		
		//DmpPhone에서 선언한 멤버변수에 접근
		System.out.println("채널 : "+dp.channel);
		
		
		//Dmbphone으로 만들어진 객체를이용하여 Phone에서 상속받은 메서드 호출
		dp.powerOn();
		dp.ring();
		dp.hangUp();
		
		//DmbPhone에서 선언한 메서드 호출
		dp.turnOnDmb();
		dp.changeChannel(7);
		dp.turnOffDmb();
		
		//Dmbphone으로 만들어진 객체를이용하여 Phone에서 상속받은 메서드 호출
		dp.powerOff();
	}
}


<출력결과>
모델: 햅틱
색상: 메탈그레이
채널: 10
전원을 켭니다.
벨이 울립니다.
전화를 끊습니다.
방송 수신을 시작합니다.
채널 7번으로 변경합니다.
방송 수신을 종료합니다.
전원을 끕니다.


package inherit.phone;

public class Phone {
	public String model;
	public String color;
	
	public Phone(String model, String color){
		this.model = model;
		this.color = color;
	}
	
	public void powerOn() {
		System.out.println("전원을 켭니다.");
	}
	public void ring() {
		System.out.println("벨이 울립니다.");
	}
	public void hangUp() {
		System.out.println("전화를 귾습니다.");
	}
	public void powerOff() {		
		System.out.println("전원을 끕니다.");
	}
}



package inherit.phone;

public class DmbPhone extends Phone{
	public int channel;
	
	public DmbPhone(String model, String color, int channel){
		super(model, color);
		this.channel = channel;
	}
	
	public void turnOnDmb() {
		System.out.println("방송 수신을 시작합니다.");
	}
	public void changeChannel(int channel) {
		this.channel = channel;
		System.out.println("채널 "+this.channel+"번으로 변경합니다.");
	}
	public void turnOffDmb() {
		System.out.println("방송 수신을 종료합니다.");
	}
}


######################################################################################################




답:


package inherit.phone;

public class Phone {
	String model;
	String color;
	
	void powerOn() {
		System.out.println("전원을 켭니다.");
	}
	void powerOff() {
		System.out.println("전원을 끕니다.");
	}
	void ring() {
		System.out.println("벨이 울립니다.");
	}
	void hangUp() {
		System.out.println("전화를 끊습니다.");
	}
}




package inherit.phone;

public class DmbPhone extends Phone{
	 int channel;
	
	 DmbPhone(String mod, String col, int ch){
		 model = mod;
		 color = col;
		 channel = ch;
	 }
	
	void turnOnDmb() {
		System.out.println("방송 수신을 시작합니다.");
	}
	void turnOffDmb() {
		System.out.println("방송 수신을 종료합니다.");
	}
	void changeChannel(int n) {
		channel = n;
		System.out.printf("채널  %d번으로 변경합니다.\n", channel);
	}

}




















######################################################################################################
개념정리_overriding, overloading


* 메서드 재정의(Overriding) : 통상적으로 메서드의 기능은 같게끔 하고 내부 블록만 변경하는 것

- 메서드 재정의란 부모클래스로부터 상속받은 메서드를 자식클래스에서 행위를 바꾸거나 보완하기 위해 다시 정의해서 사용하는 것을 말합니다.

- 이는 부모클래스에서 특별한 용도로 사용하던 메서드를 자식클래스에서 다른 용도로 사용할 때 필요합니다.

- 부모클래스의 모든 메서드가 자식클래스에 맞게 설계되어 있다면 가장 이상적인 상속이지만, 특정 메서드는 자식 클래스가 사용하기 에 적합하지 않을 수도 있습니다.

- 이 경우 상속된 일부 메서드는 자식클래스에서 재정의하여 사용해야 합니다.

- 메서드가 자식클래스에서 재정의되었다면 자식객체를 통해 메서드를 호출했을 때 새롭게 재정의된 메서드가 호출됩니다.

- 메서드 재정의 규칙
1. 반드시 상속을 전제로 해야합니다.
1. 반드시 반환 유형이 같아야 합니다.
1. 메서드 이름이 같아야 합니다.
1. 매개 변수 선언이 정확히 일치해야 합니다.
1. 접근제한자는 같거나 더 제한이 없어야 합니다.(more public)


* 중복(Overloading) : 통상적으로 메서드의 기능을 변경하는 것 

- 자바는 메서드나 생성자의 중복 선언을 허용합니다.

- 중복은 메서드 또는 생성자를 선언할 때 이름은 같지만 매개 변수의 유형이나 개수를 다르게 선언해 놓는 것을 의미합니다.

- 중복을 사용하면 하나의 메서드로 매개 변수의 유형에 따라 다른 동작이 실행되게 합니다.

- 중복의 조건

1. 이름이 같아야 합니다.
1. 접근제한자나 반환유형은 영향을 미치지 않습니다.
1. 매개 변수의 유형이 달라야 합니다.
1. 매개 변수의 개수가 달라야 합니다.
1. 매개 변수의 순서가 달라야 합니다.




#차이점: 매개변수의 변화
overriding : 매개변수가 안바뀌고 외부형틀이 완전히 똑같다.
overloading : 매개변수가 변경되고 반환자료형도 변경할수있다.

공통점: 내부블록 수정가능, 기존메서드와 이름이 같음



package overloading.basic;
/*
 * 오버로딩(중복)-하나의 클래스 내부에 같은 이름을 가진 메서드를 여러개 선언할수 있게하는 문법
 * 	-부모꺼를 오버로딩할순 없는가?
 * 1.매개변수의 데이터타입이 달라야함
 * 2.매개변수의 순서가 달라야함
 * 3.매개변수의 개수가 달라야함
 */
public class Basic {
	void input(int a) {
		System.out.println("정수 1개가 입력됨");
	}
	void input(int i, int j) {
		System.out.println("정수 2개가 입력됨");
	}
	void input(String s) {
		System.out.println("문자열 1개가 입력됨");
	}
	void input(String s, double d) {
		System.out.println("문자열 1개, 실수형 1개가 입력됨");
	}
	void input(double x, String d) {
		System.out.println("실수형 1개, 문자열 1개가 입력됨");
	}
}



package overloading.basic;

public class MainClass {

	public static void main(String[] args) {
		Basic b = new Basic();
		b.input(5);
		b.input("하이");
		b.input(5,10);
		b.input(3.14,"하하");
		
		System.out.println();
	}

}


######################################################################################################


















######################################################################################################
예제17)overriding

11일차의 goodcase안의 employee,main,person,student,teacher를 가져오고 아래처럼 출력되도록
오버라이딩하라(main은 손대지마라)

이름: 홍길동, 나이: 45
이름: 이순신, 나이: 23, 학번: 2018110033
이름: 강감찬, 나이: 44, 과목: 수학
이름: 신사임당, 나이: 33, 부서: 구매부


package person;

/*
 * 데이터를 다른 클래스에게 물려주는 클래스를 부모클래스라고 합니다.
 * 상속을 사용할 시 데이터를 물려받는 클래스에게 부모클래스의 멤버변수,
 * 메서드가 상속됩니다.
 * 단, 생성자는 상속되지 않습니다.
 */
public class Person {
	
	String name;
	int age;
	
	String info() {
		return "이름: " + name + ", 나이: " + age;
	}
	
}

package person;

public class Employee extends Person {
	
	String department;
	
	
	String info() {
		return "이름: " + name + ", 나이: " + age+"부서: "+department;
	}
	
}

package person;

/*
 * 다른 클래스로부터 멤버변수와 메서드를 물려받는 클래스를
 * 자식 클래스라고 부릅니다. 
 * 자식 클래스의 이름 뒤에 extends라는 키워드를 쓰고 
 * 물려받을 클래스의 이름을 써줍니다.
 */
public class Student extends Person {
	String stuID;
	
	String info() {
		return "이름: " + name + ", 나이: " + age+"학번: "+stuID;
	}
	
}

package person;

public class Teacher extends Person {
	
	String subject;
	String info() {
		return "이름: " + name + ", 나이: " + age+"과목: "+subject;
	}
	
}

######################################################################################################




답:

package overriding.person;

/*
 * 데이터를 다른 클래스에게 물려주는 클래스를 부모클래스라고 합니다.
 * 상속을 사용할 시 데이터를 물려받는 클래스에게 부모클래스의 멤버변수,
 * 메서드가 상속됩니다.
 * 단, 생성자는 상속되지 않습니다.
 */
public class Person {
	
	String name;
	int age;
	
	String info() {
		return "이름: " + name + ", 나이: " + age;
	}
	
}



package overriding.person;

/*
 * 다른 클래스로부터 멤버변수와 메서드를 물려받는 클래스를
 * 자식 클래스라고 부릅니다. 
 * 자식 클래스의 이름 뒤에 extends라는 키워드를 쓰고 
 * 물려받을 클래스의 이름을 써줍니다.
 */
public class Student extends Person {
	String stuID;
	String info() {
		return "이름: " + name + ", 나이: " + age + ", 학번: " + stuID;
	}
	
}




package overriding.person;

public class Teacher extends Person {
	
	String subject;
	String info() {
		return "이름: " + name + ", 나이: " + age + ", 과목: " + subject;
	}
}




package overriding.person;

public class Employee extends Person {
	
	String department;
	String info() {
		return "이름: " + name + ", 나이: " + age + ", 부서: " + department;
	}
}




package overriding.person;

public class MainClass {

	public static void main(String[] args) {
		
		Person hong = new Person();
		hong.name = "홍길동";
		hong.age = 45;
		System.out.println(hong.info());
		
		Student lee = new Student();
		lee.stuID = "2018110033";
		lee.name = "이순신";
		lee.age = 23;
		System.out.println(lee.info());
		
		Teacher kang = new Teacher();
		kang.subject = "수학";
		kang.name = "강감찬";
		kang.age = 44;
		System.out.println(kang.info());
		
		Employee shin = new Employee();
		shin.department = "구매부";
		shin.age = 33;
		shin.name = "신사임당";
		System.out.println(shin.info());
		

	}

}









######################################################################################################
개념정리_this


#생성자를 메서드명으로 호출하는방법: 첫호출시밖에없음.
	-그다음부터는 this로
	-this(name, 1);
#생성자생성순서: 매개변수가 많을수록 모든 매개변수를 수용할수있는 생성자를 만든후 점점 매개변수를 줄여가는것이 좋다.
#f3을 누르면 만들어진곳으로 향할수있다.

* this

- this는 자기 자신 객체를 지정할 때 사용하는 키워드입니다.

- this. 을 사용하면 동일 클래스 내의 멤버(멤버변수, 메서드)를 참조할 수 있습니다.

- this()를 사용하면 생성자 내부에서 자신의 다른 생성자를 호출할 수 있습니다.

package this_.car;

public class Car {
	String model;
	int speed;
	Car(String model){
		this.model = model;
	}
	Car(){
		this("이름없음");
	}
	
	void accel(int speed) {
		if(this.speed >= 150) {
			System.out.println("속도를 더이상 올릴수 없습니다.");
		}else {
			this.speed = speed;
		}
	}
	void run(int maxSpeed) {
		for(int i=0;i<=maxSpeed;i+=30) {
			this.accel(i);
			System.out.printf("%s가 달립니다.(시속: %dkm/h)\n", this.model, 
					this.speed);
		}
	}
}

package this_.car;

public class MainClass {
	public static void main(String[] args) {
		Car myCar1 = new Car("람보르기니 아벤타도르");
		Car yourCar = new Car("아반떼 스포츠");
		
		myCar1.run(250);
		System.out.println("==============================");
		yourCar.run(130);
	}
}





* super

- super는 한단계 위 부모클래스의 객체를 지정할 때 사용하는 키워드입니다.

- super. 을 사용하면 부모클래스의 멤버를 참조할 수 있습니다.

- super()는 생성자 내부에서만 사용이 가능하며, 부모클래스의 생성자를 호출하는데 사용합니다.
	-생성자 외부에서는 super()로 부모클래스의 생성자를 불러오는것이안되고
	 대신에 외부에서 super.으로 메서드 혹은 변수에 접근하는건 가능하다.

package super_.person;
public class Student extends Person {
	String stuID;
	
	Student(String name, int age, String str){
		super(name, age);
		this.stuID = str;
//		this.name = name;
//		this.age = age;
		
	}
	
	String info() {
		//return "이름: " + name + ", 나이: " + age + ", 학번: " + stuID;
		return super.info() +" 학번: " + stuID;
	}
	
}

- 생성자의 첫 라인에는 반드시 this(), super()가 있어야 하는데 이를 기술하지 않으면 묵시적으로 super()가 삽입되어 부모클래스의 
기본 생성자를 자동으로 호출합니다.
	-즉 생성자 첫라인에 this()를 쓰면 super()를 안쓰고 this()를 안쓰면 자동으로 super()가 묵시적으로 삽입된다.

package super_.person;

public class Teacher extends Person {
	
	String subject;
	
	Teacher(){	//아래 주석의 teacher가 이놈의 생략형이다.
		
	}
	/*
	* Teacher(){	
	*	super(); //이렇게 묵시적으로 super가 삽입되니까 부모의 매개변수가없는 생성자를 호출하는데
	* }		//Person에서 기본생성자가 없으면 혹은 매개변수가없는 생성자가 없다면 이건 에러이고
	*			//위에 있는 teacher에도 super가 생략되있는것일뿐이니 위에도 에러가난다.
	*/
	
	String info() {
		return "이름: " + name + ", 나이: " + age + ", 과목: " + subject;
	}


- 생성자 내부에서 또다른 생성자를 호출할 때는 반드시 생성자 블록 내부의 첫 라인에 기술해야 합



-----------------------------------------------



######################################################################################################
















######################################################################################################
예제18)this, super

this_.person패키지에 있는  person student teacher를 가져온다.

아래로 했을때 출력이되도록하라
-이때 super를 모조리 이용해서하라
-super로 부모생성자를부르고
-this로 super대신 사용해라
	-this를쓰면 super가 쓰여지지않는다.
	-super로 다양한 매개변수를넣어봐라

package super_.person;

public class MainClass {

	public static void main(String[] args) {
		Student hong = new Student("홍길동", 13, "34");	
		System.out.println(hong.info());
		
		Teacher lim = new Teacher("임창정", 50, "음악");

		System.out.println(lim.info());
	}

}

이름: 홍길동, 나이: 13 학번: null	//부모꺼에서 자식객체 info 호출하여 출력된거
이름: 홍길동, 나이: 13 학번: 34	//자식꺼에서 지꺼 info 호출하여 출력된거
이름: 임창정, 나이: 50null		//부모꺼에서 자식객체 info 호출하여 출력된거
이름: 임창정, 나이: 50음악		//자식꺼에서 지꺼 info 호출하여 출력된거

package super_.person;

/*
 * 데이터를 다른 클래스에게 물려주는 클래스를 부모클래스라고 합니다.
 * 상속을 사용할 시 데이터를 물려받는 클래스에게 부모클래스의 멤버변수,
 * 메서드가 상속됩니다.
 * 단, 생성자는 상속되지 않습니다.
 */
public class Person {
	
	String name;
	int age;
	
	
	Person(String name, int age){
		this.name = name;
		this.age = age;
		
		System.out.println(this.info());
	}

	String info() {
		return "이름: " + name + ", 나이: " + age;
	}
	
}


package super_.person;

/*
 * 다른 클래스로부터 멤버변수와 메서드를 물려받는 클래스를
 * 자식 클래스라고 부릅니다. 
 * 자식 클래스의 이름 뒤에 extends라는 키워드를 쓰고 
 * 물려받을 클래스의 이름을 써줍니다.
 */
public class Student extends Person {
	String stuID;
	
	Student(String name, int age, String stuID){
		super(name, age);
		this.stuID = stuID;
	}
	
	String info() {
		return "이름: " + name + ", 나이: " + age+"학번: "+stuID;
	}
	
}




package super_.person;

public class Teacher extends Person {
	
	String subject;
	
	public Teacher(String name, int age, String subject){
		super(name, age);
		this.subject = subject;
	}
	
	String info() {
		return "이름: " + name + ", 나이: " + age+"과목: "+subject;
	}
	
}



######################################################################################################




답:



package super_.person;

/*
 * 데이터를 다른 클래스에게 물려주는 클래스를 부모클래스라고 합니다.
 * 상속을 사용할 시 데이터를 물려받는 클래스에게 부모클래스의 멤버변수,
 * 메서드가 상속됩니다.
 * 단, 생성자는 상속되지 않습니다.
 */
public class Person {
	
	String name;
	int age;
	
	Person(String name, int age){
		this.name = name;
		this.age = age;
		System.out.println(this.info());
	}
	Person(String name){	//생성자에서 this를 이용해 생성자호출
		this(name, 1);
//		this.name = name;
//		this.age = 1;
		//System.out.println(this.info());
	}
	Person(){
		this("이름없음", 1);
	}
	
	String info() {
		return "이름: " + name + ", 나이: " + age;
	}
	
}




package super_.person;

/*
 * 다른 클래스로부터 멤버변수와 메서드를 물려받는 클래스를
 * 자식 클래스라고 부릅니다. 
 * 자식 클래스의 이름 뒤에 extends라는 키워드를 쓰고 
 * 물려받을 클래스의 이름을 써줍니다.
 */
public class Student extends Person {
	String stuID;
	
	Student(String name, int age, String str){
		super(name, age);
		this.stuID = str;
//		this.name = name;
//		this.age = age;
		
	}
	Student(){
		this("이름없음", 1, "학번없음");	//여기는 super()가 없음 어차피 this가면 거기에
					//결국 super()를 만나기때문
	}
	
	String info() {
		//return "이름: " + name + ", 나이: " + age + ", 학번: " + stuID;
		return super.info() +" 학번: " + stuID;
	}
	
}



package super_.person;

public class Teacher extends Person {
	
	String subject;
	
	Teacher(String name, int age, String subject){
		super(name, age);
		this.subject=subject;
	}
	
	String info() {
		return super.info() + subject;
	}
}






















































######################################################################################################
개념정리_접근제한자

modifier		same class	same package	other package	other package
							& subclass(상속)	(universe)
public				o		o		o		o
package friendly		o		o		x		x
protected			o		o		o		x
	-p.f에서 class멤버생성자에대해 제한을걸었을때 해당하는것에대해 같은패키지가 아니면 지금 이것의 사용을 허락하지않겠다 라는뜻인데
		protected는 다른패키지 원칙적으로 안되는데 부모자식관계면 이해해주겠다 라는뜻으로 이해하면 됨.
private				o		x		x		x




* 접근 제한자(Access Modifier)

- 접근 제한자는 클래스와 멤버변수, 메서드, 생성자의 접근을 제어할 수 있는 제한자입니다.
- main() 메서드가 없는 클래스는 외부 클래스에서 이용할 목적으로 설계된 라이브러리 클래스입니다.
- 라이브러리 클래스를 설계할 때는 외부 클래스에서 접근할 수 있는 멤버와 접근할 수 없는 멤버로 구분해서 변수, 생성자, 메서드를 
	설계하는 것이 바람직합니다.
- 외부에서 객체 생성을 막기 위해 생성자를 호출하지 못하게 하거나 객체의 특정 데이터를 보호하기 위해 해당 멤버변수에  
	접근하지 못하도록 막는 것이 접근 제한자의 역할입니다.
- 클래스에는 접근 제한자를 public과 package friendly만 붙일 수 있습니다.
	-클래스에선 이거고 나머지 멤버변수 메서드 생성자는 다른것도가능
	
디폴트값: p.f

- 접근 제한자의 종류

1. public: 같은 클래스, 같은 패키지, 다른 패키지를 막론하고 접근이 가능.
1. protected: 같은 클래스, 같은 패키지는 접근이 가능하지만 다른 패키지에 속해있는 클래스인 경우 상속관계가 없으면 접근이 불가능.
1. package friendly(접근 제한자를 붙이지 않는 형태): 같은 클래스, 같은 패키지에서만 접근이 가능하며  패키지가 다를  경우 접근이  불가능.
1. private: 같은 클래스 내부가 아니면 접근이 불가능.


예시는 Day13의 아래 패키지들을 참고
클래스의 public, p.f 예시
	-modi.cls.pac1,2
	
생성자의 public, p.f, private 예시
	-modi.constructor.pac1,2

멤버의 public, p.f, private 예시
	-modi.member.pac1,2

protected에 대한 멤버, 생성자 적용 예시
	-modi.protec.pac1,2

######################################################################################################













######################################################################################################
개념정리_은닉

* 은닉(Encapsulation)

- 은닉은 사용자에게 상세한 내부 구현을 숨기고 필요한 부분만 보이게 하는 것입니다.
	-꽁꽁숨겨놓는 이 은닉을 캡슐화라 한다.
- 은닉을 사용하기 위해서는 클래스의 멤버변수의 접근제한자를 private으로 설정합니다.
- 은닉된 멤버변수에 접근하기 위해서는 공개된(public) 메서드를  통해서  접근할  수 있는데,  변수의  값을 변경시키는데 
사용되는  메서드 는 setter메서드라고 부르며, 변수의 값을 얻어오는데 사용하는 메서드를 getter메서드라고 부릅니다.
- 이처럼 공개 메서드를 이용하여 데이터를 변경시킬 경우 메서드 내에 데이터 유효성을 검증할 수 있는 루틴을 넣을 수 있습니다.
- 뿐만 아니라 경우에 따라 접근 권한을 체크할 수 있는 로직을 포함시키면 인가되지 않은 사용자에게 중요한 데이터나 로직을 숨길 수 도 있고, 이를 제어할 수도 있습니다.
- 멤버변수만 private 제한자를 가지는 것은 아닙니다. 외부에 공개하고 싶지 않은 메서드들도 private으로 선언할 수 있습니다.

#setter/getter두는 이유
값의 유효성을 검증하기위해
위치를 왜 main에 안두는가?
	-> 추측) main에서 사용자가 입력하면 if로 처리할수도 있지만 그럼 모든 사용자가 사용하는 main코드에 중복코드가 발생하기도하고
	   main이 아닌 다른곳에서 사용하더라도 계속 적어야한다. 그래서 연관성이 있는 기능은 해당 클래스내에 넣는것이좋기때문에
		밖에서는아예 변수에 접근못하게하고 내부에서 값의 유효성검증을하고 저장하는 기능을가진 메서드를 만들어야하는것이다.

#참고: private로두고 생성자로만 값을 넣고싶은경우 setter/getter 안만들어도됨
#참고: 부모에서 은닉후 자식에서 제한자 정의할때 똑같거나 더 public하게 만들어야한다.

#참고: eclips 기능
	-생성자 자동생성 : alt shift S or 마우스 우클릭 source -> constructor
	-gettersetter만들기또한 동일경로
	-상속시 자식메서드에서 overriding 가능


######################################################################################################















######################################################################################################
개념정리_다형성

* 다형성(Polymorphism)

- 다형성이란 "객체가 여러 형태를 가진다"라는 의미로 해석되며, 하나의 객체가 여러가지 유형으로 사용되는 것을 의미합니다.
- 다형성은 상속을 전제조건으로 합니다.
- 다형성을 위해 자바는 자식클래스가 부모클래스의 타입을 가질 수 있도록 허용합니다. 즉, 부모 타입에 모든 자식객체가 대입될 수 있습니다.

- 객체의 교환성을 제고하기 위함이다.
- 상속을 전제로 서로의 타입을 교환하여 사용할수 있다.



package poly.basic;
/*
 * 하나의 클래스 파일안에 여러 클래스들을 선언할수 있다.
 * 단 파일명과 동일한 이름을 가진 클래스가 반드시 존재해야하며 해당 클래스만 public 제한자를 
 * 가질 수 있다.
 */

class A { 
//	int a;
//	public static void main(String[] args) {
//		Basic a = new Basic();
//		a.z = 4;
//	}
}
class B extends A {}
class C extends A {}
class D extends B {}
class E extends C {}


public class Basic {
//	private int z = 5;
	
	A a = new A();
	B b = new B();
	C c = new C();
	D d = new D();
	E e = new E();
//	public static void main(String[] args) {
//		A a = new A();
//		a.a = 4;
//	}

//	a.a = 4; 왜 접근을못할까? p.f일텐데 public으로 해도안되고 
	
	A a1 = b;	//자식객체가 부모객체로 자동 형변환되는것이다.
	A a2 = c;	//궁금: byte->int로 변경할때는 byte 크기가 작아서 자동형변환되는건데
			//부모객체는 코드양이나 멤버변수 등 메모리공간 자체가 더 작은데 왜 자동형변환되지?
	A a3 = new D();
	A a4 = e;
	
	Object o1 = new A();	//object는 모든 클래스의 부모이기때문에 모든 객체의 형변환
		//가능
	Object o2 = new String();
}



######################################################################################################







package other;

class A { 
	int a;
	public static void main(String[] args) {
		System.out.println("hi");
	}
}
class B extends A {}
class C extends A {}
class D extends B {}
class E extends C {}


public class MainClass{
	public static void main(String[] args) {
//		private int z = 5;
		
		A a = new A();
		B b = new B();
		C c = new C();
		D d = new D();
		E e = new E();
//		public static void main(String[] args) {
//			A a = new A();
//			a.a = 4;
//		}
		
		a.a = 4;
		

//		a.a = 4; 왜 접근을못할까? p.f일텐데 public으로 해도안되고 
		
		A a1 = b;	//자식객체가 부모객체로 자동 형변환되는것이다.
		A a2 = c;	//궁금: byte->int로 변경할때는 byte 크기가 작아서 자동형변환되는건데
				//부모객체는 코드양이나 멤버변수 등 메모리공간 자체가 더 작은데 왜 자동형변환되지?
		A a3 = new D();
		A a4 = e;
		
		Object o1 = new A();	//object는 모든 클래스의 부모이기때문에 모든 객체의 형변환
			//가능
		Object o2 = new String();
		
	}
}


















######################################################################################################
개념정리_다형성


* 다형성(Polymorphism)

- 다형성이란 "객체가 여러 형태를 가진다"라는 의미로 해석되며, 하나의 객체가 여러가지 유형으로 사용되는 것을 의미합니다.
- 다형성은 상속을 전제조건으로 합니다.
- 다형성을 위해 자바는 자식클래스가 부모클래스의 타입을 가질 수 있도록 허용합니다. 즉, 부모 타입에 모든 자식객체가 대입될 수 있습니다.


* 이종모음(Heterogeneous Collection)

- 이종모음구조는 배열에 다형성을 적용시키는 이유입니다. 배열은 원래 동종모음 구조입니다.
- 예를 들어 int[] iArr = new int[10]; 이런 구조의 배열이 있다면 iArr배열에는 int형 정수 데이터만 저장할 수 있습니다.
- 하지만 다형성을 이용하면 이종모음 구조의 객체 배열이 생성 가능합니다.
- 아래처럼 학생,선생,회사원을 한번에 출력하고자할때 각 객체를 동종모음구조인 배열로 만들면 배열이 3개필요하다.
	그러면 포문도 3개인데 이때 다형성을 이용한 이종모음구조로 배열을 만들면 배열1개에 for문도1개라서 매우 편리해진다.

package poly.person;

public class MainClass {

	public static void main(String[] args) {
		// TODO Auto-generated method stub

//		Student hont = new Student("홍길동", 15, "32");
//		Student lee = new Student("이순신", 17, "21");
//		Student park = new Student("박찬호", 13, "61");
//		
//		Teacher kim = new Teacher("김철수", 26, "영어");
//		Teacher song = new Teacher("송영희", 29, "수학");
//		
//		Employee lim = new Employee("임꺽정", 45, "행정");
//		
//		
//		System.out.println(hont.info());
//		System.out.println(lee.info());
//		System.out.println(park.info());
//		System.out.println(kim.info());
//		System.out.println(song.info());
//		System.out.println(lim.info());
		
		
//		Student[] students = {hont, lee, park};
//		Teacher[] teachers = {kim, song};
//		Employee[] employees = {lim};
//		
//		System.out.println("==========================");
//		for(int i=0;i<students.length;i++) {
//			System.out.println(students[i].info());
//					
//		}
//		
//		System.out.println(hont);
//		System.out.println(students[0]);
//		System.out.println(hont==students[0]);

		
		Person hont = new Student("홍길동", 15, "32");
		Person lee = new Student("이순신", 17, "21");
		Person park = new Student("박찬호", 13, "61");
		
		Person kim = new Teacher("김철수", 26, "영어");
		Person song = new Teacher("송영희", 29, "수학");
		
		Person lim = new Employee("임꺽정", 45, "행정");
		
		
		System.out.println(hont.info());
		System.out.println(lee.info());
		System.out.println(park.info());
		System.out.println(kim.info());
		System.out.println(song.info());
		System.out.println(lim.info());

		System.out.println("==============================");
		Person[] people = {hont, lee, park, kim, song, lim};
		
		for(int i=0;i<people.length;i++) {
			System.out.println(people[i].info());
					
		}
	}

}

######################################################################################################



















######################################################################################################
개념정리_다형성의 문제점

package poly.promotion;

public class Parent {
	public void method1() {
		System.out.println("부모의 1번 메서드 호출!");
	}
	public void method2() {
		System.out.println("부모의 2번 메서드 호출!");
	}
}


package poly.promotion;

public class Child extends Parent{

	public void method2() {
		System.out.println("재정의된 2번 메서드 호출!");
	}
	
	public void method3() {
		System.out.println("자식의 3번 메소드 호출!");
	}
	
}



package poly.promotion;

public class MainClass {

	public static void main(String[] args) {
		// TODO Auto-generated method stub

		Parent p1 = new Parent();
		p1.method1();
		p1.method2();
		
		System.out.println("----------------");
		
		Child c1 = new Child();
		c1.method1();
		c1.method2();
		c1.method3();
		
		Parent p2 = c1;	//Child->Parent : promotion(자동형변환)
		System.out.println(c1==p2);
		
		p2.method1();
		p2.method2();	//parent가 아니라 Child의 메서드가 나온다.
//		p2.method3();	//본인건데 안써짐 부모한테 물려받은거만 써지는데 이러면 소용이없다.
					//그래서 다음 부분에서 방법이나온다.
	}

}



부모의 1번 메서드 호출!
부모의 2번 메서드 호출!
----------------
부모의 1번 메서드 호출!
재정의된 2번 메서드 호출!
자식의 3번 메소드 호출!
true
부모의 1번 메서드 호출!
재정의된 2번 메서드 호출!


######################################################################################################














######################################################################################################
개념정리_강제형변환


package poly.casting;

public class MainClass {

	public static void main(String[] args) {
		//promotion이 적용되면 자식클래스의 본래멤버를 참조할 수 없음
		Parent p = new Child();
		p.method1();
		p.method2();
//		p.method3();
		System.out.println("-----------------------");
		
		Child c = (Child)p;
		c.method3();
		
		/*
		 * 한번 promotion이 일어난 객체를 대상으로 강제타입변환을 사용할수있음
		 */
//		Child ccc = (Child)new Parent(); //parent를 만들고 child로 바꾼거임 이럼에러
	}

}


#for문돌리기위해 promotion(자동형변환)해서 이종모음구조로도 배열을 만들수 있게하고 그렇게된녀석은 자식의 메서드를 못쓰니까
 자식의메서드를 쓰기위할때는 다시 강제형변환해서 본인의 형태로해서 사용하는 형태이다. 그래서 자동형변환후에 강제형변환을한다.
	



* 강제 타입 변환(Type Casting)

- 강제 타입 변환은 부모 타입을 자식 타입으로 변환하는 것을 말합니다.
- 객체에서 타입 캐스팅을 사용하려면 우선 먼저 Promotion이 일어나야 합니다. 즉, 부모 타입으로 한번 형 변환이 된 자식 객체만 강      제 타입 변환을 사용할 수 있습니다.
- Promotion이 일어나면 자식 클래스가 가지고 있는 재정의되지 않은 메서드를 사용할 수 없다는 단점이 있었습니다. 
	이 단점을 극복  하기 위해 강제 타입 변환을 사용하여 자식 메서드를 호출하는 방법을 사용합니다.




불편함 => 편리함추구 => 다형성필요성제기 => 형변환발전(자식객체는 부모클래스를 자료형으로 둘수있게하는 형변환promotion 및 강제형변환) 
	=> 다형성구현 => 이종모음구조 객체 배열탄생 => 코드수줄음, 배열관리용이, 결과값출력용이 등

형변환방법
-대입연산자
-매개변수
-반환자료형 

######################################################################################################


























######################################################################################################
개념정리_매개변수의 다형성


* 매개 변수의 다형성

- promotion은 멤버 변수의 값을 대입할 때도 발생하지만, 메서드를 호출할 때 사용하는 매개 변수에도 발생할 수 있습니다.
- 보통 메서드를 호출할 때는 메서드 선언부에서 지정한 데이터 타입과 일치하는 매개값을 전달하여 호출하지만, 매개 변수에 다형성을 
적용하면 자식 객체를 전달할 수도 있습니다.


#매개변수의 다형성필요이유

package poly.param;

public class Car {
	public void run() {
		System.out.println("차가 달립니다.");
	}
}

package poly.param;

public class Ferrari extends Car{


	public void run() {
		System.out.println("페라리가 달립니다.");
	}
	
}

package poly.param;

public class Sonata extends Car{

	
	public void run() {
		System.out.println("소나타가 달립니다.");
	}

}

package poly.param;

public class Driver {
	public void drive(Ferrari f) {
		f.run();
	}
	public void drive(Sonata f) {
		f.run();
	}
}




package poly.param;

public class MainClass {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Driver kim = new Driver();
		Ferrari f = new Ferrari();
		
		kim.drive(f);
		
		Sonata s = new Sonata();  //이렇게하면 kim.drive(s)가 안되는 문제가있다.
									//드라이버에 매개변수에 오버로딩해야함
								//하지만 차종류 300만대가 넘어가면 오버라이딩도 300만번
								//넘많음 ㅠㅠ 비효율적임 그래서 다형성을 사용한다!
		
		kim.drive(s);
		
	}

}





------------------------------------



package poly.instanceof_;

public class MainClass {

	public static void main(String[] args) {
		printPersonInfo(new Person("닭강정",22));
		printPersonInfo(new Student("김말이", 24, "44"));
		printPersonInfo(new Teacher("볶음밥", 33,"요리"));
		printPersonInfo(new Employee("떡볶이",21, "주방"));

	}
	
	
	public static void printPersonInfo(Person p) {
		if(p instanceof Student) {
			System.out.println("***********학생의 정보***********");
		}
		else if(p instanceof Teacher) {
			System.out.println("***********선생님의 정보***********");
		}
		else if(p instanceof Employee) {
			System.out.println("***********회사원의 정보***********");
		}
		else {
			System.out.println("***********사람의 정보***********");
		}
		
		System.out.println(p.info());
	}
}







* instanceof

- 자바의 키워드 중에서 instanceof 는 객체가 지정한 클래스의 인스턴스인지 아닌지 검사할 때 사용하는 연산자입니다.
- instanceof 연산자의 왼쪽 항의 객체가 오른쪽 항 클래스의 인스턴스 즉, 오른쪽 항의 객체가 생성되었다면 true를 리턴하고, 그렇지 않으면 false를 리턴합니다.
- ex) Person p = new Student();
p instanceof Student -> true




######################################################################################################










######################################################################################################
개념정리_static 공용변수(멤버변수)


#참고: 모든 instance field(일반변수)는 int a 와 같은 방식으로 만들지만 a앞에 모두 this.이 생략되어있는 것이다.

#static 변수 예시

package static_.field;

public class MainClass {
	public static void main(String[] args) {
		Count c1 = new Count();
//		c1.a = 4;
//		c1.b = 5;	에러는 아니지만 경고가뜸 즉 정적멤버변수로 접근할때는 클래스로 접근하는것을 권장
		//Count.b = 6;
		
		
		
		c1.a++;
		c1.b++;
		System.out.println("a : "+c1.a+ "b : "+c1.b);
		
		Count c2 = new Count();
		c2.a++;
		c2.b++;
		System.out.println("a : "+ c1.a++ + "b : "+c1.b);
	}
}

#스태틱 멤버(변수, 메소드) 찾기 응용
Math.random();
->Math는 객체가 아니다 new로 못만드니까 근데 메소드를부르니 random()메소드는 스태틱 메서드인거다.
Math.PI
->클래스.변수형태로 PI는 스태틱 멤버변수다.

######################################################################################################











######################################################################################################
개념정리_static 메소드호출, 메서드사용 이유 예시

#메서드호출
package static_.method;

public class MainClass {

	public static void main(String[] args) {
		/*
		 -static이 붙은 멤버는 개체 생성없이 클래스 이름으로 직접참조가능
		 */
		System.out.println(Count.method2());
		Count.b +=50;
		System.out.println(Count.method2());
		Count.b +=20;
		System.out.println(Count.method2());

	}

}

#메서드사용 이유 예시


package static_.calc;

public class Calculator {
	
	/*
	 -계산기별로 색깔이 다를수 있기때문에 color같은 변수는 데이터를 공유시켜서는 안됨
	 -하지만 pi같은 원주율값은 계산기마다 동일하기때문에 공유해서 사용하는것이 더 바람직함
	 */
	public String color;
	public static double Pi;
	
	/*
	 -일반 멤버변수를 사용하고있는 메서드는 정적메서드로 선언하면 안됨
	 */
	public void setColor(String color) {
		this.color = color;
	}
	public String getColor() {
		return color;
	}
	
	public static double areaCircle(int r) {
		return r* r* Pi;
	}
	
}

######################################################################################################












######################################################################################################
예제19)static 메소드

1)아래의 에러를 고쳐라

package static_.method;

public class Count {
	public int a;
	public static int b;
	
	//일반메서드 선언
	public int method1() {
		a=10;
		return a+b;
	}
	//일반메서드 안에서는 일반멤버변수와 정적멤버변수를 모두 참조할수 있음
	
	//정적메서드선언
	public static int method2() {
		a=10;
		return a+b;
	}
	/*
	 -static method 내부에서는 static이 붙은 변수나 메서드만 참조할 수 있씁니다.
	 -static 블록 내부에서 non-static멤버를 참조하려면 객체생성을 통해 참조해야 함
	 */
}

package other;

public class Count {
	public  int a;
	public static int b;

	//일반메서드 선언
	public int method1() {
		a=10;
		return a+b;
	}
	//일반메서드 안에서는 일반멤버변수와 정적멤버변수를 모두 참조할수 있음

	//정적메서드선언
	public static int method2() {
		Count c = new Count();
		c.a=10;
		return c.a+b;
	}
	/*
		 -static method 내부에서는 static이 붙은 변수나 메서드만 참조할 수 있씁니다.
		 -static 블록 내부에서 non-static멤버를 참조하려면 객체생성을 통해 참조해야 함
	 */


}


######################################################################################################

답:

package static_.method;

public class Count {
	public int a;
	public static int b;
	
	//일반메서드 선언
	public int method1() {
		a=10;
		return a+b;
	}
	//일반메서드 안에서는 일반멤버변수와 정적멤버변수를 모두 참조할수 있음
	
	//정적메서드선언
	public static int method2() {
		Count c = new Count();
		c.a=10;
		return c.a+b;
	}
	/*
	 -static method 내부에서는 static이 붙은 변수나 메서드만 참조할 수 있씁니다.
	 -static 블록 내부에서 non-static멤버를 참조하려면 객체생성을 통해 참조해야 함
	 */
}




















######################################################################################################
개념정리_사용 제한자(Usage Level modifier)

* static

- static 제한자는 변수, 메서드에 적용되는 자바의 키워드입니다.
- static 메서드나 변수는 해당 클래스의 객체 없이도 참조할 수 있습니다.
- static 블록(static 메서드, 정적 초기화자) 안에는 static 변수만 사용해야하고, static 메서드만 호출할  수 있습니다. 
	즉 static 블록에서 non-static 멤버를 객체 생성 없이 직접 참조할 수 없습니다.
- static 제한자는 지정된 변수와 메서드를 객체와 무관하게 만들어주기 때문에 this를 가질 수 없습니다.
- static 메서드는 non-static 메서드로 재정의(Overriding) 될 수 없습니다.
- 대표적인 static 메서드는 애플리케이션의 main() 메서드입니다.
- static에 단순히 블록({ })을 사용한 경우에는 정적 초기화자라고 부르며, static 변수를 초기화하는 역할을 가지고 
클래스가 로딩될 때 main() 메서드가 있더라도 그보다 앞서 딱 한번 실행됩니다.



* 정적 변수(static field)

- static 변수는 모든 객체들이 공유하는 공유변수가 됩니다.
- 그리고 객체 생성 없이 클래스 이름만으로 참조가 가능합니다.
- 정적 변수는 객체를 만들어 참조할 수도 있지만, 객체를 만들지 않고 클래스 이름만으로도 참조가 가능하기 
	때문에 이를 "클래스 변수"라고도 부릅니다.



* 정적 메서드(static method)

- static 메서드는 static 변수와 마찬가지로 해당 클래스의 객체 생성 없이도 참조가 가능하게 해줍니다.
- static 메서드에서 멤버를 참조할 때 주의해야 할 사항은 "static 메서드 안에서는 non-static 멤버를 객체 생성 없이 직접 참조할 수  
	없다"는 것입니다.
- static 메서드 안에서는 static 변수를 선언할 수 없습니다.


* 정적 초기화자(static initializer)

- 정적 초기화자는 static 변수들의 초기화에 사용합니다. 
	일반 멤버변수는 생성자에서 초기화하지만 static 변수는 객체 생성 없이도 사 용해야하므로 생성자를 통해 초기화할 수 없습니다.
- 그래서 static 변수는 정적초기화자를 통해 초기화를 합니다.
- 정적 초기화자는 클래스가 로딩될 때 생성자와 main() 메서드에 앞서 오직 단 한번만  실행되기 때문에 애플리케이션 실행 중  
	반드시  한번만 실행되어야 할 로직이 있다면 이곳에 기술하여 사용할 수 있습니다.

package static_.init;

public class Computer {
	public static String company = "LG";
	public static String model = "gram";
	public static String info;
	public int price;
	
	public Computer() {
		System.out.println("생성자 호출!");
		this.price = 1000000;
		this.info = company + "-" + model;
		//스태틱변수를 사용할때는 생성자가 생성안될수있으니 생성자로 초기화를하면안된다.
	}
	//정적변수의 초기화를 위해서는 정적 초기화자를 이용해야한다.
	static { // 정적초기화자
		System.out.println("정적 초기화자 호출!");
		info = company + "-" + model;
		//price = 10; //스태틱변수만 사용가능
		//정적초기화자 생성시기: 클래스를 로딩시킬때 딱 한번 호출됨. 그후엔 호출할수없음
				//생성자와다르게 호출불가 생성자또한 생성시 1번호출되긴하지만 
				//그 한번일때 본인들끼리 호출을 할수있다.
		//클래스 로딩방법: 여러개가있지만 둘중 하나만 있어도 정적초기화자 작동됨
		//1.객체를 생성
		//2.클래스이름을 통해 정적멤버에 접근
	}
	
}


package static_.init;

public class MainClass {

	public static void main(String[] args) {
		Computer com = new Computer();
		System.out.println(com.info);
		//System.out.println(Computer.info);
		//스태틱변수를 사용할때는 생성자가 생성안될수있으니 생성자로 초기화를하면안된다.
		//정적변수의 초기화를 위해서는 정적 초기화자를 이용해야한다.
		//객체를 만드는순간 정적초기화자가 가장먼저 호출되고 그다음 생성자
		

	}

}



* 싱글톤 패턴(Singleton Pattern)

- 싱글톤 패턴은 어떤 클래스의 객체는 오직 하나임을 보장하며, 이 객체에 접근할 수 있는 전역적인 접촉점을 제공하는 패턴입니다.
- 클래스 객체를 유일하게 하나만 생성하여 모든 곳에서 하나의 객체에 접근하게 하여, 전역의 개념으로 객체를 사용할 수 있습니다.
- 싱글톤 패턴은 객체의 생성을 제한하기 위해 사용합니다.
	-DBA(databaseaccess)같은건 하나의 객체가 연결시키고관리하면되고 더이상 객체가 있을필요없으니 이럴때 사용


package static_.singleton;

public class Singleton {
	/*
	 -싱글톤 패턴 : 객체의 생성을 1개로 제한하기 위한 디자인 패턴
	 1.외부에서 이 클래스의 객체를 생성할수 없도록 생성자를 단 1개만 선언하고 private 제한을 붙임
	 */
	int a;
	
	private Singleton() {}
	
	/*
	 2.자신의 클래스 내부에서 스스로의 객체를 1개 생성
	 */
	
	private static Singleton instance = new Singleton();
	/*
	 3.외부에서 이 클래스의 객체 생성을 요구할 경우 2번에서 미리 만들어둔 단 하나의 객체를 공개된 메서드를
	  통해 제공함
	 */
	
	public static Singleton getInstance() {
		return instance;
	}
	
	/*
	4.static화 및 접근제한 
	 외부에서 만들어진 객체를 사용할수있도록 공개된 메서드를 통해 제공하지만 결국 객체가 안만들어지면
	 	못만든다. 그래서 static을 붙이면 객체를안만들고도 클래스의 메소드에 접근가능하고 그 메소드에는
	 	클래스에서 만들어놓은 단 하나의 객체를 참조하는 참조변수가 있으니 그것으로 객체를 사용할수있다.
	 	하지만 그 반환하는 객체또한 private static으로 해주어야한다.
	 	static내부에선 static으로만 직접적으로 사용할수있고 간접적으로 사용하려면 내부에 객체를
	 	만들어서 하는 방법도 있지만 getInstance라는 메소드의 기능적인측면에서 내부에 객체까지 생성
	 	한다는것은 부자연스러움으로 외부에 따로 생성한다.
	 	private는 함부러 instance에 접근하지 못하도록 하기위한 조치이다.
	 */
}


package static_.singleton;

public class MainClass {

	public static void main(String[] args) {
		//Singleton s = new Singleton();
		
		Singleton s1 = Singleton.getInstance();
		Singleton s2 = Singleton.getInstance();
		
		System.out.println(s1);
		System.out.println(s2);
		System.out.println(s1==s2);		
		
		s1.a = 45;
		Singleton.getInstance().a = 4;
		//Singleton.instance.a = 5; // 불가 
		
	}

}


######################################################################################################











######################################################################################################
예제20)정적초기화자 

1)아래의 소스코드에서 다른 로직을 추가하여 출력결과를 만들어라.

package static_.init;

public class Computer {
	public static String company = "LG";
	public static String model = "gram";
	public static String info;
	public int price;
	
	public Computer() {
		System.out.println("생성자 호출!");
		this.price = 1000000;
		//this.info = company + "-" + model;
		//스태틱변수를 사용할때는 생성자가 생성안될수있으니 생성자로 초기화를하면안된다.
	}

	
}


package static_.init;

public class MainClass {

	public static void main(String[] args) {
		Computer com = new Computer();
		System.out.println(com.info);
	
	}

}


<출력결과>
정적 초기화자 호출!
생성자 호출!
LG-gram


package static_.init;

public class Computer {
	public static String company = "LG";
	public static String model = "gram";
	public static String info;
	public int price;
	
	static {
		System.out.println("정적 초기화자 호출!");
		info = "LG-gram";
	}
	
	public Computer() {
		System.out.println("생성자 호출!");
		this.price = 1000000;
		//this.info = company + "-" + model;
		//스태틱변수를 사용할때는 생성자가 생성안될수있으니 생성자로 초기화를하면안된다.
	}

	
}


######################################################################################################


답:



package static_.init;

public class Computer {
	public static String company = "LG";
	public static String model = "gram";
	public static String info;
	public int price;
	
	public Computer() {
		System.out.println("생성자 호출!");
		this.price = 1000000;
		this.info = company + "-" + model;
		//스태틱변수를 사용할때는 생성자가 생성안될수있으니 생성자로 초기화를하면안된다.
	}
	//정적변수의 초기화를 위해서는 정적 초기화자를 이용해야한다.
	static { // 정적초기화자
		System.out.println("정적 초기화자 호출!");
		info = company + "-" + model;
		//price = 10; //스태틱변수만 사용가능
		//정적초기화자 생성시기: 클래스를 로딩시킬때 딱 한번 호출됨. 그후엔 호출할수없음
				//생성자와다르게 호출불가 생성자또한 생성시 1번호출되긴하지만 
				//그 한번일때 본인들끼리 호출을 할수있다.
		//클래스 로딩방법: 여러개가있지만 둘중 하나만 있어도 정적초기화자 작동됨
		//1.객체를 생성
		//2.클래스이름을 통해 정적멤버에 접근
	}
	
}


package static_.init;

public class MainClass {

	public static void main(String[] args) {
		Computer com = new Computer();
		System.out.println(com.info);
		//System.out.println(Computer.info);
		//스태틱변수를 사용할때는 생성자가 생성안될수있으니 생성자로 초기화를하면안된다.
		//정적변수의 초기화를 위해서는 정적 초기화자를 이용해야한다.
		//객체를 만드는순간 정적초기화자가 가장먼저 호출되고 그다음 생성자
		

	}

}











######################################################################################################
예제21)singleton싱글톤


1)아래의 출력결과가 나오도록 소스코드작성하라
	-단, 객체를 하나만 생성할수있는 싱글톤 기법으로 클래스설계하라.
	-객체를 만들면 해당 주소를 저장하는 참조변수의 명은 instance로 하고 외부에서 접근못하도록 하라.

package static_.singleton;

public class Singleton {

}



package static_.singleton;

public class MainClass {

	public static void main(String[] args) {
		//Singleton s = new Singleton();
		
		Singleton s1 = Singleton.getInstance();
		Singleton s2 = Singleton.getInstance();
		
		System.out.println(s1);
		System.out.println(s2);
		System.out.println(s1==s2);		
		
		s1.a = 45;
		Singleton.getInstance().a = 4;
		//Singleton.instance.a = 5; // 불가 
		
	}

}

<출력결과>
static_.singleton.Singleton@7852e922
static_.singleton.Singleton@7852e922
true




package static_.singleton;

public class MainClass {

	public static void main(String[] args) {
		//Singleton s = new Singleton();
		
		Singleton s1 = Singleton.getInstance();
		Singleton s2 = Singleton.getInstance();
		
		System.out.println(s1);
		System.out.println(s2);
		System.out.println(s1==s2);		
		
		s1.a = 45;
		System.out.println(s1.a);
		Singleton.getInstance().a = 4;
		//Singleton.instance.a = 5; // 불가 
		System.out.println(s1.a);
	}

}

######################################################################################################


답:





package static_.singleton;

public class Singleton {
	/*
	 -싱글톤 패턴 : 객체의 생성을 1개로 제한하기 위한 디자인 패턴
	 1.외부에서 이 클래스의 객체를 생성할수 없도록 생성자를 단 1개만 선언하고 private 제한을 붙임
	 */
	int a;
	
	private Singleton() {}
	
	/*
	 2.자신의 클래스 내부에서 스스로의 객체를 1개 생성
	 */
	
	private static Singleton instance = new Singleton();
	/*
	 3.외부에서 이 클래스의 객체 생성을 요구할 경우 2번에서 미리 만들어둔 단 하나의 객체를 공개된 메서드를
	  통해 제공함
	 */
	
	public static Singleton getInstance() {
		return instance;
	}
	
	/*
	4.static화 및 접근제한 
	 외부에서 만들어진 객체를 사용할수있도록 공개된 메서드를 통해 제공하지만 결국 객체가 안만들어지면
	 	못만든다. 그래서 static을 붙이면 객체를안만들고도 클래스의 메소드에 접근가능하고 그 메소드에는
	 	클래스에서 만들어놓은 단 하나의 객체를 참조하는 참조변수가 있으니 그것으로 객체를 사용할수있다.
	 	하지만 그 반환하는 객체또한 private static으로 해주어야한다.
	 	static내부에선 static으로만 직접적으로 사용할수있고 간접적으로 사용하려면 내부에 객체를
	 	만들어서 하는 방법도 있지만 getInstance라는 메소드의 기능적인측면에서 내부에 객체까지 생성
	 	한다는것은 부자연스러움으로 외부에 따로 생성한다.
	 	private는 함부러 instance에 접근하지 못하도록 하기위한 조치이다.
	 */
}







package static_.singleton;

public class MainClass {

	public static void main(String[] args) {
		//Singleton s = new Singleton();
		
		Singleton s1 = Singleton.getInstance();
		Singleton s2 = Singleton.getInstance();
		
		System.out.println(s1);
		System.out.println(s2);
		System.out.println(s1==s2);		
		
		s1.a = 45;
		Singleton.getInstance().a = 4;
		//Singleton.instance.a = 5; // 불가 
		
	}

}











######################################################################################################
개념정리_final, static final(상수)

* final

- final 키워드는 클래스, 메서드, 변수에 적용되며 abstract와 동시에 사용될 수 없습니다.
- final 클래스의 경우에는 상속이 안됩니다. 즉 서브클래스를 가질 수 없습니다.
- final 메서드는 재정의를 할 수 없습니다.
- final 변수는 값을 변경할 수 없습니다.


* final class

- 클래스 선언 시 final을 사용하면 그 클래스는 상속이 불가능해집니다.
- final 클래스는 자식 클래스를 가질 수 없고, 오직 외부에서 객체 생성을 통해서만 사용할 수 있습니다.
- final 클래스의 대표적인 예가 String 클래스입니다. 사용자가 임의로  String 클래스를 상속받아  메서드를  재정의하는  것을 방지하기 위한 것입니다.
- JAVA API DOCUMENT
--> https://docs.oracle.com/javase/8/docs/api

package final_.cls;

public final class Parent {

}
package final_.cls;

public class Child extends Parent{ //에러남 Parent에 final 이 붙었기 때문에 상속불가

}



* final 변수

- final 변수는 한번 값을 할당하면 그 값을 변경할 수 없습니다.
- final 변수는 선언시에 초기화하는 방법과 생성자를 통하여 초기화하는 방법이 있는데 만약 초기화하지 않고 남겨두면 컴파일 에러가 발생합니다.
	-private과 final의 차이 : 변경 공간	/ 공통점 : 값이 안정해져있는 상황에서 외부에서 생성자호출시에 초기화가능, 값변경 불가
		-private: 내부에서는 계속 변경가능	
			-private는 값이 정해져있어도 외부에서 생성자 호출시에 초기화가능
		-final : 내부에서도 한번 값이 정해지면 변경불가능

package final_field;

public class Person {
	public final String nation = "대한민국";
	public final String name;	//아래 생성자에 name값 초기화 안해주면 이거 에러남
		//final을 붙이면 값이한번 저장되면 변경할수 없는 변수로 만들어진다.
		//근데 이녀석은 값을 한번 저장을 안했으니 에러가 나는것
		//자동으로 null이 되긴 하지만.. 그건 final에선 값을 한번 넣은걸로 안치는 듯
	//그럼에도불구하고 이렇게 해야하는경우는 객체별로 이름을 따로 관리하고 싶은 경우 등의 상황일텐데
		//이런경우에는 한번넣겠다고 안심을 시켜주면됨 안심시키는 방법은 생성자를 이용

	/*
	 -final 변수는 한번 값이 대입되면 값을 변경할수 없는 특징이 있기때문에 선언시 직접초기화하거나
	  생성자를 통한 초기화 로직을 작성하여 데이터가 반드시 한번 저장될수 있게해야함
	  #요약
	   final 변수 사용할때 한번 값넣는 방법 2가지
	   	-선언과 동시에 초기화
	   	-선언후 생성자에서 초기화
	 */
	
//	public Person() {
//		this.name = "안녕";
//	}
	public Person(String name) {
//		this();
		this.name = name;	//위 주석이 풀리면 에러난다. 왜냐면 안녕이라고 값이 한번 들어갔기
					//때문이다.
//		this.name = "hi";	//에러
//		this.nation = "중국"; //에러
	}
	
	
}


* 상수(static final)

- 자바에서는 불변의 값을 저장하는 필드를 상수(constant)라고 부릅니다.
- 상수는  객체마다 저장할 필요가 없는 공용성을 가져야 하며, 여러가지 값으로 초기화될 수 없기때문에 static과 final 제한자를 동시   
  에 붙여 선언합니다.
- 상수 이름은 모두 대문자로 작성하는 것이 관례입니다. 카멜케이스 적용이 안되기때문에 연결된 단어라면 (_)로 단어들을 연결해줍니다.
						

#내생각
-final을 붙이고 선언과 동시에 초기화를했다면 이건 이미 상수화가 된것이다.
하지만 상수는 객체가 생성될때 만들어진다.
어떤 객체가 생성이되어도 항상 같은 값이라면 static으로 두어서 객체가 생성되기전에도 존재하도록 두는 것이 낫다.
그래서 final에 static까지 붙은듯 
 ex)final붙이고 선언과동시에 초기화하니 모든 객체에서 공용적으로 같은 값을지닌 변수를 사용할수있네?
   근데 어차피 똑같으면 객체생성전에 만들어서 혹시나 다른곳에서도 쓸수있는 클래스변수로 만들면 안될까?
	즉, 공용성을 객체뿐아닌 외부로까지 확대하면 안될까?
   static으로 만들자! 그렇게하면 객체 생성전에도 static final을 한후 선언과 동시에 초기화를 하면 가능하겠네.      
  이렇게되면 객체를 안만들어도 쓸수 있고 객체를 만들어도 쓸수있으니까 공용성이 확장되었네. 이전엔 공용성이 제한적이었으니까(객체생성유무)
   그럼 앞으로 final만 붙이고 선언과동시에 초기화한놈은 상수라고 부르지말자! 괜히 헷갈리니까!
	오케이 그럼 앞으로 상수는 static final을 붙인것만 상수다!


package final_.constant;

public class Earth {
	public static final double EARTH_RADIUS = 6400;
	public static final double EARTH_SURFACE_AREA;
	//굳이 상수를 생성과 동시에 초기화 안하겠다면 static 초기화자를 사용할수 있다.
	//하지만 정말 생성과 동시에 초기화를 안할 필요가 없다. 왜냐면 그냥 final일때는
	//생성자에서 초기화를할때 객체에 따라 final의 처음저장하는 값이 변경될수 있어서 
	//선언과 동시에 초기화를 안했다지만 지금 이건 static초기화자를 사용하든 선언과동시에 초기화를
	//하든 결과가 무조건 같다. 상수가 아닌 final이라면 결과가 달라질수있어서 사용하지만 이건의미없다.
	static {
		EARTH_SURFACE_AREA = 
				4 * EARTH_RADIUS * EARTH_RADIUS * Math.PI; 
	}
	
	public static void main(String[] args) {
		System.out.println("지구의 반지름 : " + Earth.EARTH_RADIUS + "km");
		System.out.println("지구의 표면적 : "+ Earth.EARTH_SURFACE_AREA + 
				"km^2");
	}
}

  

* final method

- final 메서드는 자식 클래스에서 부모 클래스의 메서드를 재정의하지 못하게 합니다.
- 하지만 클래스에 final이 붙지 않는다면 상속은 가능하므로 자식 클래스에서 final 메서드의 참조는 가능합니다.
		-final 메서드의 참조는 가능하다는 뜻은 부모의 메서드를 사용은 할수있되 재정의만 못할뿐이라는 뜻임 (아래예시)
- 자식 클래스에서 반드시 부모의 메서드를 기능의 변경없이 사용하도록 강요할 경우에 final 메서드를 선언합니다.
	-야 딴건 다~~ 괜찮은데 이 메서드만은 재정의하지마라 이미 완벽하다 더만지면 문제생긴다! 이런식의 뜻
- final 클래스는 자식클래스를 가질 수 없고, 오직 외부에 객체 생성을 통해서만 사용가능
- final 클래스의 대표적인 예가 String 클래스임. 사용자가 임의로 String 클래스를 상속받아 메서드를 재정의 하는 것을 방지하기 위한 것



package final_.method;

public class Parent {
	public void method1() {}
	public void method2() {}
	public final void method3() {}
	//메서드에 final붙으면 재정의 불가
}




package final_.method;

public class Child extends Parent{

	public void method1() {
		super.method1();
		System.out.println("hi재정의완료");
	}

	public void method2() {
		super.method2();
		System.out.println("hi재정의완료");
	}
	//public void method3() {}
	//Parent의 method3는 재정의불가
	
	
	public Child() {
		method1();
		method2();
		method3();
		//재정의가 불가한거지 상속받은 method3을 얼마든지 사용가능하다.
	}
}


#참고: 앞으로 api를 어떻게 사용하는지 미래의 방법을 알려주는거
- JAVA API DOCUMENT : 자바 api에 대한 사용법을 알려주는 문서사이트이다.
---> https://docs.oracle.com/javase/8/docs/api
	-구글에 java api 입력 해서 페이지 나오면 packages에 java.lang 클릭->String클릭
		string 실제 입력방법나옴 실제론 다르게입력해야하는데 new 치고 워낙많이쓰니까 스트링만 대입연산자로 허용을 해준거
	-그후 Math 패키지에서 random메서드를 찾아라

developer.naver.com : 기업들이 오픈소스로 제공하는 api를 받는방법

실력 : 적재적소에 이런 api를 가지고 집어넣어 개발하는 것

######################################################################################################







######################################################################################################
예제22)final field

1)파이널 변수를 생성후 
nation : 국적을 넣는 변수, 값은 대한민국, 선언과 동시에 초기화
name : 이름을 넣는 변수, 값은 객체에 따라 달라지도록 설계
	-단, 선언과 동시에 초기화하지말것
패키지명: final_.field
클래스명: Person
실행클래스명: MainClass




package final_.field;

public class MainClass {
	
	public static void main(String[] args) {

		
		Person kim = new Person("김한국");
		
//		kim.nation = "미국"; //에러
//		kim.name = "김마이클"; //에러
		kim.age = 17;
		kim.age = 27;
		System.out.println("국적: "+kim.nation);
		System.out.println("이름: "+kim.name);
		System.out.println("나이: "+kim.age);
		
		Person park = new Person("박중국");
		park.age = 30;
		System.out.println("국적: "+park.nation);
		System.out.println("이름: "+park.name);
		System.out.println("나이: "+park.age);
		
	}
}


<출력결과>

국적: 대한민국
이름: 김한국
나이: 27
국적: 대한민국
이름: 박중국
나이: 30



package final_.field;

public class Person {
	public final String nation = "대한민국";
	public final String name;
	public int age;
	 
	
	public Person(String name){
		this.name = name;
	}
	
	
	
}

######################################################################################################


답:

package final_.field;

public class Person {
	public int age;
	public final String nation = "대한민국";
	public final String name;	//아래 생성자에 name값 초기화 안해주면 이거 에러남
		//final을 붙이면 값이한번 저장되면 변경할수 없는 변수로 만들어진다.
		//근데 이녀석은 값을 한번 저장을 안했으니 에러가 나는것
		//자동으로 null이 되긴 하지만.. 그건 final에선 값을 한번 넣은걸로 안치는 듯
	//그럼에도불구하고 이렇게 해야하는경우는 객체별로 이름을 따로 관리하고 싶은 경우 등의 상황일텐데
		//이런경우에는 한번넣겠다고 안심을 시켜주면됨 안심시키는 방법은 생성자를 이용

	/*
	 -final 변수는 한번 값이 대입되면 값을 변경할수 없는 특징이 있기때문에 선언시 직접초기화하거나
	  생성자를 통한 초기화 로직을 작성하여 데이터가 반드시 한번 저장될수 있게해야함
	  #요약
	   final 변수 사용할때 한번 값넣는 방법 2가지
	   	-선언과 동시에 초기화
	   	-선언후 생성자에서 초기화
	 */
	
//	public Person() {
//		this.name = "안녕";
//	}
	public Person(String name) {
//		this();
		this.name = name;	//위 주석이 풀리면 에러난다. 왜냐면 안녕이라고 값이 한번 들어갔기
					//때문이다.
//		this.name = "hi";	//에러
//		this.nation = "중국"; //에러
	}
	
	
}



















######################################################################################################
예제23)final 클래스 & method

1)파이널 클래스
Parent 및 Child 만들고 
Parent를 final 클래스로 변경한후
Child클래스가 Parent 클래스를 상속받도록하여 에러가 발생함을 확인하라
내부정의필요없고 안된다는것을 확인하는것이 궁극적 목적
	-클래스는 완벽하다 바꾸지마라~ 라는 뜻

package final_.method;

public final class Parent {

}
package final_.method;

public class Child extends Parent {//에러
	
}


2)파이널 메서드
부모클래스명: Parent
자식클래스명: Child

Child
-부모클래스 3개다 재정의(불가능한게 있는지 확인)
-부모클래스의 재정의가 안되는것확인하고 그것이 사용은 되는지 또 확인
	-확인은 생성자만들어서하던가 다른 메소드 만들어서하던가~~ 알아서

package final_.method;

public class Parent {
	public void method1() {}
	public void method2() {}
	//final 메서드인 method3선언(구현부는 블록만두고 아무것도넣지말고 위의형식과같이한다.
}


package final_.method;

public class Parent {
	public final void method1() {
		System.out.println("hi");
	}
	public final void method2() {
		System.out.println("hihi!!");
	}
	public void method3() {
		System.out.println("bye");
	}
}

package final_.method;

public class Child extends Parent {
	
//	public final void method1() {
//		
//	}
//	public final void method2() {
//		
//	}
	public void method3() {
		
	}
}

######################################################################################################


답:




2)파이널 메서드

package final_.method;

public class Parent {
	public void method1() {}
	public void method2() {}
	public final void method3() {}
	//메서드에 final붙으면 재정의 불가
}


package final_.method;

public class Child extends Parent{

	public void method1() {
		super.method1();
		System.out.println("hi재정의완료");
	}

	public void method2() {
		super.method2();
		System.out.println("hi재정의완료");
	}
	//public void method3() {}
	//Parent의 method3는 재정의불가
	
	
	public Child() {
		method1();
		method2();
		method3();
		//재정의가 불가한거지 상속받은 method3을 얼마든지 사용가능하다.
	}
}
















######################################################################################################
예제24)final을 이용한 상수화 => static final

클래스명 Earth
심폴릭상수명(public) : EARTH_RADIUS, EARTH_SURFACE_AREA
	-상수는 무조건 대문자로 적어야함. 카멜케이스안되니 단어연결시엔 언더바이용
EARTH_RADIUS는 6400으로 선언과동시에 초기화하라, EARTH_SURFACE_AREA는 선언 후 다른방식을이용하여 초기화(자동초기화는 초기화로안침)
						값: 4 * EARTH_RADIUS * EARTH_RADIUS * Math.PI

Earth 클래스에 main함수 넣어라. 아래처럼.(MainClass만들기 귀찮으니까 이렇게한듯)  

	public static void main(String[] args) {
		System.out.println("지구의 반지름 : " + Earth.EARTH_RADIUS + "km");
		System.out.println("지구의 표면적 : "+ Earth.EARTH_SURFACE_AREA + 
				"km^2");
	}

<출력결과>
지구의 반지름 : 6400.0km
지구의 표면적 : 5.147185403641517E8km^2
######################################################################################################


답:




package final_.constant;

public class Earth {
	public static final double EARTH_RADIUS = 6400;
	public static final double EARTH_SURFACE_AREA;
	//굳이 상수를 생성과 동시에 초기화 안하겠다면 static 초기화자를 사용할수 있다.
	//하지만 정말 생성과 동시에 초기화를 안할 필요가 없다. 왜냐면 그냥 final일때는
	//생성자에서 초기화를할때 객체에 따라 final의 처음저장하는 값이 변경될수 있어서 
	//선언과 동시에 초기화를 안했다지만 지금 이건 static초기화자를 사용하든 선언과동시에 초기화를
	//하든 결과가 무조건 같다. 상수가 아닌 final이라면 결과가 달라질수있어서 사용하지만 이건의미없다.
	static {
		EARTH_SURFACE_AREA = 
				4 * EARTH_RADIUS * EARTH_RADIUS * Math.PI; 
	}
	
	public static void main(String[] args) {
		System.out.println("지구의 반지름 : " + Earth.EARTH_RADIUS + "km");
		System.out.println("지구의 표면적 : "+ Earth.EARTH_SURFACE_AREA + 
				"km^2");
	}
}
















######################################################################################################
개념정리_abstract

* abstract

- abstract 키워드는 클래스와 메서드에 적용됩니다.
- 추상(abstract) 클래스는 실체 클래스들의 멤버변수와 메서드들의 이름을 통일할 목적으로 사용합니다.
	- 반드시 상속을 받아서 사용하도록 한다.
- 추상(abstract) 메서드가 있는 클래스는 반드시 추상 클래스여야 합니다.
- 그러나 추상 클래스에 반드시 추상 메서드만 선언할 필요는 없고 일반 메서드도 선언할 수 있습니다.



* 추상 클래스

- 추상 클래스는 new 키워드를 이용해서 객체를 만들지 못하고 오직 상속을 통해서 자식 클래스로 구체화 시켜야 합니다.
- 추상 클래스도 일반 클래스와 마찬가지로 멤버변수, 생성자, 메서드를 선언할 수 있습니다.
- new를 사용하여 직접 생성자를 호출할 수는 없지만 자식 객체가 생성될 때 super()를 호출하여 
	추상 클래스 객체를 생성하므로 추상 클래스도 생성자가 반드시 있어야 합니다.

* 추상 메서드

- 추상 메서드는 추상 클래스 내에서만 선언할 수 있습니다.
- 추상 메서드는 메서드의 선언부만 있고 메서드 실행 내용이 들어가는 중괄호 {}가 없는 메서드를 말합니다.
	-메서드의 구현부분이 없다.
- 추상 클래스를 설계할 때 자식 클래스가 반드시 실행 내용을 채우도록 강요하고 싶은 메서드가 있을 경우, 해당 메서드를 추상 메서 드로 선언합니다.
	-cpp에서 순수가상함수랑 비슷한듯?
- 자식 클래스에서 반드시 부모 추상클래스의 추상 메서드를 재정의하여 실행 내용을 작성해야  합니다.  그렇지  않으면  컴파일  에러가 납니다.
-추상메서드를 하나라도 포함하는 클래스는 추상클래스가 되어야한다.
 그러나 추상클래스가 반드시 추상메서드를 가질 필요는 없다.
 

본사에서 과일주문이 들어왔을때 가격을 보여주는 프로그램을 틀을 짜서 줬다.
하지만 지사마다 가격이 다달라서 가격은 지사 개발팀에서 상속받아서 재정의를 해서 가격을 넣어주어야한다.

package abs.badcase;

public class HeadStore {
	public void orderApple() {
		System.out.println("0원입니다. 가게에서 가격을 정해주세요.");
	}
	public void orderBanana() {
		System.out.println("0원입니다. 가게에서 가격을 정해주세요.");
	}
	public void orderGrape() {
		System.out.println("0원입니다. 가게에서 가격을 정해주세요.");
	}
	public void orderMelon() {
		System.out.println("0원입니다. 가게에서 가격을 정해주세요.");
	}
	
}

package abs.badcase;

public class Store extends HeadStore{
	public void orderApple() {
		System.out.println("사과 쥬스의 가격은 3000원입니다.");
	}
	public void orderBanana() {
		System.out.println("바나나 쥬스의 가격은 2800원입니다.");
	}
	public void orderGrape() {
		System.out.println("포도 쥬스의 가격은 3200원입니다.");
	}
	/*
	public void orderMelon() {
		System.out.println("멜론 쥬스의 가격은 4000원입니다.");
	}
	*/
}

package abs.badcase;

public class MainClass {
	public static void main(String[] args) {
		Store s = new Store();
		s.orderApple();
		s.orderBanana();
		s.orderGrape();
		s.orderMelon();
		
	}
}

위처럼된이유 : 사장이 깜빡하고 메론의 정보를 입력안함

위처럼되면 main에서 실행했을때 melon의 가격은 0원으로 나온다.
그럼 손님은 가격확인용 포스기에서 0원으로 봤으니 메론을 받고 그냥 가려고한다.(가격만 볼수있는 포스기)
사장이 막는다. 왜 오천원안주세요? 손님: 포스기에 0원이라 뜨길래 주문을한거다. 행사인줄알았다. 행사아닌줄 알았으면 안시켰다 하고 감
사장이 본사에 연락함.
왜 이거 입력안되면 주문 프로그램자체가 에러나게 제한을 안걸어주냐?
그대로 나오면 사장들이 실수로 입력안하면 0원나올거아냐 .
그냥 안되게 하던가 ㅡㅡ 

본사: 하 .. 이렇게까진 안하려했는데 .. 그럼 하나라도 입력안하면 무조건 에러나게 해드릴게요.
	(추상클래스와 추상메서드를 통해 오버라이딩을 강제화시켜야겠다. 오버라이딩(가격재설정)안하면 에러나도록.)

package abs.goodcase;

public abstract class HeadStore {
	
	/*
	 1.메서드에 abstract를 붙이면 해당 메서드는 추상메서드가 되며 이 메서드는 상속을 통해 자식 클래스에서
	 반드시 오버라이딩을 해야함. 그렇지 않으면 에러가 발생함
	 2.추상메서드는 실체가 존재하지 않는 메서드의 틀 역할을 하기때문에 메서드의 바디부분 {}이 없고 세미클론
	 으로 선언을 마감함.
	 3.일반 클래스에서는 추상메서드를 선언할수 없음 추상메서드가 하나라도 존재하는
	 	클래스는 반드시 추상클래스가 되어야함
	 4.추상클래스 내부에서는 추상메서드만을 선언할 필요는 없습니다.
	 	일반메서드도 모두 선언할수 있습니다.
	 */
	public abstract void orederApple();
	public abstract void orederBanana();
	public abstract void orederGrape();
	public abstract void orederMelon();//가격 재정의 안하면 에러
	
	public void orderWaterMelon() {//가격 재정의 안해도 에러안남
		System.out.println("수박 쥬스의 가격은 4000원입니다.");
	}
	public final void orderPeach() {//가격재정의 불가
		System.out.println("복숭아의 가격은 2000원입니다.");
	}
}



######################################################################################################








######################################################################################################
개념정리_abstract


추상클래스 및 추상메서드 용도
1)재정의 누락 방지
	-강제오버라이딩하도록하여 오버라이딩 안하면 프로그램실행안되도록하여 초기값입력 실수를 방지하기위함
2)메서드 이름오타 방지
	-회사에서 클래스를 만들때 메서드 이름을 문서로 전달하면 오타우려가있는데 추상클래스를 만들고 거기에
	 추상 메서드들을 입력하여 추상클래스를 뿌린후 상속받아 사용하면 반드시 해당이름으로 오타없이(있더라도 에러가나니까 고친다) 
	 메서드 입력 가능


#제한자
-접근제한자
	-public, package friendly, private, protected
-사용제한자
	-abstract, final, static

#클래스에 적용가능한 제한자
-접근제한자
	-public, package friendly
-사용제한자
	-abstract, final

######################################################################################################

















######################################################################################################
예제25)클래스 및 메소드 추상화(강제오버라이딩)


아래의 코드는 지점주인이 본사에 항의하는 코드이다.
실수로 지점주인이 오버라이딩을 안했을시 실행자체가 안해달라는 요구가 있다.
1)강제 오버라이딩 하도록 소스코드를 수정하라.
2)본사클래스에서 WaterMelon이라는 메소드와 Peach라는 메소드를 추가한다.(가격은 자유롭게/수박쥬스,복숭아)
	단, WM은 지점주인의 마음에따라 물가를 바꿀수있도록하고 
	Peach는 지점주인이 가격을 바꾸고싶어도 절대못바꾸도록 하라


package abs.badcase;

public abstract class HeadStore {
	
	
	public abstract void orderApple();
	public abstract void orderBanana();
	public abstract void orderGrape();
	public abstract void orderMelon();
	public void orderWaterMelon() {
		System.out.println("니맘대로정하쇼 안쓸거면 안정해도되고");
	}
	public final void orderPeach() {
		System.out.println("미투");
	}
}

package abs.badcase;

public class Store extends HeadStore{
	public void orderApple() {
		System.out.println("사과 쥬스의 가격은 3000원입니다.");
	}
	public void orderBanana() {
		System.out.println("바나나 쥬스의 가격은 2800원입니다.");
	}
	public void orderGrape() {
		System.out.println("포도 쥬스의 가격은 3200원입니다.");
	}
	/*
	public void orderMelon() {
		System.out.println("멜론 쥬스의 가격은 4000원입니다.");
	}
	*/
}


package abs.badcase;

public class MainClass {
	public static void main(String[] args) {
		Store s = new Store();
		s.orderApple();
		s.orderBanana();
		s.orderGrape();
		s.orderMelon();
		
	}
}


#제한자
-접근제한자
	-public, package friendly, private, protected
-사용제한자
	-abstract, final, static

#클래스에 적용가능한 제한자
-접근제한자
	-public, package friendly
-사용제한자
	-abstract, final




package abs.badcase;

public abstract class HeadStore {
	
	
	public abstract void orderApple();
	public abstract void orderBanana();
	public abstract void orderGrape();
	public abstract void orderMelon();
	public void orderWaterMelon() {
		System.out.println("니맘대로정하쇼 안쓸거면 안정해도되고");
	}
	public void orderPeach() {
		System.out.println("미투");
	}
}



package abs.badcase;

public class Store extends HeadStore{
	public void orderApple() {
		System.out.println("사과 쥬스의 가격은 3000원입니다.");
	}
	public void orderBanana() {
		System.out.println("바나나 쥬스의 가격은 2800원입니다.");
	}
	public void orderGrape() {
		System.out.println("포도 쥬스의 가격은 3200원입니다.");
	}
	
	public void orderMelon() {
		System.out.println("멜론 쥬스의 가격은 4000원입니다.");
	}
	
	public void orderWaterMelon() {
		System.out.println("수박쥬스의 가격은 10000원입니다.");
	}
//	public void orderPeach() {
//		System.out.println("복숭아쥬스의 가격은 300원입니다.");
//	}
//	
}

######################################################################################################






답:






package abs.goodcase;

public abstract class HeadStore {
	HeadStore(){
		System.out.println("HEADStore생성자호출!");
	}
	/*
	 1.메서드에 abstract를 붙이면 해당 메서드는 추상메서드가 되며 이 메서드는 상속을 통해 자식 클래스에서
	 반드시 오버라이딩을 해야함. 그렇지 않으면 에러가 발생함
	 2.추상메서드는 실체가 존재하지 않는 메서드의 틀 역할을 하기때문에 메서드의 바디부분 {}이 없고 세미클론
	 으로 선언을 마감함.
	 3.일반 클래스에서는 추상메서드를 선언할수 없음 추상메서드가 하나라도 존재하는
	 	클래스는 반드시 추상클래스가 되어야함
	 4.추상클래스 내부에서는 추상메서드만을 선언할 필요는 없습니다.
	 	일반메서드도 모두 선언할수 있습니다.
	 */
	public abstract void orderApple();
	public abstract void orderBanana();
	public abstract void orderGrape();
	public abstract void orderMelon();//가격 재정의 안하면 에러
	
	public void orderWaterMelon() {//가격 재정의 안해도 에러안남
		System.out.println("수박 쥬스의 가격은 4000원입니다.");
	}
	public final void orderPeach() {//가격재정의 불가
		System.out.println("복숭아의 가격은 2000원입니다.");
	}
}



package abs.goodcase;

public class Store extends HeadStore{
//	
//	Store(){
//		super();	//자식클래스의 생성자는 항상 부모클래스의 생성자를 호출할수있다.
//					//통상적으로 마지막으로 호출되는 생성자에는 반드시 super()가 있다.
//					//그럼 추상클래스의 자식이라하더라도 부모의 생성자를호출한다.
//					//그럼으로 부모의 생성자를 부모클래스에서 설계해야한다.
//	}
//	
	public void orderApple() {
		System.out.println("사과 쥬스의 가격은 2800원입니다.");
	}
	public void orderBanana() {
		System.out.println("바나나 쥬스의 가격은 2800원입니다.");
	}
	public void orderGrape() {
		System.out.println("포도 쥬스의 가격은 2800원입니다.");
	}
	public void orderMelon() {
		System.out.println("멜론 쥬스의 가격은 2800원입니다.");
	}
	
	@Override
	public void orderWaterMelon() {
		// TODO Auto-generated method stub
		super.orderWaterMelon();
	}
//	public void orderPeach() { //에러남 final 메서드이기때문임
//		// TODO Auto-generated method stub
//		super.orderWaterMelon();
//	}
	

}





package abs.goodcase;

public class MainClass {
	public static void main(String[] args) {
		//HeadStore h = new HeadStore();//HeadStore타입으로 객체를 구체화불가하다
									//는 문구와 함꼐 에러남 -> 추상클래스이니까^^
		//추상클래스는 스스로 객체생성불가(꿈을 객체로 만들지못함)
		//반드시 상속을통해 클래스를 구체화시켜야함(설계가 안끝났는데 어떻게 객체를 만들겠냐~)
//		Store s = new Store();
		HeadStore s = new Store();
		s.orderApple();
		s.orderWaterMelon();
		s.orderPeach();
		//다형성기능 사용가능, 객체를 만드는것만 불가능하지 추상클래스로 다형성기능인 프로모션가능
		
	}
}

























