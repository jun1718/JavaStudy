예제모음
------------------------------------------------------------------------------------

======================================================================================================
*21.08.31_4회차(4강)
======================================================================================================












######################################################################################################
개념정리_논리연산자(eager, short circuit evaluation)

연산자마다 가능한연산이있음
예를들면 *라면 숫자형*숫자형 등은 가능하지만 *연산자의 피연산자로는 논리자료형을 지원하지 않는다.

#논리연산자의 피연산자에따른 역할변경
	-즉 논리연산자를 사용하려면 피연산자 모두 논리값이 와야한다.
정수 &(|) 정수: 비트연산
논리 &(|) 논리: 논리연산

#&논리곱
ture & true -> true
true & false -> false
false & true -> false
false & false -> false

#|논리합
ture | true -> true
true | false -> true
false | true -> true
false | false -> false


#논리곱에서 연산과정
	-short circuit evaluation(단락(축)평가): 좌항에서 결과가 판정나면 우항을 실행하지 않는다.
		(서킷 어바이유웨이션)
		-사용이유: 메모리를 절약하자
		-한개짜리 : 좌항에서 결과가 판정되도 우항을 실행한다.
	-eager evalution(열성적인평가, 이걸 어(굉장히작게)바이유웨이션)
	**** 참고
	파이썬(구글링https://yahwang.github.io/posts/55)
		-eager evalution : &/|
		-short circuit evalution : and/or
	java(구글링https://yahwang.github.io/posts/55)
		-eager evalution : &/|
		-short circuit evalution : &&/||
	c(구글링https://yahwang.github.io/posts/55)
		-eager evalution : 없음, 지원하지 않음
		-short circuit evalution : &&/||

		
1)& : FM, eager evaluation
	ex)논리값과 관계없이 ++b를 꼭해야하는경우

2)&&(short circuit) 
-좌항이 false면 우항을 실행하지않고 false.
-좌항이 true면 우항을 실행한다.

#논리합에서 연산과정
1)| : FM, eager evaluation


2)||(short circuit)
-좌항이 true면 우항을 실행하지않고 true
-좌항이 false면 우항을 실행하여 판별

######################################################################################################















######################################################################################################
예제1)논리연산자의 short circuit evaluation, eager evaluation 응용

1)현재 출력결과에서 두번째 y가 22가 아닌 21로 출력되도록 하라
2)b값을 2번의 출력 모두 20이 되도록 하라

<아래의 클래스에서  출력결과>
연산결과가 거짓입니다.
x: 10 y: 21
연산결과가 참입니다.
x: 10 y: 22
연산결과가 거짓입니다.
a: 10b: 21
연산결과가 참입니다.
a: 10b: 22


public class _1LogicalOperating {
	public static void main(String[] args) {
		int x = 10, y = 20;
		if ((x!=10) & (++y == 21)) {
			System.out.println("연산결과가 참입니다.");
		}
		else {
			System.out.println("연산결과가 거짓입니다.");
		}
		System.out.println("x: " + x + " y: " + y);
		
		if ((x==10)|(++y==21)) {
			System.out.println("연산결과가 참입니다.");
		}
		else {
			System.out.println("연산결과가 거짓입니다.");
		}
		System.out.println("x: " + x + " y: " + y);
		
		
		int a = 10; int b =20;
		if ((a!=10) & (++b == 21)) {
			System.out.println("연산결과가 참입니다.");
		}
		else {
			System.out.println("연산결과가 거짓입니다.");
		}
		System.out.println("a: " + a + "b: " +b);
		
		if ((a==10)|(++b==21)) {
			System.out.println("연산결과가 참입니다.");
		}
		else {
			System.out.println("연산결과가 거짓입니다.");
		}
		System.out.println("a: " + a + "b: " +b);
		
	}
}



######################################################################################################



답:



public class _1LogicalOperating {
	public static void main(String[] args) {
		int x = 10, y = 20;
		if ((x!=10) & (++y == 21)) {
			System.out.println("연산결과가 참입니다.");
		}
		else {
			System.out.println("연산결과가 거짓입니다.");
		}
		System.out.println("x: " + x + " y: " + y);
		
		if ((x==10)||(++y==21)) {
			System.out.println("연산결과가 참입니다.");
		}
		else {
			System.out.println("연산결과가 거짓입니다.");
		}
		System.out.println("x: " + x + " y: " + y);
		
		
		int a = 10; int b =20;
		if ((a!=10) && (++b == 21)) {
			System.out.println("연산결과가 참입니다.");
		}
		else {
			System.out.println("연산결과가 거짓입니다.");
		}
		System.out.println("a: " + a + "b: " +b);
		
		if ((a==10)||(++b==21)) {
			System.out.println("연산결과가 참입니다.");
		}
		else {
			System.out.println("연산결과가 거짓입니다.");
		}
		System.out.println("a: " + a + "b: " +b);
		
	}
}













######################################################################################################
개념정리_대입연산자

-대입연산자의 기본기호는 '='이고, 보다 발전된 대입 연산자는 x operand = a의 형태를 가지고 있으며 이는 x = x operand a와 같은
역할을 함
-대입연산자에는 =,+=,-=,*=,/=,%=,<<=,>>=,>>>=,&=,^=,|= 등이 있습니다.



public class _2AssignmentOperatorExample {
	public static void main(String[] args) {
		int a=5, b= 5;
		a+=3;  //a = a+3
		b=+ 3; //b = (+3)으로 인식되는거임
		System.out.println("a : "+a);
		System.out.println("b : "+b);
		
		a-= 4;
		System.out.println("============================");
		System.out.println("a : "+a);
		
		a *= 6;
		System.out.println("a : "+a);
		
		a/=5;
		System.out.println("a : "+a);
		
		a %=3;
		System.out.println("a : "+a);
	}
}

######################################################################################################















######################################################################################################
예제2)난수생성(정수,실수)

1)RandomExample 클래스를 만들어서 아래의 소스코드가 정상적으로 실행되도록 만들어라.


public class _3RandomExample {
	public static void main(String[] args) {

		//실수난수생성하기 0이상 1.0미만
		System.out.println("랜덤값: " + r);
	
		System.out.println("*** 신년 여행지 선정 ! ***");
		if () { 
			System.out.println("모로코로 갑시다!!!");
		}
		else if() {
			System.out.println("상하이로 갑시다!!!");
		}
		else{
			System.out.println("집에서 놉시다!!!");
		}
		
		//정수 난수 생성하기 0~9

		System.out.println("=============================");
		System.out.println("정수 난수값: " + );
		
		System.out.println("*** 신년 여행지 선정 ! ***");
		if () { 
			System.out.println("모로코로 갑시다!!!");
		}
		else if() { 
			System.out.println("상하이로 갑시다!!!");
		}
		else{
			System.out.println("집에서 놉시다!!!");
		}
	}
}

######################################################################################################






답:



public class _3RandomExample {
	public static void main(String[] args) {
		//난수(랜덤값)을 발생시키는 메서드 random()
		//0.0이상 1.0미만의 랜덤 실수값을 가져옴 c에서 rand()는 0~65535개였나? 그랬던듯
		double r = Math.random();
		System.out.println("랜덤값: " + r);
		
		System.out.println("*** 신년 여행지 선정 ! ***");
		if (r >0.66) { //0.67~0.99 33개 이상
			System.out.println("모로코로 갑시다!!!");
		}
		else if(r > 0.33) {//0.34~0.66 33개 
			System.out.println("상하이로 갑시다!!!");
		}
		else{//0~0.32 33개
			System.out.println("집에서 놉시다!!!");
		}
		
		//정수 난수 생성하기 0~9
		int rn = (int)(r*10);
		System.out.println("=============================");
		System.out.println("정수 난수값: " + rn);
		
		System.out.println("*** 신년 여행지 선정 ! ***");
		if (rn >0.66) { //0.67~0.99 33개 이상
			System.out.println("모로코로 갑시다!!!");
		}
		else if(rn > 0.33) {//0.34~0.66 33개 
			System.out.println("상하이로 갑시다!!!");
		}
		else{//0~0.32 33개
			System.out.println("집에서 놉시다!!!");
		}
	}
}




public class _4ConditionalOperatorExample {

	public static void main(String[] args) {
		//-4~5까지의 정수 난수값 발생
		int r = (int)(Math.random()*10-4);
		
		System.out.println("-4~5까지의 정수난수값 : " + r);
		
		
	}
	
	
	
}














######################################################################################################
예제3)조건연산자+난수생성

1)-4~5까지의 정수 난수값 발생후 출력
2)위의 난수값들을 모두 절대값으로 변경(음수가 없도록 하라는 뜻)하여 abs라는 정수형 공간에 저장한 후 출력
	-조건: 조건연산자(conditional operator를 사용할것)
3)조건연산자를 이용해서 조건에따라 성공과 실패를 저장하는 String 객체를 만들어라
	-무조건 성공만하게 만들어보시오


#조건연산자 : if와 같은데 아주 간단한 로직을 만들때 사용함(예를들어 c에서 매크로함수? 였던듯)
(조건식 ? 연산식1 : 연삭식2) : 조건이 참이면 1식 거짓이면 2식을 실행함

######################################################################################################


답:


public class _4ConditionalOperatorExample {

	public static void main(String[] args) {
		//-4~5까지의 정수 난수값 발생
		int r = (int)(Math.random()*10-4);
		
		System.out.println("-4~5까지의 정수난수값 : " + r);
		
		//3항조건연산자
		int abs = (r >=0) ? r : -r;
		System.out.println(abs);
		String s = (abs>=0) ? "성공" : "실패";
		
		System.out.println(s);
	}
	
	
	
}



######################################################################################################
개념정리_연산자 우선순위 및 종류

연산자우선순위

1.단항연산자
(), [], .(참조연산자)
++--(증감), +-(부호), !(논리반전), ~(비트반전), (type)

2.이항연산자
*/%(산술연산자)
+-

<< >> >>>(비트이동연산자)	>>>:부호포함 우측이동

< <= > >=(비교연산자)
== !=
instanceof(비교연산자:객체형비교)

&, | ^(비트연산자,논리연산자)
&&, || (논리연산자)

3.삼항연산자
? : (조건부연산자conditional operator)

4.이항연산자(대입연산자)
연산후 대입연산자, 대입연산자
 =,+=,-=,*=,/=,%=,<<=,>>=,>>>=,&=,^=,|=


연산자종류	 연산자			피연산자 수

증감 연산	++, --			단항
비교 연산	==, !=, <, 		이항
	>, <=, >=, 
	instanceof	
비트 연산  ~, &, |, 		이항
	^, <<, >>,
	>>>	
논리 연산	!, &, |,		이항 단항 
	&&, ||	

조건부 연산 ? : 			삼항
대입 연산	=, +=, -=, *=, 		이항
	/=, %= &=, ^=, 
	|=, <<=, >>=, 
	>>>=	
######################################################################################################











######################################################################################################
개념정리_표준입출력

* 자바 표준 입/출력(IO: Input/Output)

- IO란 입력과 출력을 뜻합니다.

- Input:
1. 파일의 데이터를 읽는다. (loading)
1. 키보드의 입력데이터를 읽는다.
1. 네트워크상의 데이터를 읽는다.

- Output
1. 파일에 데이터를 쓴다.(save)
1. 모니터에 데이터를 쓴다.(모니터에 데이터를 출력한다.)
1. 네트워크상에 데이터를 쓴다.(파일 전송)

- C언어에서는 문자열을 출력할 때 printf() 함수를 이용하고, 입력받을 때 scanf() 함수를 이용합니다.

- 자바에서 데이터를 출력하는 명령은 System.out이고, 데이터를 입력받을 때는 System.in을 이용합니다.

- 데이터를 입력받을 때는 표준 JAVA  API인 Scanner클래스를 사용하며, 이 Scanner 클래스는 다양한 타입의 입력 값들을 읽어들이기  
	위한 메서드들을 제공합니다.




######################################################################################################











######################################################################################################
개념정리_자바 표준 API의 class인 Scanner 사용법

0.Scanner가 들어있는 API(import) 불러오기

1. 스캐너 객체 생성
ex) Scanner scan = new Scanner(System.in);

2. 입력 받을 데이터 타입에 따른 메서드 호출.

ex) scan.next(), scan.nextLine(), scan.nextInt(), scan.nextDouble() 등

- next(): 공백을 포함하지 않는 문자열을 입력 받을 때
- nextLine(): 공백을 포함한 문자열을 입력 받을 때
- nextInt(): 정수를 입력 받을 때
- nextDouble(): 실수를 입력 받을 때
문자입력은????? 

3. 스캐너 객체 종료. ex) scan.close();


######################################################################################################















######################################################################################################
예제4)표준입력함수 사용(ScannerExample)

1)아래 출력결과처럼 이루어지도록 구현하시오.

<출력결과>
이름을 입력하세요.
> 이순신
나이를 입력하세요.
> 26
------------------
이름 : 이순신
나이 : 26

######################################################################################################


답:

import java.util.Scanner;

public class ScannerExample {
	public static void main(String[] args) {
		//1.스캐너 객체 생성
		Scanner scan = new Scanner(System.in);
		//2.스캐너 클래스가 가지고 있는 입력메서드들을 사용하여 데이터를 입력받음
		
		
		System.out.println("이름을 입력하세요.");
		System.out.print("> ");	//println하면 안됨
		String name = scan.next();
		
		System.out.println("나이를 입력하세요.");
		System.out.print("> ");
		int age = scan.nextInt();
		
		
		
		System.out.println("------------------------------");
		System.out.println("이름 : " + name);
		System.out.println("나이 : " + age);
		
		
		scan.close();
	
	}
}















######################################################################################################
개념정리_배열(Arrays)

-평균낼때 매번학생수 체크해야함, 변수이름이 너무많아짐 그래서 나옴


* 배열(Array)

- 배열은 같은 데이터 유형 변수를 여러 개 선언해야 하는 불편함을 줄이기 위해 사용합니다.

- 자바에서는 배열도 일종의 데이터 타입으로 취급할 수 있기 때문에 배열을 정의하는 대괄호"[]"가  배열 변수명 앞에 오는  것이  가능 합니다.


-배열(Array)이란 선형 자료구조(Data Structure)중 하나로, 동일한 타입의 연관된 데이터를 메모리에 연속적으로 저장하여 
하나의 변수에 묶어서 관리하기 위한 자료 구조입니다.  가장 기본적인 자료구조인 만큼 C,Java,Python등 거의 모든 언어에 구현되어 있습니다.
 배열의 길이는 최초 선언한 값으로 고정되며 위와 같이 인덱스(Index)를 통해 데이터에 접근 할 수 있습니다

		출처: https://ifuwanna.tistory.com/231 [IfUwanna IT]

#배열 "변수"선언: <데이터 타입><배열 이름[]> or <데이터 타입[]><배열 이름> 배열 생성: <배열 이름> = new <데이터 타입[배열의 크기]>
	-배열을 선언만한경우 힙영역에 생성은안되고 배열명의 공간에는 nll값이들어온다
	-c와다르게 []연산자안에 상수값을 안넣어도 컴파일시 문제가 없다.(차후 동적할당된 공간의 주소를받는 포인터형변수로 만들어지나봄?)
	-ex) int nabi[]; -> 자료형 : int(정수) 기본자료형(타입) 
	     int[] nabi; -> 자료형 : int(정수) 배열자료형(타입)	=>자바에선 이방식을 선호함


- 자바의 배열은 선언시에는 크기를 명시할 수 없으며, 생성시에 크기를 명시한다.

- 배열은 기본데이터 타입이나 객체참조 데이터 타입 또는 다른 배열의 순차적인 집합체라고 할 수 있습니다.

- 하나의 배열에 여러가지 데이터형을 혼합해서 사용할 수 없습니다. 이런 배열의 특징을 동종모음(Homogeneous collection)이라고   합니다.

- 배열은 선언, 생성, 초기화의 과정을 통하여 만들어집니다.

#배열의 생성 : 동적할당
	-ex) int[] nabi;
	     nabi = new int[5];
	-주소값: 한바이트당 하나의 주소를가지고있음
		-ex)int는 주소값을 4개가지고 있는거임 4byte니까
	-대표주소만알면된다.

- 선언 시에는 배열에 들어갈 데이터 타입을 결정하고, 생성 시 만들 배열의 크기를 결정합니다. 
	그리고 초기화 과정을 통하여 배열에 들어갈 값을 입력해 줍니다.

- 배열의 길이란 배열에 저장할 수 있는 전체 항목 수를 말하는데 코드에서 배열의 길이를 얻으려면 '배열변수이름.length'라는 코드를 사용합니다.


#배열의 초기화: 각 인덱스에 값을 처음넣는 행위
	-배열은 생성시 최초에 각 자료형에 대한 기본값으로 초기화가 되지만 그것을 배열의 초기화라고 부르지 않고 그 후 직접 유효값을넣을때
		배열의 초기화라 하나보다?

#배열특징 
1)reference Type(기본타입이아니다 참조타입이다)
2)homogeneous(호모지니어스) collection : 동종모음구조 : 같은 종류의 데이터만 모아지는 것
		-int형 배열을 만들면 double형 데이터는 해당 배열타입에 들어갈수 없다.
3)immutable : 크기 변경불가능(배열의 길이)
	-해결책: 리스트, 셋 등으로 배열을 강화시킬수있다고한다.

*****참고	(멤버변수 및 지역변수 초기화에 대하여)
#암시적 초기화방법: 클래스에서 멤버변수를 선언과 동시에 초기화하지 않은경우 자동으로 데이터의 형태가 가지는 기본값으로 초기화를 진행한다.
	-이때 초기화는 멤버변수에서만되고 지역변수에대해서는 기본값으로 초기화되지않는다. 그럼으로 반드시 초기화하여야한다.
	-각 데이터타입의 기본값(default value), 배열 생성시 배열의 타입별 초기값
		int[] a; 배열변수->a, 배열변수형->int 힙영역에 생성되는 int배열변수형 공간에서 각 세부공간은 int이고 그공간에
			배열변수형이 저장됨
	      배열변수형   초기값
		byte : 0
		short : 0
		int : 0
		long : 0L
		float : 0.0F
		double : 0.0
		char : " "(유니코드의 공백문자) : '\u0000'
		boolean : false
		string : null
		참조변수(주소가들어가는 모든 변수) : null
	*java 자료형의 대분류 : 기본자료형(primitive type), 참조자료형(참조타입,reference type)
		기본자료형 : 정수타입(byte,char,short,int,long), 실수타입(float, double), 논리타입(boolean)
			-메모리에서 할당된 공간의 값으로 실제 값을 저장
		참조자료형 : 배열타입, 열거타입, 클래스, 인터페이스
			-메모리에서 할당된 공간의 값으로 메모리(할당된 특정공간)의 주소값을 저장하는 것
		*자료형은 메모리에 공간을 할당받았을때 그모양이 무엇이냐 물을때 그 종류라고 보면될듯? 특정 데이터를 저장할수 있는공간의
											이름 
#new : 힙영역에 새로운 객체를 만들때 사용하는 연산자로 객체 생성연산자라한다
String s = "a";	//힙영역에 동적할당된 객체공간의 멤버변수공간에 값 문자 배열이 만들어진후 a값과 널값이 들어가고 해당 객체공간의
		주소를 s에 넣는다. 즉 s는 참조변수라는 것이다.

s = null; //특히하게도 자바에서는 힙영역의 특정객체에 대한 참조변수가 없으면 garbage collector로 공간할당을 자동해제한다.
		garbage collector : 사용되지 않는 메모리를 다시 사용할 수 있도록 하는 것 -> jvm이 할당된 모든
					메모리를 가지고 있고 이를 관리한다는 뜻임

변수의 초기화
변수를 선언하고 처음으로 값을 저장하는 것을 '변수의 초기화'라고 한다.

멤버변수는 초기화를 하지 않아도 자동적으로 변수의 자료형에 맞는 기본값으로 초기화가 이루어지므로 
초기화하지 않고 사용해도 되지만 지역 변수는 사용하기 전에 반드시 초기화를 해야한다.


class InitTest {
  int x;
  int y = x; //문제 없음

  void method() {
    int i;
    int j = i; // 컴파일 에러: 지역변수를 초기화하지 않고 사용함
  }
}

멤버 변수의 초기화 방법
명시적 초기화(explicit initialization) : 선언과 동시에 초기화하는 방법임
생성자(constructor)
초기화 블럭(initialization block)
인스턴스 초기화 블럭 : 인스턴스 변수를 초기화 하는데 사용
클래스 초기화 블럭 : 클래스 변수를 초기화하는데 사용




배열변수의 데이터 타입은 int배열타입이고 배열변수가 참조하는 배열의 타입은 int이다.(아무리 구글링해도 잘 모르겠음)


######################################################################################################





















######################################################################################################
예제5)배열(객체)의 자료형, 배열변수의 자료형(배열타입)

1)int배열타입 변수인 score를 만들고 응용하라

1-1)배열의 선언
1-2)배열의 생성
1-3)배열의 초기화
1-4)배열의 값참조(사용)
1-5)배열의 내부 값을 문자열 형태로 출력
1-6)배열의 길이 출력
1-7)배열의 선언과 생성을 동시에하는 byte배열타입 변수 bArr(참조변수)를 만들고(배열의 선언) 내부문자열형태로출력,길이출력
1-8)int배열타입 배열변수를 선언, 배열 생성, 배열 초기화 동시에 한후 문자열형태 및 길이 출력 
1-9)배열의 초기값설정하지않고 초기값이 기본값으로 자동초기화된것을 확인
1-10)char배열타입 배열변수를 선언, 배열 생성, 배열 초기화 동시에 한후 문자열형태 및 길이 출력 
1-11)String배열타입 배열변수를 선언, 배열 생성, 배열 초기화 동시에 한후 문자열형태 및 길이 출력 





######################################################################################################


답:


import java.util.Arrays;
import java.util.Scanner;

public class _1 {
	public static void main(String[] args) {
		
		int[] score;
		score = new int[5];
		for (int i=0, b=1;i<4;i++,b++) {
			score[i] = b;
		}
		System.out.println(Arrays.toString(score));
		System.out.println(score[0]);
		System.out.println(score.length);
		
		byte[] bArr = new byte[5];
		System.out.println(Arrays.toString(bArr));
		System.out.println(bArr.length);
		
		int[] arr = new int[] {10, 39, 29, 43, 56};
		System.out.println(Arrays.toString(arr));
		System.out.println(arr.length);
		
		char[] ch = new char[] {'남', 'B', 65, '자'};
		System.out.println(Arrays.toString(ch));
		System.out.println(ch.length);
		
		String[] str = new String[] {"ㄴ어래ㅑㄷ저ㅐㅑ렂대ㅑㄹ", "hi", " "};
		System.out.println(Arrays.toString(str));
		System.out.println(str.length);
		System.out.println(str.length);
	}
}



강의내용이면서 읽기힘든 답:

import java.util.Arrays;

public class _6ArrayBasic {
	public static void main(String[] args) {
		//1.배열의 선언 -stack에 배열의 참조변수를 설정
//		int score[50];//자바에서는 선언시 크기명시 불가
//		int score[];	//c style
		int[] score;    //java style
				//현재는 힙에 할당안됨 score에는 null 값이 들어가있음
//		System.out.println(score); //에러
		
		
		
		//2.배열의 생성 -heap에 실제 데이터가 저장될 공간을 생성
		//배열은 생성시 크기를 명시함. 한번 설정한 크기는 변경불가
		score = new int[5];
		System.out.println(score);
		System.out.println(score[0]);	//기본값으로 초기화됨
		
		//3.배열의 초기화 - 배열에 값을 저장하는 과정
		score[0] = 87;
		System.out.println(score[0]);	//배열의 초기화
			
		score[2] = 99;
		score[3] = score[0];
		
		
		//4.배열의 값 참조(사용)
		System.out.println("배열의 3번째 데이터값 : " + score[2]);
		System.out.println("배열의 4번째 데이터값 : " + score[3]);
		
		/*
		 * 배열 내부에 저장된 값들을 한눈에 문자열 형태로 확인해보려면 출력메서드 
		 * println의 매개값으로 Arrays.toString(배열변수명)을 쓰면 됨
		 */
		System.out.println(Arrays.toString(score));
		
		
		//배열의 길이를 알아보려면 배열변수명.length 명령을 사용
		System.out.println("배열의 길이: " + score.length);
		
		//배열의 선언과 생성을 동시에 하는방법
		byte[] bArr = new byte[7];
		System.out.println(Arrays.toString(bArr));
		
		//배열의  선언과 생성과 초기화를 동시하는 방법
		char[] letters = new char[] {'가', '나', '다', '라'};
		System.out.println(Arrays.toString(letters));
		System.out.println("배열의 길이: " + letters.length);
		
//		String[] names = new String[] {"홍길동", "심사임당", "강감찬"};
		String[] names = {"홍길동", "심사임당", "강감찬"}; // 선언-생성-초기화를 동시에
											//하는경우에는 new 배열타입[] 생략가능
		System.out.println(names);
		System.out.println(Arrays.toString(names));
		System.out.println("배열의 길이: " + names.length);
		
		//배열의 초기값을 설정하지 않으면 각 데이터 타입의 기본값으로 자동초기화됨
		
		
	}
}




























======================================================================================================
*21.09.01_5회차(5강)
======================================================================================================


























































######################################################################################################
개념정리_제어문

* 제어문

- 제어문의 종류는 조건문, 반복문, 탈출문이 있습니다.
- 조건문은 특정 조건을 만족할 때 실행할 문장을 작성하는데 사용합니다.
- 반복문은 여러 번 반복 실행할 코드가 있다면 반복문을 작성합니다.
- 반복문이 실행되는 동안 실행을 중지시키고 싶으면 탈출문을 사용합니다.


* 조건문 if ~ else

- if문은 프로그램의 흐름을 바꾸는데 사용되는 조건 선택 분기문입니다.
- if문의 조건식 결과는 반드시 boolean형이어야 되며, 조건식이 참이면 if문 블록안의 실행문이 실행되고, 거짓이면 else문 블록안의 실행문이 실행됩니다.
- if문장은 else문장 없이 사용할 수 있습니다. 그러나 else문장은 if문장 없이 단독으로 사용할 수 없습니다.
- 조건식의 결과가 거짓일 때 실행할 문장이 없다면, else문 이하를 생략해도 됩니다.


* 다중 분기 조건문 if ~ else if ~ else

- 여러 조건들을 설정할 때 사용하는 조건문입니다.
- 다중 분기 조건문은 위에서부터 차례로 조건을 검색합니다.


public class _1IfExample1 {
	public static void main(String[] args) {
		//0~100까지의 정수형 난수 발생
		int point = (int)(Math.random()*101);
		System.out.println("점수: "+point);
		
		if(point>=60) {
			System.out.println("60점 이상입니다.");
			System.out.println("시험에 합격했습니다.");
		} else {
			System.out.println("60점 미만입니다.");
			System.out.println("시험에 불합격했습니다.");			
		}//end else
		System.out.println("수고하셨습니다!");
	}//end main
}//end class



import java.util.Scanner;

public class _1IfExample2 {
	public static void main(String[] args) {
		Scanner scan = new Scanner(System.in);
		
		System.out.println("점수를 입력하세요.");
		System.out.print("> ");
		int point = scan.nextInt();
		
		if(point >= 90) {
			if(point > 100) {
				System.out.println("점수를 잘못 입력했습니다.");
			} else if(point >= 95) {
				System.out.println("당신의 학점은 A+입니다.");
			} else {
				System.out.println("당신의 학점은 A입니다.");				
			}
		} else if(point >= 80) {			
			System.out.println("당신의 학점은 B입니다.");
		} else if(point >= 70) {
			System.out.println("당신의 학점은 C입니다.");
		} else if(point >= 60) {
			System.out.println("당신의 학점은 D입니다.");			
		} else {
			System.out.println("당신의 학점은 F입니다.");			
			System.out.println("당신은 재수강!");			
		}
	}//end main
}//end class


######################################################################################################

































######################################################################################################
예제6) if 


* 1. 양의 정수를 입력받아서 그 수가 홀수라면
*    "x는 홀수입니다.", 짝수라면 "x는 짝수입니다."가
*    출력되도록 조건문을 활용하여 코드를 만들어보세요.
*    힌트) 짝수는 2로 나누면 나머지가 0이다.
* 2. 만약 사용자가 0을 입력하면 "0입니다." 하고 종료되도록, 음수를
*    입력하면 "음의 정수입니다."를 출력하고 종료되도록 조건문을
*    수정해보세요.   
*/		


######################################################################################################


답:


import java.util.Scanner;

public class _2IfQuiz {
	public static void main(String[] args) {
		Scanner scan = new Scanner(System.in);
		System.out.print("양의 정수 입력 : ");
		int num = scan.nextInt();
		
		if(num == 0) {
			System.out.println("0입니다");
			return;
		} else if(num < 0) {
			System.out.println("음의 정수입니다.");
			return;			
		}
		
		if(num % 2 == 0) {
			System.out.println("x는 짝수입니다.");
		} else {
			System.out.println("x는 홀수입니다.");			
		}
		
	}//end main
}//end class






















######################################################################################################
개념정리_switch ~ case



* 조건문 switch ~ case

- 복합 if문은 구현하기 복잡하고 프로그램의 효율성이 감소되는 단점이 있기 때문에, 다중 분기 문제를 해결할 때는 switch문을 사용합 니다.

- switch문은 다중 분기 구조이므로 복합 if문의 논리적인 구조를 간결하게 표현할 수 있습니다.

- if문과는 달리 조건식이 사용되지 않고, 값을 가지는 변수 또는 표현식이 판단조건으로 사용되며, 연산 결과의 데이터 타입은 int, String, Enum(열거형)이 사용됩니다.

- case문 뒤에 사용되는 값은 변수를 사용할 수 없고, 반드시 상수를 사용해야 합니다.

- switch ~ case문에서 default는 if~else에서 else와 비슷한 효과를 가집니다.

switch (변수) // 변수 : char int string, enum
{
case 변수값(상수):
	해당 case의 실행코드
case 상수2:
	해당 case의 실행코드
default:
	해당 case의 실행코드
}	


######################################################################################################






























######################################################################################################
예제7) switch ~ case


1)case 변수를 정수타입으로 두기
	아래 방식으로 swtich ~ case를 만들어서 효율성을 if보다 좋게하라

90점이상 100점이하 A 출력
	100점초과시 점수잘못입력함을 출력
80점이상 B 출력
70점이상 C 출력
60점이상 D 출력
50점이상 D 출력

2)case변수 문자열타입으로 두기
	아래처럼 출력되게 해봐라

배열이름 : foods
	배열변수 자료형 : String배열타입

정수난수 0~4를 만든뒤 해당 난수를 이용해서 switch에 접목하라(switch변수의 자료형은 Styring이다.)

비빔밥, 사시미, 북경요리, 카레, 똠양꼼
한식	일식	중식  기타해외요리입니다.


######################################################################################################




답:




1)case 변수를 정수타입으로 두기
	아래 방식으로 swtich ~ case를 만들어서 효율성을 if보다 좋게하라

import java.util.Scanner;

public class _3SwitchExample1 {
	public static void main(String[] args) {
		Scanner scan = new Scanner(System.in);
		System.out.print("점수 : ");
		int point = scan.nextInt();
		
		/*
		 * switch 키워드 뒤에 나오는 변수나 연산식은 결과값이 반드시 문자나 정수타입이어야함
		 */
		switch(point/10){
 			//case 뒤에는 반드시 상수를 적어야함
		case 10:
		case 9:	//90~99
			if (point > 100) {
				System.out.println("점수잘못입력함.");
			} else {
				System.out.println("당신의 학점은 A입니다.");	
			}
			break;
		case 8:	
			System.out.println("당신의 학점은 B입니다.");
			break;
		case 7:
			System.out.println("당신의 학점은 C입니다.");
			break;
		case 6: //50 ~ 69 D
		case 5:
			System.out.println("당신의 학점은 D입니다.");
			break;
		default:
			System.out.println("당신의 학점은 F입니다.");
		}
		
		
		scan.close();
	}

}





2)case변수 문자열타입으로 두기
	아래처럼 출력되게 해봐라

public class _3SwitchExample2 {
	public static void main(String[] args) {
		String[] foods = {"비빔밥", "사시미", "북경오리", "카레", "똠양꼼"};
		//index(0~4) 범위 난수 발생
		int idx = (int)(Math.random() * 5);
		System.out.println("선택된 음식 : " + foods[idx]);
		
		switch(foods[idx]) { //문자나 정수만가능 foods는 String배열타입, idx를하니 char
								//문자타입 그래서 가능
		case "비빔밥":
			System.out.println("한식입니다.");
			break;
		case "사시미":
			System.out.println("일식입니다.");
			break;
		case "북경오리":
			System.out.println("중식입니다.");
			break;
		default:
			System.out.println("기타 해외요리입니다.");
		}
	}//end main
}//end class





























######################################################################################################
예제8) switch ~ case 출력결과만으로 유추하여 실행하기(심화)

<출력결과>
직급을 입력하세요.
[사원,대리,과장,차장,부장]
> 사워
사워은(는) 없는 직급입니다.
직급을 다시 입력해주세요.


직급을 입력하세요.
[사원,대리,과장,차장,부장]
> 대리
대리의 급여는 300만원입니다.
		//이런식으로 각 월급을 알려줘라 월급은 맘대로 설정





######################################################################################################




답:


import java.util.Arrays;
import java.util.Scanner;

public class _4SwitchQuiz {
	public static void main(String[] args) {
		
		System.out.println("직급을 입력하세요.");
		System.out.println("[사원, 대리, 과장, 차장, 부장]");
		System.out.print("> ");
		
		Scanner scan = new Scanner(System.in);
		String position = scan.next();
		
		switch(name){
		case "사원":
			System.out.println(position+"의 직급은 100만원입니다.");
			break;
		case "대리":
			System.out.println(position+"의 직급은 200만원입니다.");
			break;
		case "과장":
			System.out.println(position+"의 직급은 300만원입니다.");
			break;
		case "차장":
			System.out.println(position+"의 직급은 400만원입니다.");
			break;
		case "부장":
			System.out.println(position+"의 직급은 500만원입니다.");
			break;
		default:
			System.out.println(position+"은(는) 없는 직급입니다.");
			System.out.println("직급을 다시 입력해주세요.");
		}
	}//end main
}//end class



























######################################################################################################
개념정리_while

* 반복문 while

- while문은 조건식을 만족하는 동안 반복문을 실행하는데, 조건식을 검사해서 조건식이 참이면 실행문을 반복하고, 거짓이면 while문 을 빠져나옵니다.

- while문에 들어가는 조건식도 if문과 마찬가지로 반드시 boolean타입으로 결과를 반환해야 합니다.

- 조건식 안에 true를 넣으면 무한루프가 발생하기 때문에 반드시 탈출구문을 넣어야 합니다.




public class _5WhileExample1 {
	public static void main(String[] args) {
		//1~10까지의 누적합계를 구하는 로직
		int sum = 0; //합계를 저장할 변수
		int n=1; //제어변수 : 반복문의 횟수를 제어할 변수
		
		while(n <= 10) {
			sum += n;
			n++;
		}
		System.out.println("1부터 10까지의 합 : "+ sum);
		
	}//end main
}//end class


######################################################################################################
























######################################################################################################
예제9) while 응용(소수판별로직)

소수를 판별하는 while 제어문을 작성하시오.


######################################################################################################




답:



import java.util.Scanner;

public class _5WhileExample2 {
	public static void main(String[] args) {
		//정수를 이력받아서 해당 정수가 소수인지 판별
		Scanner scan = new Scanner(System.in);
		System.out.print("정수를 입력: ");
		int num = scan.nextInt();
		
		int i=2;
		while (num%i != 0) {
			i++;
		}
		if (i == num) {
			System.out.println(num + "은 소수입니다.");
		}
		else {
			System.out.println(num + "은 소수가 아닙니다.");			
		}
	}
}




































======================================================================================================
*21.09.02_6회차(6강)
======================================================================================================














































######################################################################################################
개념정리_do while, for

#차이점
while : 시작값이 false면 0회실행
do while : 시작값이 false면 1회실행

#for(초기값;boolean형 조건식;반복표현식(증감식)){
	실행문
}//초기값은 반드시 한번실행된다.

#for예문

public class _2ForExample1 {
	public static void main(String[] args) {
		int sum=0;
		for(int n=1; n<=10;n++) {
			sum += n;
		}
		
		System.out.println("누적합: " + sum);
	}
}


public class _2ForExample2 {
	public static void main(String[] args) {
		//7~100까지의 정수중 7의 배수를 모두 가로로 출력
		for(int i=7; i<101; i++) {
			System.out.print(i+ " ");
		}
		System.out.println("\n--------------------");
		
		//1~100가지의 정수중 6의 배수를 모두 가로로 출력
		for(int i = 1; i < 101; i++) {
			if(i%6==0) {
				System.out.print(i + " ");
			}			
		}
		System.out.println("\n--------------------");
		
		//1~100가지 정수중 8의 배수이면서 동시에 16의 배수가 아닌수를 모두 가로로 출력
		for(int i=1;i<101;i++) {
			if(i%8==0 && i%16!=0)
				System.out.print(i + " ");
		}
		System.out.println("\n--------------------");
		
		//1~850까지의 정수중 9의 배수의 개수를 출력
		int n=0;
		for(int i=1;i<851;i++) {
			if(i%9==0)
				n++;
		}
		System.out.println("9의 배수의 개수: " + n);
	}
}


public class _3ForQuiz {
	public static void main(String[] args) {
		int dan = (int)(Math.random()*8)+2;
		System.out.println("랜덤 구구단 " + dan + "단");
		System.out.println("--------------------------");
		for(int i=1;i<10;i++) {
			System.out.println(dan + " x " + i + " = " + dan*i);
		}
	}
}




######################################################################################################














######################################################################################################
예제10) do while

1)정수를 입력받아 1부터 입력받은 숫자까지의 누적합을 구하는 로직을 통해 while로 구현하고
 do while로 구현해서 차이점을 확인하라
######################################################################################################


답:

0을넣어서 확인해야함 0을 넣었을때 while은 1번도안해서 sum=0 dowhile은 1번해서 sum=1이됨

import java.util.Scanner;

public class _1DoWhileExample {
	public static void main(String[] args) {
		//정수를 입력받아 1부터 입력받은 숫자까지의 누적합을 구하는 로직
		Scanner scan = new Scanner(System.in);
		System.out.print("정수: ");
		int target = scan.nextInt();
		int sum = 0;
		int n=1;
		
//		while(n<=target) {
//			sum+=n;
//			n++;
//		}
//		System.out.println("1부터 " + target + "까지의 누적합계  : " + sum);
		
		do {
			sum += n;
			n++;
		}while(n<=target);
		
		System.out.println("1부터 " + target + "까지의 누적합계  : " + sum);
	}
}


















######################################################################################################
예제11) 별짓기



*****
 ****
  ***
   **
    *



    *
   ***
  *****
 *******
*********



*********
 *******
  *****
   ***
    *


######################################################################################################


답:




*****
 ****
  ***
   **
    *
i	" "	*
0	0	5	
1	1	4
2	2	3
3	3	2
4	4	1
"":i
*: 5-i



public class _5ForStarEx1 {
	public static void main(String[] args) {
		for(int i=0;i<5;i++) {
			for(int j=0;j<i;j++) {
				System.out.print(" ");
			}
			for(int j=0;j<5-i;j++) {
				System.out.print("*");
			}
			System.out.println();
		}
	}
}



    *
   ***
  *****
 *******
*********

" "	*
4	1
3	3
2	5
1	7
0	9

"":j<4-i
* :j<(i*2)+1


public class _5ForStarEx2 {
	public static void main(String[] args) {
		for(int i=0;i<5;i++) {
			for(int j=0;j<4-i;j++) {
				System.out.print(" ");
			}
			for(int j=0;j<(i*2)+1;j++) {
				System.out.print("*");
			}
			System.out.println();
		}
	}
}



*********
 *******
  *****
   ***
    *


""	*
0	9	8 (2*4) +1
1	7	6 (2*3) +1
2	5	4    2
3	3	2
4	1	0 

"":j<i
* :j<2*(4-i)+1




public class _5ForStarEx3 {
	public static void main(String[] args) {
		for(int i=0;i<5;i++) {
			for(int j=0;j<i;j++) {
				System.out.print(" ");
			}
			for(int j=0; j<(2*(4-i)+1); j++) {
				System.out.print("*");
			}
			System.out.println();
		}	
	}
}





























































======================================================================================================
*21.09.03_7회차(7강)
======================================================================================================
























































######################################################################################################
개념정리_향상된 for문
#enhanced for(강화된 포문, 향상된 포문)

for(엘리먼트 선언: 배열또는 컬렉션의 레퍼런스->배열변수말하는거임){
	실행문;
}

엘리먼트: 배열변수에서 나오는 0번인덱스값부터를 받을 변수
레퍼런스: 배열변수 또는 컬렉션변수 


public class _1EnhancedForLoop {
	public static void main(String[] args) {
		 String[] weekDay = {"일", "월", "화", "수", "목", "금", "토"};
//		 for(int i=0;i<weekDay.length;i++) {
//			 System.out.println(weekDay[i] + "요일");
//		 }
		 for(String day:weekDay) {
			 System.out.println(day+"요일");
		 }

	}

}



######################################################################################################


























######################################################################################################
예제12) enhanced for문
향상된 for문을 사용하여 총점과 평균을 출력

######################################################################################################


답:


public class _1EnhancedForLoop {
	public static void main(String[] args) {

		 //향상된 for문을 사용하여 총점과 평균을 출력
		 int sum=0;
		double avg=0;
		
		for(int i:scores) {
			sum += i;
		}
		avg = (double)sum / scores.length;
		System.out.println(avg);
	}

}


























######################################################################################################
예제13)loop+제어문+탈출문
1)아래의 출력결과가 되도록하라
	-커피는 최초 5잔이다.
돈넣어라 : 500
커피를 한잔드리겠습니다.
남은 커피 : 4잔
돈넣어라 : 700
커피를 한잔드리겠습니다.
남은 커피 : 3잔
잔돈 : 200원입니다.
돈넣어라 : 600
커피를 한잔드리겠습니다.
남은 커피 : 2잔
잔돈 : 100원입니다.
돈넣어라 : 400
500원이상넣어라
돈넣어라 : 500
커피를 한잔드리겠습니다.
남은 커피 : 1잔
돈넣어라 : 700
커피를 한잔드리겠습니다.
남은 커피 : 0잔
잔돈 : 200원입니다.
음료수가 다떨어졌습니다. 판매를 중지합니다.

######################################################################################################




답:





import java.util.Scanner;

public class _2LoopQuiz {
	public static void main(String[] args) {
		Scanner scan = new Scanner(System.in);
		int coffee=5;
		
		while(true) {
			System.out.print("돈넣어라 : ");
			int money=scan.nextInt();
			if(money<500) {
				System.out.println("500원이상넣어라");
			}else if(money==500){
				System.out.println("커피를 한잔드리겠습니다.");
				coffee--;
				System.out.println("남은 커피 : " + coffee + "잔");
				if(coffee==0) {
					System.out.println("음료수가 다떨어졌습니다. 판매를 중지합니다.");
					break;
				};
			}else if(money>500){
				System.out.println("커피를 한잔드리겠습니다.");
				coffee--;
				money-=500;
				System.out.println("남은 커피 : " + coffee + "잔");
				System.out.println("잔돈 : " + money + "원입니다.");
				if(coffee==0) {
					System.out.println("음료수가 다떨어졌습니다. 판매를 중지합니다.");
					break;
				};
			}
		}
	}
}

































































======================================================================================================
*21.09.04_8회차(8강)
======================================================================================================



















































######################################################################################################
개념정리_메서드 및 매개변수 개념


함수: 클래스가 아닌 전역에 선언되고 정의된함수
메서드: 클래스안에 선언되고 정의된 함수

자바: 클래스밖에없기때문에 함수가없고 모두 메서드라부름

*메서드(method) : 코드반복을 막기위함
-메서드는 정의하는 과정과 호출하는 과정이 있음
-메서드 선언은 메서드 내부에서는 할수없음 반드시 메서드블록 외부에서만 선언가능
	-main안에서 못만든단소리
	-class내부에서만가능
-메서드 내부에서는 다른 메서드의 호출만 가능
-호출하는 과정은 메서드를 사용하는 과정이며 해당메서드가 필요로하는 데이터(매개값)를 메서드 내부로 전달하면서 해당 메서드는
 매개값을 통해 처리한 결과값을 호출부로 다시 반환해줌


public class _1MethodExample1 {
	public static int calcSum(int num){
		int sum=0;
		for(int i=1;i<=num;i++) {
			sum+=i;
		}//endFor
		return sum;
	}//endMethod
	public static int calcSum2(int begin, int end) {
		int sum=0;
		//short sum=0;가능 왜냐면 반환될때 int로 자동형변환되기때문임 작은놈->큰놈
		for(int i=begin;i<=end;i++) {
			sum+=i;
		}
		return sum;
	}
	
	public static void main(String[] args) {
		System.out.println("1~10까지 누적합: "+calcSum(10));
		System.out.println("1~20까지 누적합: "+calcSum(20));
		int result = calcSum(100);
		System.out.println("1~100까지 누적합: "+result);
		System.out.println(0+"~"+100+"까지의 누적합: "+calcSum2(0,100));
		
	}//endMain
}//endClass


#매개변수
-매개변수는 메서드를 호출할때 실행에 필요한값들을 메서드 내부로 전달하기위한 매개체
-메서드 호출부에서 어떤매개값을 전달하느냐에 따라 메서드의 실행결과가 달라짐
-매개변수를 몇개전달받을지는 메서드를 선언할때 선언부에서 결정해야함
-매개변수를 하나도 선언하지 않을수 있으며 이때는 메서드 선언부의 ()를 비워둠 그리고 호출시에도 ()를 비워서 호출함





public class _1MethodExample2 {
	public static void main(String[] args) {
		System.out.println(calcSum());
		System.out.println(calcSum());
		System.out.println(calcSum());
		System.out.println(calcSum());
		System.out.println("이번에 획득한 무기: "+randomWeapon());
	}
	
	public static int calcSum() {
		int sum=0;
		for(int i=1;i<=100;i++) {
			sum+=i;
		}
		return sum;
	}
	public static String randomWeapon() {
		double d=Math.random();
		if(d>0.66) return "단검";
		else if(d>0.33) return "장궁";
		else return "지팡이";
	}
}




######################################################################################################


















######################################################################################################
개념정리_반환값 개념

#반환유형(return type)

1.반환값은 메서드를 호출한 곳으로 메서드의 최종실행 결과를 전달하는 값임
2.매개변수는 여러개 존재할수있지만 반환값은 오직 하나여야함
3.return이라는 키워드를 사용하여 return 뒤에 전달할 값을 지정
4.전달할 값의 데이터 타입을 반환유형이라고 하며 메서드를 선언할때 메서드 이름 앞에 반환유형을 명시해야함
5.반환값이 있는 메서드는 호출문이 하나의 값이 되기때문에 반화된 값을 다른변수에 대입할수도있고 다른 메서드의 매개값으로 사용할수도
	있음

6.모든 메서드가 반환값이 필요한것은 아님 메서드 실행 이후에 반환값이 없다면 return을 사용하지 않아도 된다.
	-이때는 반환유형을 선언시에 void라 해야함
7.모든 메서드는 return키워드를 만나면 강제로 종료됩니다. 따라서 return문 이하에 코드를 작성할수 없음
8.반환값이 없는 메서드는 반드시 단독호출해야함
	-변수에 저장하거나 다른 메서드의 매개값으로 사용불가




import java.util.Scanner;

public class _1MethodExample3 {
	public static int add(int n1, int n2) {
		return n1 + n2;
	}//add
	public static int[] totalOperate(int n1, int n2){
		int[] total= {n1+n2,n1-n2,n1*n2,n1/n2};
		return total;
	}//totalOperate
	public static void callMyName(String name) {
		if(name.length()<2) {
			System.out.println("이름은 2글자 이상으로 입력하세요!");
			return;
		}
		System.out.println("내 이름은 "+name+"입니다.!!");
	}//callMyName
	
	public static void main(String[] args) {
		int r = add(3,5);
		System.out.println(r);
		
		int r2=add(add(4,6), add(8,7));
		System.out.println(r2);
		
		int[] tot=totalOperate(30,5);
		System.out.println("30 + 5 = "+tot[0]);
		System.out.println("30 - 5 = "+tot[1]);
		System.out.println("30 * 5 = "+tot[2]);
		System.out.println("30 / 5 = "+tot[3]);
		callMyName("리덕화");
		
		System.out.println("---------------------------");
		Scanner sc = new Scanner(System.in);
		System.out.print("이름 입력: ");
		String name = sc.nextLine();
		callMyName(name);
	}//main
}//class


######################################################################################################

















######################################################################################################
개념정리_string mainpulate


#대소문자 변경 / Stirng 문자열에서 특정문자 반환(변수, 버퍼)

public class StringMainPulate {
	public static void main(String[] args) {
		String str = "iNSERT";
		System.out.println(str);
		
		//문자열을 일괄적으로 소문자로 변환하는 메서드는 toLowerCase()
		str = str.toLowerCase(); //반대 : toUpperCase()
		System.out.println(str);
		
		str = str.toUpperCase();
		System.out.println(str);
		
		//문자열에서 특정 문자 하나만 가져오는 메서드는 charAt(문자열인덱스번호)입니다.
		char c = str.charAt(0);			//str이란 변수에서 0번인덱스 가져오기
		System.out.println(str.charAt(0));
		System.out.println(c);
		
	}//main
}//class



char gender = scan.next().charAt(0);	//버퍼에서 바로 0번인덱스만 가져오기


######################################################################################################





















######################################################################################################
예제14)고객관리프로그램(다음 강의를 통해 완성될 예제_정보수정, 정보삭제 기능이 없음)



#요구사항정의
-고객의 정보는 이름,성별,이메일,출생년도가 있습니다. 고객의 정보를 입력받아 배열에 저장해야합니다. 이름은 문자열로 저장하며, 
 성별은 남자는 M, 여자는 F로 저장합니다. 이메일은 문자열로 저장하며 태어난 출생년도는 정수로 저장합니다.
-고객관리프로그램은 고객의 정보를 저장, 조회, 수정, 삭제할 수 있는 기능이 있어야 합니다. 고객 정보를 파일에 저장하는 기능을 구현하지 않아도 
 됩니다.
-I를 눌러 고객의 정보를 입력받도록 하며, 저장된 고객정보는 P또는 N을 눌러 이전 고객정보 또는 다음 고객정보를 조회할수 있어야합니다.
 조회한 고객정보는 U를 눌러 새로운 정보로 수정할수 있어야합니다. D를 누르면 조회한 고객 정보를 배열에서 삭제해야 합니다. 프로그램의 
 종료는 Q를 누릅니다.





######################################################################################################




답:



import java.util.Arrays;
import java.util.Scanner;

public class CustomerManager {
	//프로그램 전체에서 사용할 변수들은 클래스블록 바로 아래에 선언합니다.
	//static이 붙은 블록에서는 static변수와 static 메서드만 사용할수 있음
	
//globalVariable
	static String[] nameList = new String[100];
	static char[] genderList = new char[100];
	static String[] emailList = new String[100];
	static int[] birthList = new int[100];
	
	//현재 고객데이터가 몇명 저장되었는지 알기위한 변수 count 선언
	static int count = 0;
	
	//배열의 인덱스를 조작하기 위해 인덱스를 변수화시킴
	//배열의 인덱스는 0번부터 출발함으로 초기값을 0바로 이전값인 -1로 세팅하여 초기에
	//next를 실행했을때 인덱스가 0이되어 첫번째 고객을 조회하기 위함
	static int index = -1;
	static Scanner scan = new Scanner(System.in);

//userDefinedMethod
	//고객정보를 입력받는 메서드 선언
	public static void insertData() {
		System.out.println("==============고객정보입력=============");
		
		System.out.print("이름 : ");
		String name = scan.next();
		
		System.out.print("성별(M/F): ");
		char gender = scan.next().charAt(0);
		
		System.out.print("이메일: ");
		String email = scan.next();
		
		System.out.print("출생년도: ");
		int birth = scan.nextInt();
		
		nameList[count] = name;
		genderList[count] = gender;
		emailList[count] = email;
		birthList[count] = birth;
		
		System.out.println("=====================================");
		count++;
		index++;
	}
	public static void disp() {
		for(int i=0;i<count;i++) {
			System.out.println(nameList[i]);
			System.out.println(genderList[i]);
			System.out.println(emailList[i]);
			System.out.println(birthList[i]);
		}
	}
	public static void printData(int index) {
		System.out.println("\n===========고객정보=============");
		System.out.println(nameList[index]);
		System.out.println(genderList[index]);
		System.out.println(emailList[index]);
		System.out.println(birthList[index]);
		System.out.println("\n==============================");
	}
	
	
//main
	public static void main(String[] args) {
//while
		while(true) {
			System.out.println("\n[INFO] 고객수: " + count
					+ ", 인덱스: " + index);
			System.out.println("메뉴를 입력하세요.");
			System.out.println("(I)nsert, (P)revious, "
					+ "(N)ext, (C)urrent, (U)pdate, "
					+ "(D)elete, (Q)uit");
			System.out.print("메뉴 입력: ");
			String menu = scan.next();
			
			menu = menu.toUpperCase();
			char m = menu.charAt(0);
//switch
			switch(m) {
			case 'ㅑ':
			case 'I':
				System.out.println("\n고객정보 입력을 시작합니다.");
				insertData();
				System.out.println("고객정보가 정상적으로 입력되었습니다.");
//				System.out.println("현재 종류별 총 입력정보");
//				System.out.println(Arrays.toString(nameList));
//				System.out.println(Arrays.toString(genderList));
//				System.out.println(Arrays.toString(emailList));
//				System.out.println(Arrays.toString(birthList));
				break;
			case 'ㅔ':
			case 'P':			
				if(count==0) {
					System.out.println("데이터를 먼저 입력해주세요."
							+"\n현재 데이터가 하나도 없습니다.");
					continue;
				}
				System.out.println("\n이전 고객정보를 조회합니다.");
				if(index==0) {
					System.out.println("이전 데이터가 없습니다.(현재 첫번재) "
							+ "\n첫번째 데이터를 다시 출력합니다.");
					printData(index);
					continue;
				}
				index--;
				printData(index);
				break;
			case 'ㅜ':
			case 'N':
				if(count==0) {
					System.out.println("데이터를 먼저 입력해주세요."
							+"\n현재 데이터가 하나도 없습니다.");
					continue;
				}
				System.out.println("\n다음 고객정보를 조회합니다.");
				if(count!=0&&index==count-1) {
					System.out.println("다음 데이터가 없습니다.(현재 마지막)"
							+ "\n가장 마지막 데이터를 출력합니다.");
					printData(index);
					continue;
				} 
				index++;
				printData(index);
				
				break;
			case 'ㅊ':
			case 'C':
				System.out.println("\n현재 고객정보를 조회합니다.");
				printData(index);
				break;
			case 'ㅕ':
			case 'U':
				System.out.println("\n현재 고객정보를 수정합니다.");
				break;
			case 'ㅇ':
			case 'D':
				System.out.println("\n현재 고객정보를 삭제합니다.");
				break;
			case 'ㅂ':
			case 'Q':
				System.out.println("\n프로그램을 종료합니다.");
				scan.close();
				System.exit(0);	//프로그램을 강제종료하는 구문
				break;
			default:
				System.out.println("\n메뉴를 잘못 입력하셨습니다.");
			}//switch
		}//while
	}//main
}//class

































































































======================================================================================================
*21.09.05_9회차(9강)
======================================================================================================


















































































######################################################################################################
예제14)고객관리프로그램



#요구사항정의
-고객의 정보는 이름,성별,이메일,출생년도가 있습니다. 고객의 정보를 입력받아 배열에 저장해야합니다. 이름은 문자열로 저장하며, 
 성별은 남자는 M, 여자는 F로 저장합니다. 이메일은 문자열로 저장하며 태어난 출생년도는 정수로 저장합니다.
-고객관리프로그램은 고객의 정보를 저장, 조회, 수정, 삭제할 수 있는 기능이 있어야 합니다. 고객 정보를 파일에 저장하는 기능을 구현하지 않아도 
 됩니다.
-I를 눌러 고객의 정보를 입력받도록 하며, 저장된 고객정보는 P또는 N을 눌러 이전 고객정보 또는 다음 고객정보를 조회할수 있어야합니다.
 조회한 고객정보는 U를 눌러 새로운 정보로 수정할수 있어야합니다. D를 누르면 조회한 고객 정보를 배열에서 삭제해야 합니다. 프로그램의 
 종료는 Q를 누릅니다.

//각 함수에대한 조건은 모두 switch에 넣어라(함수에 탈출조건넣지마라는소리임)
insertData(index);
printData(index);
updateData(index);	//풀이에서는 함수에넣긴했는데 풀때는 그렇게풀지마라 정해진건아니고 통일하자는 차원에서.. 
deleteData(index);


######################################################################################################




답:






import java.util.Scanner;

public class CustomerManagement {
//variable
	static String[] nameList = new String[100];
	static char[] genderList = new char[100];
	static String[] emailList = new String[100];
	static int[] birthList = new int[100];
	
	static int count = 0;
	static int index = -1;
	
	static Scanner scan = new Scanner(System.in);
	
//userDefinedMethod
	public static void insertData() {
		System.out.print("이름입력 : ");
		nameList[count] = scan.next();
		
		System.out.print("성별입력(M/W) : ");
		genderList[count] = scan.next().toUpperCase().charAt(0);

		System.out.print("이메일입력 : ");
		emailList[count] = scan.next();
		
		System.out.print("출생년도입력 : ");
		birthList[count] = scan.nextInt();
		
		count++;
	}
	public static void updateData() {
		System.out.printf("이름입력(%s) : ", nameList[index]);
		nameList[index] = scan.next();
		
		System.out.printf("성별입력(%c) : ", genderList[index]);
		genderList[index] = scan.next().toUpperCase().charAt(0);

		System.out.printf("이메일입력(%s) : ", emailList[index]);
		emailList[index] = scan.next();
		
		System.out.printf("출생년도입력(%d) : ", birthList[index]);
		birthList[index] = scan.nextInt();
	}
	public static void printData() {
		System.out.println("=============고객정보 조회=============");
		System.out.println("이름 : " + nameList[index]);
		System.out.println("성별 : " + genderList[index]);
		System.out.println("e메일 : " + emailList[index]);
		System.out.println("출생년도 : " + birthList[index]);
		System.out.println("==================================");
	}
	public static void deleteData() {
		for(int i=index;i<count-1;i++) {
			nameList[i] = nameList[i+1];
			genderList[i] = genderList[i+1];
			emailList[i] = emailList[i+1];
			birthList[i] = birthList[i+1];
		}
		count--;
	}
	public static char menu() {
		System.out.println("\n<명령어 목록>");
		System.out.printf("현재 count: %d, 현재 index: %d\n", count,index);
		System.out.println("Insert, Previous, Current"
				+ ", Next, Update, Delete, Quit");
		
		System.out.print("명령어 입력: ");
		char menu = scan.next().toUpperCase().charAt(0);
		
		return menu;
	}
	public static void menuProcessor(char menu) {
		switch(menu) {
		case 'ㅑ':
		case 'I':
			System.out.println("\n고객의 정보 추가을 실시합니다.");
			insertData();
			break;
			
		case 'ㅔ':
		case 'P':
			System.out.println("\n이전 정보를 조회합니다.");
			if(count==0) {
				System.out.println("데이터를 입력하세요.");
				break;
			}
			if(index<=0) {
				System.out.println("인덱스값을 변경하세요.");
				break;
			}
			index--;
			printData();
			break;
			
		case 'ㅊ':
		case 'C':
			System.out.println("\n현재 정보를 조회합니다.");
			if(count==0) {
				System.out.println("데이터를 입력하세요.");
				break;
			}
			if(index<0) {
				System.out.println("인덱스값을 변경하세요.");
				break;
			}
			printData();
			break;
			
		case 'ㅜ':
		case 'N':
			System.out.println("\n다음 정보를 조회합니다.");
			if(count==0) {
				System.out.println("데이터를 입력하세요.");
				break;
			}
			if(index==count-1) {
				System.out.println("인덱스값을 변경하세요.");
				break;
			}
			index++;
			printData();
			break;
			
		case 'ㅕ':
		case 'U':
			if(count==0) {
				System.out.println("데이터를 입력하세요.");
				break;
			}
			if(index<0) {
				System.out.println("인덱스를 변경하세요.");
				break;
			}
			System.out.println("\n"+nameList[index]+"님의 정보를 수정합니다.");
			updateData();
			break;
			
		case 'ㅇ':
		case 'D':
			if(count==0) {
				System.out.println("데이터를 입력하세요.");
				break;
			}
			if(index<0) {
				System.out.println("인덱스를 변경하세요.");
				break;
			}
			System.out.println("\n정보 삭제를실시합니다.");
			deleteData();
			break;
			
		case 'ㅂ':
		case 'Q':
			System.out.println("\n고객관리 매니저를 종료합니다.");
			System.exit(0);
			break;
			
		default:
			System.out.println("명령어를 잘못 입력하셨습니다.");
		}//switch
	}//menuProcessor

//main
	public static void main(String[] args) {
		while(true) {
			char menu = menu();
			menuProcessor(menu);
		}
	}//main
}//class







######################################################################################################
개념정리_배열의 삭제


#배열 {1,2,3,4}가 있을때 1번인덱스를 삭제하면
 1,3,4,4가 되도록 삭제해야하고 사용자한테는 시스템상 마지막 4를 안보이게해서 논리적으로는 사라진것처럼 보이게해야한다.
	??궁금:근데 왜 굳이 마지막거 널로 안채우지? 널로채우면 더 직관적이고 좋은듯한데
 

import java.util.Arrays;

public class _4ArrayDelete {
	public static void main(String[] args) {
		int[] iArr = {1,3,5,7,9,11,13};
		System.out.println(Arrays.toString(iArr));
		
		int index=3;
		for(int i=index;i<iArr.length-1;i++) {
			iArr[i] = iArr[i+1];
		}
		System.out.println(Arrays.toString(iArr));
		String[] nameList = new String[100];
		nameList[0]="홍길동";
		nameList[1]="신사임당";
		nameList[2]="이순신";
		nameList[3]="강감찬";
		System.out.println(Arrays.toString(nameList));
		//||nameList[i+1]!="0"
		
		int count = 4;
		for(int i=1;i<count-1;i++) {
			nameList[i] = nameList[i+1];			
		}
		System.out.println(Arrays.toString(nameList));
	}
}





######################################################################################################




















######################################################################################################
개념정리_실행파일만들기

<eclips->.jar만들기>
실행중인 소스코드중지
프로젝트우클릭
export
java디렉터리클릭
Runnable JAR file 클릭 -next 클릭
Launch configuration에서 빼고싶은 class 클릭
저장위치및 이름선택
finish
ok

<window>
해당위치에 생겼는지확인
jsmooth 설치

<jsmooth>
skeleton
selection의 none이라 되어있는곳 클릭
console wrapper 클릭
	-console wrapper : 도스프로그램만들때
	-windowed wrapper : 윈도우그래픽프로그램만들때

excutable클릭
excutable binary에서 .jar클릭-클릭 후 binary에 경로가 입력되는데 .jar를 .exe로 수동변경할것
	-어떤파일을 실행가능하게 만들것이냐 묻는거임
		-내생각에는 excuta에서는 exe로 만들때 이름뭘로할건지 묻는거고 그파일이름 다쓰기힘드니까 그냥 .jar가져와서
			.exe로만 바꾸는듯

2번째칸에서 실행파일의 아이콘이될 사진클릭
current directory에 '.'기호 하나만 표시

application클릭
embedded jar의 경로에 .jar클릭
	-use an embedded jar 클릭
main class위치에서 프로젝트 내 실제 실행파일로만들 클래스를 찍어줌

위에 톱니바퀴아이콘클릭
	-이때만들어지는파일은 해당 프로젝트의 클래스들을 언제든지 만들기위한 바로가기역할인가?


######################################################################################################






















######################################################################################################
개념정리_클래스 배경 및 기본코드


#객체
속성: 멤버변수, 필드
기능: 메서드



#아래 add함수를 3개 result를 3개만든것처럼 계속 코드를 재작성해야하는데 이게 낭비다(시간,인력,리소스)
	-그래서 하나의 설계를 만들어놓고 함수처럼 매번 재작성하는게 아니라 객체를 클래스로 찍어내자는것

public class _1Object_Basic1 {
	static int result1 = 0;
	static int result2 = 0;
	static int result3 = 0;
	public static int add1(int n) {
		result1 += n;
		return result1;
	}
	public static int add2(int n) {
		result2 += n;
		return result2;
	}
	public static int add3(int n) {
		result2 += n;
		return result2;
	}
	public static void main(String[] args) {
		System.out.println("1번 계산기 계산결과!");
		System.out.println("=======================");
		System.out.println(add1(6));
		System.out.println(add1(14));
		System.out.println(add1(140));
		
		System.out.println("2번 계산기 계산결과!");
		System.out.println("=======================");
		System.out.println(add2(64));
		System.out.println(add2(10));
	}
}


----------------------------------------------------


#위의 낭비를 해결(시간낭비,인력낭비,리소스낭비_코드영역) + 관리용이 (절차지향은 위처럼 모든걸 함수나 코드로 작성해야해서
							1번계산기로 넣으려면 또 배열을 만들어서 추가적으로 변수들을
							입력해 모아두어야한다. 구조체를 만들던가. 그러면 그변수와
							그변수에 맞는 함수를 외우고서 같이 실행해야하는데
							클래스는 그러한것을 모두 없애준다)


public class _2Calculator {
	int result = 0;
	int add(int n) {
		result += n;
		return result;
	}
	int sub(int n) {
		result-=n;
		return result;
	}
	int mul(int n) {
		result*=n;
		return result;
	}
	
}

public class _3CalMain {
	public static void main(String[] args) {
		_2Calculator c1 = new _2Calculator();	//1번계산기 생성
		_2Calculator c2 = new _2Calculator();	//2번계산기 생성
		
		c1.add(14);
		c1.sub(7);
		c1.mul(6);
		
		c2.add(5);
		c2.sub(4);
		c2.mul(6);
		
		System.out.println("1번계산기 결과값: "+c1.result);
		System.out.println("2번계산기 결과값: "+c2.result);		
	}
}


######################################################################################################























































































































======================================================================================================
*21.09.06_10회차(10강)
======================================================================================================
















































######################################################################################################
개념정리_객체지향프로그래밍 

클래스 내부에 속성(멤버변수)과 기능(함수)

Marker rPen = new Marker();
c와다르게 자바는 rPen앞에 에스크립터를붙여서 포인트변수화 하지 않아도 자동으로
포인트변수화시킨뒤 주소를 저장하나보다.
그럼 배열과마찬가지로 객체를 스택에서 구현은불가능한가?

modifire: 접근제한자

#객체 이용
아래보면 blackPen을 포인터변수화안해도 자동 포인트변수화가된다.
왜냐면 스택에 어차피 클래스를 만들지 못하니 무조건 포인트변수화해놓은듯하다
그럼 마찬가지로 스택에 없으니 .을 찍는경우도 *없이 .만찍어도된다.
스택이 있으면 구분하기위해 스택에선 그냥 .만찍고 포인터변수인경우 차이를 구분하기위해 *.을 찍는데
어차피 모두다 포인터로 *을 찍을거면 찍지말자고 합의했나보다.
안찍어도 그건 포인터밖에 없으니까
즉 -> .*이 무의미해졌고 .하나가 모두 함축한다는 뜻이다.


//설계용 클래스(라이브러리 클래스)는 메인메서드를 작성하지 않는다.
public class Pen {
	//객체의 속성을 나타내는것을 필드(멤버변수)라고 부름
	String color;
	int price;
	
	//객체의 기능을 나타내는 것을 메서드(멤버함수)라고 부름
	void write() {
		System.out.println(color + "색 글을 씁니다.");
	}
	
	void info() {
		System.out.println("----------pen's Info------------");
		System.out.println("색상: "+color);
		System.out.println("가격: "+price);
		//배열은 동종모음구조라 지금처럼 여러 형태의 데이터를 저장불가능하며 기능함수를
		//묶을수없다.
		
		
	}

}

public class PenMain {
	public static void main(String[] args) {
		//Pen의 기능과 속성을 사용하려면 설계용 클래스를 로딩시켜 pen 객체를 생성해야함
		Pen blackPen = new Pen();
		blackPen.color = "검정";
		blackPen.price = 400;
		
		blackPen.write();
		blackPen.info();
		
		Pen redPen = new Pen();
		redPen.color = "빨강";
		redPen.price = 600;
		redPen.write();
		redPen.info();
		
		
		System.out.println(blackPen);
		System.out.println(redPen);
				
		
		Pen bluePen = new Pen();
		bluePen.color = "파랑";
		bluePen.price = 500;
		
		bluePen.write();
		bluePen.info();
		
	
	}

}



######################################################################################################








######################################################################################################
개념정리_변수

#매개변수에 디폴트값을 넣는다고해서 c처럼 디폴트매개변수가 되지 않는다. 그런건 지원안함


public class Variable {
	//필드(멤버변수) 선언.
	int a; //초기화하지 않으면 기본값으로 자동 초기화
	
	//메서드 선언
	void printNumber(int c) {
		//지역변수 b와 매개변수 c를 선언
		int b=0;
		
		System.out.println("멤버변수: "+a);
		System.out.println("지역변수: "+b); //멤버, 매개는 초기화안되어있어도
										//출력등 사용가능한데 지역변수는 반드시
								//초기화해야 출력가능하다. 멤버나 매개는 밖에서
								//들어올것을 알기때문이다.
								//멤버변수는 초기화하지 않아도 기본값으로 자동초기화된다
								//매개는 반드시 밖에서 들어온다
		System.out.println("매개변수: "+c);
		
	}
	
	public static void main(String[] args) {
		Variable  v = new Variable();
		v.printNumber(5);
	}
}
 

######################################################################################################




















######################################################################################################
예제15)계좌관리프로그램

offshoot의 AccountManager.exe와 똑같이 프리코딩하시오.

클래스명: Account 
	멤버변수 : name, password(int), balance(int)->계좌내 잔액
	멤버함수 : 출금(withDrawMoney), 입금(deposit), 잔액조회(getBalance)
	
main클래스: AccountManager
	멤버변수 : 알아서
	멤버함수 : 알아서

######################################################################################################




답:






public class Account {
	String name;
	int password;
	int balance;
	
	void deposit(int money) {
		balance += money;
		System.out.println(money+"원 입금되었습니다.");
	}
	void withDrawMoney(int money) {
		balance -= money;
		System.out.println(money+"원 출금되었습니다.");
	}
	int getBalance() {
		return balance;
	}
}


=====================================


import java.util.Scanner;

public class AccountManagerReview {
	static Scanner scan = new Scanner(System.in);
	
	public static int pwCheck(Account p1) {
		System.out.println("계좌 비밀번호를 입력하세요.");
		System.out.print("> ");
		int password = scan.nextInt();
		if(p1.password!=password) {
			System.out.println("비밀번호가 틀렸습니다.\n메뉴로 돌아갑니다.");
		}
		return password;
	}
	
	
	
	
	public static void accountAccounting(Account p1) {
		System.out.println("계좌를 등록합니다.");
		System.out.print("이름: ");
		p1.name = scan.next();
		
		System.out.print("비밀번호: ");
		p1.password = scan.nextInt();
		
		System.out.print("처음 입금액: ");
		p1.balance = scan.nextInt();
	}
	public static int menu() {
		System.out.println("\n메뉴를 입력하세요.");
		System.out.println("1.예금 / 2.출금 / 3.잔액조회 / 4.종료");
		System.out.print("> ");
		int menu = scan.nextInt();
		
		return menu;
	}
	public static void deposit(Account p1) {
		if(pwCheck(p1)==p1.password) {	
			System.out.print("입금액 입력: ");
			int money = scan.nextInt();
			p1.deposit(money);
		}
	}
	public static void withDrawMoney(Account p1) {
		if(pwCheck(p1)==p1.password) {	
			System.out.print("출금액 입력: ");
			int money = scan.nextInt();
			
			if(money>p1.balance) {
				System.out.println("잔액부족입니다! 슈퍼가서 돈넣고 오세요^^");
				return;
			}
			
			p1.withDrawMoney(money);
		}
	}	
	public static void getBalance(Account p1) {
		if(pwCheck(p1)==p1.password) {			
			System.out.println(p1.name+"님의 계좌잔액은 "+p1.getBalance()+"원입니다.");
		}
	}
	
	public static void main(String[] args) {
		Account p1 = new Account();
		accountAccounting(p1);	
		
		while(true) {
			int menu = menu();
			
			if(menu==1) {
				deposit(p1);
			}
			if(menu==2) {
				withDrawMoney(p1);
			}
			if(menu==3) {
				getBalance(p1);
			}
			if(menu==4) {
				System.out.println("\n프로그램을 종료합니다.");
				System.exit(0);
			}
		}
	}
}





































































































======================================================================================================
*21.09.07_11회차(11강)
======================================================================================================
























































######################################################################################################
개념정리_동적할당해제개념 및 패키지



* Garbage Collecting

- 객체를 생성하는데 사용되는 키워드는 new이지만, 생성된 객체를 메모리에서 해제시키는 키워드는 존재하지 않습니다.
- 그 이유는 자바에서는 자바 가상머신(JVM)이 알아서 메모리를 관리해주며, 이를 가비지 컬렉팅이라 합니다.
- 객체가 더 이상 프로그램에서 사용되지 않으면 가비지 컬렉터가 스스로 판단해서 메모리를 해제하고 수거합니다.

	-장점: 개발자가 해제를 신경쓰지 않아도된다.
	-단점: 시시각각 메모리를 제어하지 못한다.
		-마린태어나고죽고 계속관리해야하는데 그래서 게임을 c++로 만든다.

* 패키지(package)

- 클래스는 크게 2종류가 있습니다. 하나는 개발자가 직접 만들어 사용하는 사용자 정의  클래스이고,  다른  하나는 JDK(Java Development Kit)안에 포함되어 있거나, 다른 개발자들이 미리 만들어 놓은 클래스들이 있습니다.
- 그런데 이런 클래스들은 매우 종류가 많고 비슷한 기능들을 분류시켜야 할 필요성이 있기 때문에 서로 관계가 있는 클래스들을 패키지로 묶어서 관리합니다.
- 현재 클래스에서 다른 패키지의 외부 클래스를  사용하고 싶은 경우에  import 키워드로 해당 클래스의 전체 경로(패키지  명까지 포함)를 지정해줘야 합니다.

ex) import java.util.Scanner;

- 만약 해당 패키지 안에 들어있는 모든 클래스를 사용하고 싶다면 * 기호를 넣어주면 됩니다.     ex) import java.util.*;

- package 선언 방법

1. 사용자가 임의로 패키지를 만드려면 클래스의 가장 윗부분에 패키지 구문을 포함시키면 됩니다.    ex) package store;
1. 패키지 이름은 영문 소문자로 지정하는 것을 권장합니다.
1. 대분류와 소분류 패키지를 구분할 때는 .(dot)을 사용합니다.
1. 최상위 패키지의 이름은 java로 시작할 수 없습니다. java패키지는 표준 API들의 모음을 구성해놓은 패키지입니다.
1. 자바의 키워드들도 패키지이름으로 사용할 수 없습니다.



######################################################################################################







######################################################################################################
개념정리_변수 타입

변수의 타입에는 기본타입, 참조타입이 있다.

참조타입
-배열타입
-클래스타입
-인터페이스타입

String s1 = "안녕"
String s2 = "안녕"
s1 == s2 
동일클래스라면 주소가 같게 입력되서 true
	-저장한걸또저장하네? -> cpp의 참조변수개념으로 저장됨 공간을 공유함
다른클래스라면 주소가 다르게 입력되서 false

그럼 문자열은 비교어떻게해?
아래처럼 해!

객체동등비교 메서드 : eqauls()


s1.equals(s2)
	-맞으면 트루
	-틀리면 폴스 불린자료형을 반환함
package str_equals;

public class User {
	public static void main(String[] args) {
		String id="맹탕구리";
		String id2="맹탕구";
		String pw;
		System.out.println(id.equals(id2));
		System.out.println(id.equals("맹탕구리"));
		System.out.println("랑낭".equals("랑낭1"));
	}

}




######################################################################################################












######################################################################################################
개념정리_기본 및 참조타입 개념, equals

* 기본 타입(primitive type) vs 참조 타입(reference type)

- 기본 타입이란 정수, 실수, 문자, 논리 값을 저장하는 데이터 타입입니다.
- 참조 타입이란 객체의 주소를 참조하는 타입으로 배열, 클래스, 인터페이스 타입을 말합니다.
- 기본 타입으로 선언된 변수는 실제 값(value)을 변수 안에 저장하지만, 참조 타입으로 선언된 변수는 메모리의 주소값을 변수 안에 저장합니다.
- 참조 타입으로 선언된 변수는 스택(stack)영역에 주소값을 저장하고 내부의 실제 값은 힙(heap)영역에 저장합니다.



* 참조 타입 String과 객체 동등 비교 메서드 equals()

- 자바는 문자열이 동일하다면 String 객체를 공유하도록 되어있습니다.
그래서 단순히 문자열을 String 변수에 할당한다면 같은 주소값을 갖게 됩니다.

ex) String str1 = "Hello"; String str2 = "Hello";
--> str1 == str2 -> true

- 그러나 new키워드를 사용해서 String객체를 직접 heap영역에 생성한다면 문자열의 내용이 같더라도 다른 주소값을 가지게 되므로 동등, 비동등 연산자(==, !=)의 결과가 false로 나오게 됩니다.

ex) String str3 = new String("Hello"); String str4 = new String("Hello");
--> str3 == str4 -> false

- 그래서 동일 String객체이든 다른 String 객체이든 상관없이 문자열의 내용 값 그자체를 비교할 때는 equals()  메서드를 사용해야 합    니다.


######################################################################################################











######################################################################################################
개념정리_객체지향 기술, 상속개념

* 객체 지향 프로그래밍 기술

- OOP 기술에는 은닉(캡슐화:Encapsulation), 상속(Inheritance), 다형성(Polymorphism)이 있습니다.


* 상속(Inheritance)

- OOP에서 상속은 기존의 클래스를 확장하여 새로운 클래스를 이끌어내는 것을 의미합니다.
- 상속 관계는 is a 관계를 만족하는 관계입니다.
ex) 돌고래 is a 포유류 --> 돌고래는 포유류의 속성을 가지고 있다.
- 상속은 기존의 코드를 재사용함으로써 불필요한 코드를 재작성하는 번거로움을 없앨 수 있고, 새로운 클래스를 만드는 시간과 노력을       줄일 수 있습니다.
- 자바에서는 C++에서 사용했던 다중상속의 문제점때문에 단일상속만을 지원합니다.
	-다이아몬드구조 
- 어떤 클래스가 다른 클래스로부터 상속을 받아 만들어지면 새롭게 만들어진 클래스를 자식(child or sub)클래스라고 부르며, 멤버변수       와 메서드를 물려준 클래스는 부모(parent or super)클래스라고 부릅니다.
- 상속을 하면 부모클래스의 멤버변수와 메서드가 자식클래스에 상속이 됩니다. 그러나 부모클래스의 생성자는 상속이 되지 않습니다.
- 상속을 사용하는 키워드는 extends 입니다.
- 상속을 하더라도 부모 클래스에서 private 접근제한을 갖는 멤버변수와 메서드는 상속대상에서 제외됩니다.
- 자바의 모든 클래스는 Object 클래스를 상속받고 있습니다. Object클래스는 자바의 최상위 클래스입니다.





#상속형태
-자식클래스의 이름 뒤에 extends라는 키워드를 쓰고 물려받을 클래스의 이름을 씀
	-다른클래스로부터 멤버변수와 메서드를 물려받는 클래스를 자식클래스라함

public class Student extends person {

};

#클래스를만들면서 상속만드는법
-클래스 마들때 superclass에 상속받을 클래스이름을 적으면됨


#object : 상속을 따로 지정하지 않으면 모두 object로 상속받게된다.
	-증거: 클래스만들려고키면 java.lang.Object라고 뜬다.
######################################################################################################












######################################################################################################
예제16)패키지생성 및 내부 클래스 불러오기

패키지생성
1)class에서 패키지만들기
-hello라는 package를 class에서 만들어라
	-hello하위에 bye패키지와 hi패키지를 만들고 각 패키지 내부에 패키지와 같은 이름의 class를 만들어라
		-각 패키지들은 모두 마우스로 만들어라.
2)공백 패키지만들기
-nulll(공백이란의미) 패키지를 만들어라.(클래스가 하나도 없는상태)
3)공백패키지만들고 내부에도 공백패키지만들기
	-flat, hierarchical두개로 보기좋게 해봐라


패키지이용(임폴트)
1)fruit이란 패키지를만들고 내부에 apple과 banana클래스를 만들어라.(내부설계할필요없음 임폴트만 시험할거니까)
	test란 패키지를 만들고 내부에 test란 파일을 만들어라.
2)import_ex란 패키지를만들고 내부에 ImportExample클래스를 만들어라
3)importexample클래스에서 fruit과 test패키지 내의 클래스들의 객체를 모두 만들어라.
apple과 banana는 동시에 import하고 너머지는 직접 하나하나 import하여 객체를 만들수있게하라




######################################################################################################




답:




package day0907.fruit;

public class Apple {

}

package day0907.fruit;

public class Banana {

}

package day0907.hello.bye;

public class Bye {

}

package day0907.hello.hi;

public class Hi {

}

package day0907;

import day0907.fruit.*;
//import day0907.fruit;
import day0907.hello.hi.Hi;
import day0907.hello.bye.Bye;

public class MainClass {
	Apple ap = new Apple();
	Banana bn = new Banana();
	Bye b = new Bye();
	Hi hi = new Hi();
}















######################################################################################################
예제17)상속

inherit패키지내부에 phone 패키지를 만드는데 두개를 동시에 만들어라.
그리고 phone패키지 내부에 DmbPhone, MainClass, Phone 3개의 클래스를 만들어라
그후 아래 폼을 이용해서 출력결과가 실행되게하라(Phone과 DmbPhone 클래스를 설계하라!)

Phone클래스 멤버변수: String model, String color
Phone클래스 메서드(멤버함수): powerOn, powerOff, ring(벨울리는기능_전화오는기능), hangUp(전화끊는기능)

package inherit.phone;

public class MainClass {
	public MainClass() {
		//Dmb폰 객체 생성
		DmbPhone dp = new DmbPhone("햅틱", "메탈그레이", 10);
		
		//dmb폰 객체에서 상속받은 Phone클래스의 멤버변수에 접근
		System.out.println("모델 : "+dp.model);
		System.out.println("색상 : "+dp.color);
		
		//DmpPhone에서 선언한 멤버변수에 접근
		System.out.println("채널 : "+dp.channel);
		
		
		//Dmbphone으로 만들어진 객체를이용하여 Phone에서 상속받은 메서드 호출
		dp.powerOn();
		dp.ring();
		dp.hangUp();
		
		//DmbPhone에서 선언한 메서드 호출
		dp.turnOnDmb();
		dp.changeChannel(7);
		dp.turnOffDmb();
		
		//Dmbphone으로 만들어진 객체를이용하여 Phone에서 상속받은 메서드 호출
		dp.powerOff();
	}
}


<출력결과>
모델: 햅틱
색상: 메탈그레이
채널: 10
전원을 켭니다.
벨이 울립니다.
전화를 끊습니다.
방송 수신을 시작합니다.
채널 7번으로 변경합니다.
방송 수신을 종료합니다.
전원을 끕니다.

######################################################################################################




답:


package inherit.phone;

public class Phone {
	String model;
	String color;
	
	void powerOn() {
		System.out.println("전원을 켭니다.");
	}
	void powerOff() {
		System.out.println("전원을 끕니다.");
	}
	void ring() {
		System.out.println("벨이 울립니다.");
	}
	void hangUp() {
		System.out.println("전화를 끊습니다.");
	}
}




package inherit.phone;

public class DmbPhone extends Phone{
	 int channel;
	
	 DmbPhone(String mod, String col, int ch){
		 model = mod;
		 color = col;
		 channel = ch;
	 }
	
	void turnOnDmb() {
		System.out.println("방송 수신을 시작합니다.");
	}
	void turnOffDmb() {
		System.out.println("방송 수신을 종료합니다.");
	}
	void changeChannel(int n) {
		channel = n;
		System.out.printf("채널  %d번으로 변경합니다.\n", channel);
	}

}






































































































======================================================================================================
*21.09.08_12회차(12강)
======================================================================================================






















































######################################################################################################
개념정리_overriding, overloading


* 메서드 재정의(Overriding) : 통상적으로 메서드의 기능은 같게끔 하고 내부 블록만 추가하는 것

- 메서드 재정의란 부모클래스로부터 상속받은 메서드를 자식클래스에서 행위를 바꾸거나 보완하기 위해 다시 정의해서 사용하는 것을 말합니다.

- 이는 부모클래스에서 특별한 용도로 사용하던 메서드를 자식클래스에서 다른 용도로 사용할 때 필요합니다.

- 부모클래스의 모든 메서드가 자식클래스에 맞게 설계되어 있다면 가장 이상적인 상속이지만, 특정 메서드는 자식 클래스가 사용하기 에 적합하지 않을 수도 있습니다.

- 이 경우 상속된 일부 메서드는 자식클래스에서 재정의하여 사용해야 합니다.

- 메서드가 자식클래스에서 재정의되었다면 자식객체를 통해 메서드를 호출했을 때 새롭게 재정의된 메서드가 호출됩니다.

- 메서드 재정의 규칙
1. 반드시 상속을 전제로 해야합니다.
1. 반드시 반환 유형이 같아야 합니다.
1. 메서드 이름이 같아야 합니다.
1. 매개 변수 선언이 정확히 일치해야 합니다.
1. 접근제한자는 같거나 더 제한이 없어야 합니다.(more public)


* 중복(Overloading) : 통상적으로 메서드의 기능을 변경하는 것 

- 자바는 메서드나 생성자의 중복 선언을 허용합니다.

- 중복은 메서드 또는 생성자를 선언할 때 이름은 같지만 매개 변수의 유형이나 개수를 다르게 선언해 놓는 것을 의미합니다.

- 중복을 사용하면 하나의 메서드로 매개 변수의 유형에 따라 다른 동작이 실행되게 합니다.

- 중복의 조건

1. 이름이 같아야 합니다.
1. 접근제한자나 반환유형은 영향을 미치지 않습니다.
1. 매개 변수의 유형이 달라야 합니다.
1. 매개 변수의 개수가 달라야 합니다.
1. 매개 변수의 순서가 달라야 합니다.




#차이점: 매개변수의 변화
overriding : 매개변수가 안바뀌고 외부형틀이 완전히 똑같다.
overloading : 매개변수가 변경되고 반환자료형도 변경할수있다.

공통점: 내부블록 수정가능, 기존메서드와 이름이 같음



package overloading.basic;
/*
 * 오버로딩(중복)-하나의 클래스 내부에 같은 이름을 가진 메서드를 여러개 선언할수 있게하는 문법
 * 	-부모꺼를 오버로딩할순 없는가?
 * 1.매개변수의 데이터타입이 달라야함
 * 2.매개변수의 순서가 달라야함
 * 3.매개변수의 개수가 달라야함
 */
public class Basic {
	void input(int a) {
		System.out.println("정수 1개가 입력됨");
	}
	void input(int i, int j) {
		System.out.println("정수 2개가 입력됨");
	}
	void input(String s) {
		System.out.println("문자열 1개가 입력됨");
	}
	void input(String s, double d) {
		System.out.println("문자열 1개, 실수형 1개가 입력됨");
	}
	void input(double x, String d) {
		System.out.println("실수형 1개, 문자열 1개가 입력됨");
	}
}



package overloading.basic;

public class MainClass {

	public static void main(String[] args) {
		Basic b = new Basic();
		b.input(5);
		b.input("하이");
		b.input(5,10);
		b.input(3.14,"하하");
		
		System.out.println();
	}

}


######################################################################################################














######################################################################################################
예제17)overriding

11일차의 goodcase안의 employee,main,person,student,teacher를 가져오고 아래처럼 출력되도록
오버라이딩하라(main은 손대지마라)

이름: 홍길동, 나이: 45
이름: 이순신, 나이: 23, 학번: 2018110033
이름: 강감찬, 나이: 44, 과목: 수학
이름: 신사임당, 나이: 33, 부서: 구매부

######################################################################################################




답:

package overriding.person;

/*
 * 데이터를 다른 클래스에게 물려주는 클래스를 부모클래스라고 합니다.
 * 상속을 사용할 시 데이터를 물려받는 클래스에게 부모클래스의 멤버변수,
 * 메서드가 상속됩니다.
 * 단, 생성자는 상속되지 않습니다.
 */
public class Person {
	
	String name;
	int age;
	
	String info() {
		return "이름: " + name + ", 나이: " + age;
	}
	
}



package overriding.person;

/*
 * 다른 클래스로부터 멤버변수와 메서드를 물려받는 클래스를
 * 자식 클래스라고 부릅니다. 
 * 자식 클래스의 이름 뒤에 extends라는 키워드를 쓰고 
 * 물려받을 클래스의 이름을 써줍니다.
 */
public class Student extends Person {
	String stuID;
	String info() {
		return "이름: " + name + ", 나이: " + age + ", 학번: " + stuID;
	}
	
}




package overriding.person;

public class Teacher extends Person {
	
	String subject;
	String info() {
		return "이름: " + name + ", 나이: " + age + ", 과목: " + subject;
	}
}




package overriding.person;

public class Employee extends Person {
	
	String department;
	String info() {
		return "이름: " + name + ", 나이: " + age + ", 부서: " + department;
	}
}




package overriding.person;

public class MainClass {

	public static void main(String[] args) {
		
		Person hong = new Person();
		hong.name = "홍길동";
		hong.age = 45;
		System.out.println(hong.info());
		
		Student lee = new Student();
		lee.stuID = "2018110033";
		lee.name = "이순신";
		lee.age = 23;
		System.out.println(lee.info());
		
		Teacher kang = new Teacher();
		kang.subject = "수학";
		kang.name = "강감찬";
		kang.age = 44;
		System.out.println(kang.info());
		
		Employee shin = new Employee();
		shin.department = "구매부";
		shin.age = 33;
		shin.name = "신사임당";
		System.out.println(shin.info());
		

	}

}









######################################################################################################
개념정리_this


#생성자를 메서드명으로 호출하는방법: 첫호출시밖에없음.
	-그다음부터는 this로
	-this(name, 1);
#생성자생성순서: 매개변수가 많을수록 모든 매개변수를 수용할수있는 생성자를 만든후 점점 매개변수를 줄여가는것이 좋다.
#f3을 누르면 만들어진곳으로 향할수있다.

* this

- this는 자기 자신 객체를 지정할 때 사용하는 키워드입니다.

- this. 을 사용하면 동일 클래스 내의 멤버(멤버변수, 메서드)를 참조할 수 있습니다.

- this()를 사용하면 생성자 내부에서 자신의 다른 생성자를 호출할 수 있습니다.

package this_.car;

public class Car {
	String model;
	int speed;
	Car(String model){
		this.model = model;
	}
	Car(){
		this("이름없음");
	}
	
	void accel(int speed) {
		if(this.speed >= 150) {
			System.out.println("속도를 더이상 올릴수 없습니다.");
		}else {
			this.speed = speed;
		}
	}
	void run(int maxSpeed) {
		for(int i=0;i<=maxSpeed;i+=30) {
			this.accel(i);
			System.out.printf("%s가 달립니다.(시속: %dkm/h)\n", this.model, 
					this.speed);
		}
	}
}

package this_.car;

public class MainClass {
	public static void main(String[] args) {
		Car myCar1 = new Car("람보르기니 아벤타도르");
		Car yourCar = new Car("아반떼 스포츠");
		
		myCar1.run(250);
		System.out.println("==============================");
		yourCar.run(130);
	}
}





* super

- super는 한단계 위 부모클래스의 객체를 지정할 때 사용하는 키워드입니다.

- super. 을 사용하면 부모클래스의 멤버를 참조할 수 있습니다.

- super()는 생성자 내부에서만 사용이 가능하며, 부모클래스의 생성자를 호출하는데 사용합니다.
	-생성자 외부에서는 super()로 부모클래스의 생성자를 불러오는것이안되고
	 대신에 외부에서 super.으로 메서드 혹은 변수에 접근하는건 가능하다.

package super_.person;
public class Student extends Person {
	String stuID;
	
	Student(String name, int age, String str){
		super(name, age);
		this.stuID = str;
//		this.name = name;
//		this.age = age;
		
	}
	
	String info() {
		//return "이름: " + name + ", 나이: " + age + ", 학번: " + stuID;
		return super.info() +" 학번: " + stuID;
	}
	
}

- 생성자의 첫 라인에는 반드시 this(), super()가 있어야 하는데 이를 기술하지 않으면 묵시적으로 super()가 삽입되어 부모클래스의 
기본 생성자를 자동으로 호출합니다.
	-즉 생성자 첫라인에 this()를 쓰면 super()를 안쓰고 this()를 안쓰면 자동으로 super()가 묵시적으로 삽입된다.

package super_.person;

public class Teacher extends Person {
	
	String subject;
	
	Teacher(){	//아래 주석의 teacher가 이놈의 생략형이다.
		
	}
	/*
	* Teacher(){	
	*	super(); //이렇게 묵시적으로 super가 삽입되니까 부모의 매개변수가없는 생성자를 호출하는데
	* }		//Person에서 기본생성자가 없으면 혹은 매개변수가없는 생성자가 없다면 이건 에러이고
	*			//위에 있는 teacher에도 super가 생략되있는것일뿐이니 위에도 에러가난다.
	*/
	
	String info() {
		return "이름: " + name + ", 나이: " + age + ", 과목: " + subject;
	}


- 생성자 내부에서 또다른 생성자를 호출할 때는 반드시 생성자 블록 내부의 첫 라인에 기술해야 합



-----------------------------------------------



######################################################################################################
















######################################################################################################
예제18)this, super

this_.person패키지에 있는  person student teacher를 가져온다.

아래로 했을때 출력이되도록하라
-이때 super를 모조리 이용해서하라
-super로 부모생성자를부르고
-this로 super대신 사용해라
	-this를쓰면 super가 쓰여지지않는다.
	-super로 다양한 매개변수를넣어봐라

package super_.person;

public class MainClass {

	public static void main(String[] args) {
		Student hong = new Student("홍길동", 13, "34");	
		System.out.println(hong.info());
		
		Teacher lim = new Teacher("임창정", 50, "음악");

		System.out.println(lim.info());
	}

}

이름: 홍길동, 나이: 13 학번: null	//부모꺼에서 자식객체 info 호출하여 출력된거
이름: 홍길동, 나이: 13 학번: 34	//자식꺼에서 지꺼 info 호출하여 출력된거
이름: 임창정, 나이: 50null		//부모꺼에서 자식객체 info 호출하여 출력된거
이름: 임창정, 나이: 50음악		//자식꺼에서 지꺼 info 호출하여 출력된거
######################################################################################################




답:



package super_.person;

/*
 * 데이터를 다른 클래스에게 물려주는 클래스를 부모클래스라고 합니다.
 * 상속을 사용할 시 데이터를 물려받는 클래스에게 부모클래스의 멤버변수,
 * 메서드가 상속됩니다.
 * 단, 생성자는 상속되지 않습니다.
 */
public class Person {
	
	String name;
	int age;
	
	Person(String name, int age){
		this.name = name;
		this.age = age;
		System.out.println(this.info());
	}
	Person(String name){	//생성자에서 this를 이용해 생성자호출
		this(name, 1);
//		this.name = name;
//		this.age = 1;
		//System.out.println(this.info());
	}
	Person(){
		this("이름없음", 1);
	}
	
	String info() {
		return "이름: " + name + ", 나이: " + age;
	}
	
}




package super_.person;

/*
 * 다른 클래스로부터 멤버변수와 메서드를 물려받는 클래스를
 * 자식 클래스라고 부릅니다. 
 * 자식 클래스의 이름 뒤에 extends라는 키워드를 쓰고 
 * 물려받을 클래스의 이름을 써줍니다.
 */
public class Student extends Person {
	String stuID;
	
	Student(String name, int age, String str){
		super(name, age);
		this.stuID = str;
//		this.name = name;
//		this.age = age;
		
	}
	Student(){
		this("이름없음", 1, "학번없음");	//여기는 super()가 없음 어차피 this가면 거기에
					//결국 super()를 만나기때문
	}
	
	String info() {
		//return "이름: " + name + ", 나이: " + age + ", 학번: " + stuID;
		return super.info() +" 학번: " + stuID;
	}
	
}



package super_.person;

public class Teacher extends Person {
	
	String subject;
	
	Teacher(String name, int age, String subject){
		super(name, age);
		this.subject=subject;
	}
	
	String info() {
		return super.info() + subject;
	}
}


