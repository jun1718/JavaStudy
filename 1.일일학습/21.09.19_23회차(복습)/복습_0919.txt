21.09.19_23회차(복습)
======================================================================================================
*복습
======================================================================================================






######################################################################################################
개념정리_인터페이스

* 인터페이스(Interface)
	-상속을해야 다형성구현이가능한데 관계없는녀석들끼리 다형성구현이 필요한경우 이때도 굳이 상속을해야하나? 이런생각으로 시작되어 생성
	-다형성과 추상클래스개념이 섞여있데

- 자바의 인터페이스는 객체의 사용 방법을 정의한 타입으로 객체의 교환성을 높여주기 때문에 다형성을 구현하는 매우 중요한 역할을 합니다.
- 인터페이스를 선언할 때는 interface 키워드를 사용하며, 클래스에서 인터페이스를 구현할 때는 
	클래스 이름 뒤에 implements 키워드를 사용하여 구현합니다.
- 클래스는 멤버변수, 생성자, 메서드를 구성 멤버로 가지지만 인터페이스는 상수와 추상메서드만을 구성멤버로 가집니다.
- 인터페이스는 데이터를 저장할 수 없기 때문에 데이터를 저장할 객체 또는 정적 변수를 선언할 수 없습니다.
- 따라서 인터페이스 선언된 변수는 public static final을 생략하더라도 컴파일 과정에서 자동으로 붙게 됩니다.
- 인터페이스의 메서드를 추상메서드 형식으로 선언하면 abstract를 붙이지 않더라도 자동으로 컴파일 과정에서 붙게 됩니다.
- 클래스가 상속 가능한 것처럼 인터페이스도 extends 키워드를 사용하여 인터페이스 간의 상속을 구현할 수 있으며. 
	다중 상속도 표현 할 수 있습니다.


//interface의 이름을 만들때는 앞에 I를 붙인다
	-자바든 클래스이든 .java로 확장자가 같기때문에 구분할게 있어야함

#자바에서 다형성을 가지기위한방법
-상속 : 자식(본인)객체가 부모클래스의 타입을 물려받을수있다.
-interface : 본인객체가 interface의 타입을 물려받을수 있다.


package inter.basic;

public interface Inter2 {
	int ABC = 10;
	void method2();
	
}

package inter.basic;

/*
 * 1.인터페이스를 사용하려면 클래스에서 해당 인터페이스를 구현해야 함.
 * 2.인터페이스를 구현하는 키워드는 implements임
 * 3.인터페이스를 상속과 달리 여러 인터페이스들을 동시에 다중구현할수있음
 * 4.인터페이스를 구현할때 인터페이스 내부에 선언된 추상메서드들을 반드시 전부 재정의해야함
 */



#interface특징
-단일상속으로 표현할수 없는 부분을 인터페이스로 채워넣을수 있다.
-인터페이스의 메서드는 추상메서드여야함
-인터페이스의 변수는 자동으로 상수가 됨
-인터페이스를 구현할때는 implements
-인터페이스를 여러개 implements할수 있다.
-인터페이스는 다른 인터페이스를 여러개 extends할수 있다.
	-인터페이스끼리 상속이 가능하다.
		-다중상속가능
-강제오버라이딩을 통해 기능의 명세를 위해 사용
######################################################################################################




<예시코드>


package inter.basic;

public interface Inter1 {
	//인터페이스에 변수를 서언하면 자동으로 상수 취급한다.
	//디폴트값이 상수라는 뜻
	public static final double INCH = 2.54;
//	double HI = 3.4;
	
	//인터페이스에 메서드를 선언하면 추상메서드로 취급됨
	//즉 객체를 만들수없다. 다형성을 만들기위한 거기때문에 그럼
	abstract void method1();
//	void method2();
}



package inter.basic;

public interface Inter2 {
	int ABC = 10;
	void method2();
	
}


public class InterClass implements Inter1, Inter2{
	public void method1() {
		System.out.println("Inter1의 메서드구현");
	}
	public void method2() {
		System.out.println("Inter2의 메서드구현");
	}
	public void method3() {
		System.out.println("클래스의 메서드호출!");
	}
}


package inter.basic;

public class MainClass {

//	public static final int a = 4;
	public static void main(String[] args) {
		//인터페이스는 객체를 생성할 수 없음
//		Inter1 i = new Inter1();
		InterClass ic = new InterClass();
		
		System.out.println(Inter1.INCH);
		System.out.println(Inter2.ABC);
//		System.out.println(ic.INCH);	//객체로도 접근가능하지만 저둘은 상수처리되었으니
//		System.out.println(ic.ABC); 	//객체가없어도 만들수있음으로 공용성있게 inter
										//face를 이용해서 호출한다.
										//즉 상수들을 모아놓고 사용할때 유용하게 취급됨
		System.out.println(ic.INCH);
		//ic.INCH; 이렇게 sys없이 선언만 해두면 에러남 상수특징인가?> 실험해보니 특징인듯(a)
		
//		System.out.println("a");
		
		ic.method1();
		ic.method2();
		ic.method3();

		/*
		 * -인터페이스 이름도 하나의 타입으로 취급가능
		 * -인터페이스를 통해 상속 없이도 다형성 구현 가능
		 * 	원래다형성 뜻 : 부모클래스의 타입을 자식객체가 사용할수있다.
		 */
		
		Inter1 i1 = ic;
		Inter2 i2 = new InterClass();
		
		
		i1.method1();
//		i1.INCH;
		i2.method2();
//		i2.ABC;
		
//		i2.method1();
//		i2.method3();
//		i2.INCH;
		
		
		InterClass icc = (InterClass)i1;
		InterClass icc2 = (InterClass)i2;
		
		icc.method1();
		icc.method2();
		icc.method3();
		icc2.method1();
		icc2.method2();
		icc2.method3();
		
		
		
	}

}































######################################################################################################
예제26)interface를 구현하고 상속을 이용해서 java의 단일상속의 부족한부분을 보완하기


package : inter.pet
0)IPet interface를 구현한 클래스로 만들어진 객체에 대해 돌본다는 메세지를 출력하는 기능 하나만 가진 class: PetShop
	-메서드명 : void carePat


1)class: Animal 
추상메서드 void eat 선언

2)class: Fish
추상메서드 void swim 선언

3)interface: Ipet
추상메서드 void play 선언

4)Animal을 상속받고 interface인 Ipet을 구현하는 클래스 : Dog, Cat
	-Animal만 상속받는 클래스 : Tiger(Ipet 구현 x)
-Dog
	-play(밖)와 eat(사료) 재정의
-Cat
	-play(방)와 eat(생선) 재정의
-Tiger
	-eat(고기) 재정의

5)Fish를 상속받고 interface인 Ipet을 구현하는 클래스 : GoldFish
	-Fish만 상속받는 클래스 : Shark(Ipet 구현 x)

-GoldFish
	-play(어항), swim(강)
-Shark
	-swim(바다) 

6)MainClass 
-Dog 객체 baduk 생성
-Cat 객체 nabi 생성
-Tiger 객체 hodol 생성

-다형성적용하여 이종모음 배열변수 animals 선언, 공간생성, 동시에 주소값 초기화
-향상된 포문을 이용해서 animals에 있는 객체들이 뭘 먹는지 각각 출력
-System.out.println("---------------------------"); 출력

-interface IPet배열타입 변수 pets 선언 및 공간생성(IPet공간 3개로 이루어진 공간)
-기본값으로 들어가있는 곳에 3개다 animals의 값들로 값 초기화 (안되는거 하나 확인)
-GoldFish() 공간만들고 안됐던 칸에 공간의 주소를 저장
-IPet 배열변수 pets가 저장하는 배열의 주소들을 참조하여 해당 객체들이 뭘하고 노는지 확인

-System.out.println("--------------------------");

-PetShop 객체 생성 후 내부 메서드 carePet의 매개변수를 이용한 다형성적용으로 baduk, nabi, GoldPish를 그대로 넣어도 이상없이
	뭘돌보는지 출력하도록 할것
	-그이후 nabi를 선언부로 올라가서 Animal으로 참조변수의 타입을 변경함으로 다형성 적용후 carePet메서드 정상작동되도록 해봐라
		-한마디로 upcasting 됐던거를 다시 downcasting 해보라는거임 downcasting을 안하면 carePet이 에러나니까.
package inter.pet;

public abstract class Animal {
	public abstract void eat();
}

package inter.pet;

public class Shark extends Fish{
	public void swim() {
		System.out.println("상어는 그어떤 바다에서도 수영가능합니다.");
	}
}

package inter.pet;

public abstract interface IPet {
	public abstract void play();
	
}

package inter.pet;

public class Cat extends Animal implements IPet{
	public void eat() {
		System.out.println("고양이는 생선을 먹습니다.");
	}
	public void play() {
		System.out.println("고양이는 집에서 놉니다.");
	}
}
package inter.pet;

public class Dog extends Animal implements IPet{
	public void eat() {
		System.out.println("개는 뼈다귀를 먹습니다.");
	}
	public void play() {
		System.out.println("개는 개집에서 놉니다.");
	}
}
package inter.pet;

public class Tiger extends Animal {
	public void eat() {
		System.out.println("호랑이는 밀림의 모든것을 먹습니다.");
	}
}
package inter.pet;

public class GoldFish extends Fish implements IPet{
	public void swim() {
		System.out.println("금붕어는 어항에서 수영합니다.");
	}
	public void play() {
		System.out.println("금붕어는 강에서 놉니다.");
	}
}
package inter.pet;

public class Shark extends Fish{
	public void swim() {
		System.out.println("상어는 그어떤 바다에서도 수영가능합니다.");
	}
}
package inter.pet;

public class PetShop {
	public void carePat(IPet pet) {
		if(pet instanceof Dog) {
			System.out.println("강아지를 돌봅니다.");
		}
		if(pet instanceof Cat) {
			System.out.println("고양이를 돌봅니다.");
		}
		if(pet instanceof GoldFish) {
			System.out.println("금붕어를 돌롭니다.");
		}
	}
}
package inter.pet;

public class MainClass {

	public static void main(String[] args) {
		Dog baduk = new Dog();
		Animal nabi = new Cat();
		Tiger hodol = new Tiger();
		
		Animal[] animals = {baduk, nabi, hodol};
		for(int i=0;i<animals.length;i++) {
			animals[i].eat();
		}
		
		System.out.println("--------------------");
		
//		IPet[] pets = {baduk, nabi, hodol};
		IPet[] pets = new IPet[3];
//		IPet hi = new Dog();
//		IPet hi = new IPet();
		//배열공간을 만들고 그공간의 타입을 정하는건 객체를만드는게 아니니 가능하고
		//객체를 만드는건 불가능하구나.
		
		pets[0] = baduk;
		pets[1] = (Cat)nabi;
//		pets[2] = hodol;
		
		GoldFish gold = new GoldFish();
		
		pets[2] = gold;
		
		for(IPet pet : pets) {
			pet.play();
		}
		
		System.out.println("--------------------");
		
		PetShop p = new PetShop();
		
		for(int i=0;i<pets.length;i++) {
			p.carePat(pets[i]);
		}
		
	}//main
}//class

######################################################################################################






답:



package inter.pet;

public interface IPet {
	public abstract void play();
}




package inter.pet;

public abstract class Animal {
	public abstract void eat();
}


package inter.pet;

public class Cat extends Animal implements IPet {

	public void play() {
		System.out.println("고양이는 방에서 놀아요~");
	}
	public void eat() {
		System.out.println("고양이는 생선을 먹어요~");
	}

}

package inter.pet;

public class Dog extends Animal implements IPet {
	
	public void play() {
		System.out.println("강아지는 밖에서 놀아요~");
	}
	public void eat() {
		System.out.println("강아지는 사료를 먹어요~");		
	}
	

}

package inter.pet;

public class Tiger extends Animal {

	public void eat() {
		System.out.println("호랑이는 고기를 먹어요.");
	}

}



package inter.pet;

public abstract class Fish {
	public abstract void swim();
}

package inter.pet;

public class GoldFish extends Fish implements IPet {

	
	public void play() {
		System.out.println("금붕어는 어항에서 놀아요~");

	}

	
	public void swim() {
		System.out.println("금붕어는 강에서 헤엄쳐요~");

	}

}


package inter.pet;

public class Shark extends Fish {
	public void swim() {
		System.out.println("상어는 바다에서 헤엄쳐요~");
	}

}



package inter.pet;

public class PetShop {
	public void carePet(IPet pet) {
		if(pet instanceof Dog) {
			System.out.println("강아지를 돌봅니다.");
		} else if (pet instanceof Cat) {
			System.out.println("고양이를 돌봅니다.");
		} else if (pet instanceof GoldFish) {
			System.out.println("금붕어를 돌봅니다.");
		}
	}
}




package inter.pet;

public class MainClass {

	public static void main(String[] args) {
		Dog baduk = new Dog();
		Animal nabi = new Cat(); //여기는 상관없지만 아래 pets[1]에서 에러남
			/*
			 * animal과 ipet은 상관이 없기때문에 아래에서 ipet이 animal부분을 담을수없음
			 * 애초에  nabi가 Cat으로 만들어지면 interface의 상수와 메소드부분을 가지고,
			 * 부모의 멤버와 생성자를 가진다. 그러다가 다형성으로 Cat이 Animal이 되면
			 * Animal클래스가 가진 멤버와 생성자밖에 못쓰고 Cat의 고유한 멤버는 사용할수없다.
			 * 이는 interface도 마찬가지다. 
			 */
		//위에 Animal nabi했을때 아래에서 에러안나게하려면 강제형변환해주면됨
		
		//Cat nabi = new Cat();
		
		Tiger hodol = new Tiger();
		
		Animal[] animals = {baduk, nabi, hodol};
		
		for(Animal a : animals) {
			a.eat();
		}
		System.out.println("---------------------------");
		IPet[] pets = new IPet[3];
		
		pets[0] = baduk;
//		pets[1] = nabi;
//		pets[1] = (Cat)nabi;
		pets[1] = (IPet)nabi;
		
		
//		pets[2] = hodol; //Tiger 클래스는 interpace로 IPet을 상속받지 않았다.그래서
			//다형성불가
//		pets[2] = (IPet)hodol;	//컴파일에러는 안뜨지만 런타임에러가 뜸
						//hodol이는 interpace가 구현되지 않았기 때문임
		
		//pets[2] = new Shark();
		
		pets[2] = new GoldFish();
		
		for(IPet pet: pets) {
			pet.play();
		}
		
		System.out.println("--------------------------");
		
		PetShop shop = new PetShop();
		shop.carePet(baduk);
		System.out.println("--------------------------");
		shop.carePet((IPet)nabi);
		shop.carePet(pets[2]);
	}

}











######################################################################################################
개념정리_예외처리

#error 종류
-serious error
	-컴퓨터사항이 낮은걸로 돌려서나는 에러라든지 프로그램의 문제가 아닌것으로 나는 오류
-mild error
	-프로그램의 문제
	-checked exception(대부분이 문법적에러, 컴파일에러라고도 한다)
	-unchecked exception(컴파일에는 문제없는데 실행하다가 오류가난경우, runtime 에러라한다)
	-위 2가지를 예외라한다.

-예외클래스
	object(클래스)

	Throwable(클래스)

error(클래스)	exception(클래스)
serious에대한	unchecked exception(runtimeException(클래스))
에러를 담고있는클래스	checked exception(컴파일에러와 관련된것을 담고있는 클래스들이 있음)


* 예외 처리(Exception)
	
- 에러에는 심각한 에러(serious error)와 가벼운 에러(mild error)가 있습니다. 
	심각한 에러는 시스템 상의 문제로 인한 에러로 개발자가 처리할 수 없는 에러를 말합니다. 
	가벼운 에러는 개발자가 코드를 통해 처리할 수 있는 에러를 말하며 이 방식을 예외처리라고 합니다.
- 예외에는 컴파일러 체크 예외와 실행 예외(Runtime Exception)가 있습니다.
- 컴파일러 체크 예외는 자바 소스를 컴파일하는 과정에서 예외 처리 코드를  검사하여 예외 처리 코드가 없다면 컴파일 오류가 발생합니다.
- 실행 예외는 컴파일하는 과정에서 예외처리 코드를 검사하지 않는 예외를 말합니다.
- 예외 처리는 컴파일 예외와 실행 예외에 대한 대처방법입니다.
- 예외 처리는 시스템 스스로 오류를 복구하는 것이 아니고 오류 발생 가능성이 있는 부분에 대한 처리를 미리 프로그래밍 해주는 것입니다.
- 프로그램에서 문제가 될만한 부분을 예상하여 사전에 "문제가 발생하면 이렇게 처리하라" 라고 프로그래밍 하는 것을 예외 처리라고합니다.



#예외처리 문법
	-사용가능 위치 : 생성자 내부 혹은 메서드 내부만 가능
		-클래스 내부에 직접적으로 사용 불가

try{
	예외발생 가능성이 있는 코드
} catch(Exception e){
	예외 발생시 실행할 코드
}

예외가 발생하면 트라이 종료 후 catch실행
예외가 발생안하면 케치실행안하고 트라이블록 실행

package exception.trycatch;

public class TryCatchExample1 {
	public static void main(String[] args) {
		
		int i = 10;
		int j = 0;	//0이면 반드시 에러남 즉 에러가능성이있는코드라서 예외 가능성이있다고함			
		
		System.out.println(i*j);
		try {
			System.out.println(i/j);
			//예외가 발생한곳에서 바로 catch로 가기때문에 아래 코드 실행안됨
			System.out.println("예외 발생시 이 텍스트는 출력되지 않음");
		}catch(Exception e) {
			System.out.println("0으로 나눌 수 없습니다.");
		}
		System.out.println(i+j);
		System.out.println(i-j);
	}
}




######################################################################################################
































######################################################################################################
개념정리_runtime exception


* 실행 예외(Runtime Exception)

- 실행 예외는 컴파일러가 예외 처리 코드를 체크하지 않기 때문에 오로지 개발자의 경험에 의해서 예외 처리 코드를 삽입해야 합니다.
- 만약 개발자가 실행 예외에 대해 예외처리 코드를 넣지 않았을 경우 해당 예외가 발생하면 프로그램은 곧바로 종료됩니다.
	-0으로 나누면 에러나는거같은걸 말하는거다. 실행중에 발생하는 예외
- 주요 실행 예외

1. NullPointerException
- 객체 참조가 없는 상태, 즉 null 값을 갖는 참조 변수로 객체 접근 연산자인 dot(.)를 사용했을 때 발생합니다.

2. ArrayIndexOutOfBoundsException
- 배열에서 인덱스 범위를 초과하여 사용할 경우 발생합니다.
	-배열의 범위를 넘어선 참조

3. NumberFormatException
- 문자열로 되어 있는 데이터를 숫자로 변경하는 경우에 발생합니다.

4. ClassCastException
- 형 변환은 부모 클래스와 자식 클래스간에 발생하고 구현 클래스와 인터페이스 간에도 발생합니다. 
이러한 관계가 아니라면 다른 클     래스로 타입을 변환할 수 없습니다.
- 상속관계나 인터페이스 관계가 없는 클래스들을 억지로 형 변환 할 경우 발생합니다.

5. ArithmeticException
-0으로 나누는경우 발생



######################################################################################################






































######################################################################################################
예제27)기본적인 RunTimeException case 



1. NullPointerException
- 객체 참조가 없는 상태, 즉 null 값을 갖는 참조 변수로 객체 접근 연산자인 dot(.)를 사용했을 때 발생합니다.


package exception.runtime_exception;

public class ? {
	public static void main(String[] args) {
		String a = "15";
		String b = "13";
		
		System.out.println(a+b);
		
		//문자열 수치변환
		//str -> int 변환
		//Integer.parseInt(문자열) 메서드 이용
		
		int i = Integer.parseInt(a);
		int j = Integer.parseInt(b);
		System.out.println(i+j);
	
		
		//parseInt는 문자열 내부에 순수한 정수가 들어있어야만 변환을 실행하며  정수값이 아닐
		//경우 NumberFortmatException이 발생함
		
		String str = "hello";
//		int e = Integer.parseInt(str);	//에러
		
		
	}
}



2. ArrayIndexOutOfBoundsException
- 배열에서 인덱스 범위를 초과하여 사용할 경우 발생합니다.
	-배열의 범위를 넘어선 참조

package exception.runtime_exception;

public class ? {

	public static void main(String[] args) {
		int[] arr = {3, 6, 9};
		System.out.println(arr[2]);
//		System.out.println(arr[3]); //분명 없는 인덱스를 []에 넣었는데도 checked
			//exception이 발생안함. 즉 컴파일에러가 안뜸 근데 이건 돌리면에러가남
		//이게바로 runtime error이면서 unchecked exception
	}

}




3. NumberFormatException
- 문자열로 되어 있는 데이터를 숫자로 변경하는 경우에 발생합니다.



package exception.runtime_exception;

public class ?{
	public static void main(String[] args) {
		String a = "15";
		String b = "13";
		
		System.out.println(a+b);
		
		//문자열 수치변환
		//str -> int 변환
		//Integer.parseInt(문자열) 메서드 이용
		
		int i = Integer.parseInt(a);
		int j = Integer.parseInt(b);
		System.out.println(i+j);
	
		
		//parseInt는 문자열 내부에 순수한 정수가 들어있어야만 변환을 실행하며  정수값이 아닐
		//경우 NumberFortmatException이 발생함
		
		String str = "hello";
//		int e = Integer.parseInt(str);	//에러
		
		
	}
}






4. ClassCastException
- 형 변환은 부모 클래스와 자식 클래스간에 발생하고 구현 클래스와 인터페이스 간에도 발생합니다. 이러한 관계가 아니라면 다른 클래스로 
	타입을 변환할 수 없습니다.
- 상속관계나 인터페이스 관계가 없는 클래스들을 억지로 형 변환 할 경우 발생합니다.
	-upcasting된 부모타입객체의 원객체(자식객체)가 아닌데 타 자식객체가 부모타입객체를 다시 downcating한 경우
		-부모가 같은 자식 a,b 객체중에 b객체참조변수에 부모로 upcasting한 주소 저장
		-b객체참조변수가 참조하는 객체를 a로 downcasting할때 이런 경우가 일어남 b에는 b와 부모꺼만있는데 a껄하면 당연히안되지
	-근데 착각하는경우: 다형성에서 upcasinting이 되기전에 downcasting될수는 없다.(부모객체로 만들고 자식타입으로 다형성구현불가)
			이건 문법으로 정해진것이다. up되기전에 down이 되면 다른검사없이 바로 컴파일에러를띠운다.
			그래서 이경우는 컴파일이 뜬다. 컴파일이뜨니까 어뭐야 이럼 실행예외가 아니잖아? 라고 생각하지 않길 바란다.


package exception.runtime_exception;

class Animal {}
class Dog extends Animal {}
class Cat extends Animal {}

public class ?{
	public static void main(String[] args) {
		Dog d = new Dog();
		Animal da = d;
		d = (Dog)da;
		System.out.println("타입변환 성공!");
		
		Animal c = new Cat();
	//	Cat c = new Cat();
//		Dog d2 = (Dog)c; 이건 컴파일에러가 잡아냄
		Dog d2 = (Dog)c;	//이건 컴파일에러가 안잡힘 animal이라는 동일부모 공통점이있어서
							//그런건가? 한번 업캐스팅이 된녀석을
							//다운캐스팅하는거니까 업캐스팅된게 Dog였는줄아는건가
						//Cat c를 하면 upcasting이 안일어났는데 downcasting
		//하려고해서 컴파일이 이건 잡는거고 두번째는 up후 down이고 부모가 같아서 그거까진
		//못잡아내나봄 컴파일이?
		System.out.println("타입변환");
		
	}
}




5.ArithmeticException
- 0으로 나누는경우 발생


package exception.trycatch;

public class TryCatchExample1 {
	public static void main(String[] args) {
		
		int i = 10;
		int j = 0;	//0이면 반드시 에러남 즉 에러가능성이있는코드라서 예외 가능성이있다고함			
		
		System.out.println(i*j);
		try {
			System.out.println(i/j);
			//예외가 발생한곳에서 바로 catch로 가기때문에 아래 코드 실행안됨
			System.out.println("예외 발생시 이 텍스트는 출력되지 않음");
		}catch(Exception e) {
			System.out.println("0으로 나눌 수 없습니다.");
		}
		System.out.println(i+j);
		System.out.println(i-j);
	}
}


######################################################################################################






답:


1. NullPointerException
- 객체 참조가 없는 상태, 즉 null 값을 갖는 참조 변수로 객체 접근 연산자인 dot(.)를 사용했을 때 발생합니다.

2. ArrayIndexOutOfBoundsException
- 배열에서 인덱스 범위를 초과하여 사용할 경우 발생합니다.
	-배열의 범위를 넘어선 참조

3. NumberFormatException
- 문자열로 되어 있는 데이터를 숫자로 변경하는 경우에 발생합니다.

4. ClassCastException
- 형 변환은 부모 클래스와 자식 클래스간에 발생하고 구현 클래스와 인터페이스 간에도 발생합니다. 이러한 관계가 아니라면 다른 클래스로 
	타입을 변환할 수 없습니다.
- 상속관계나 인터페이스 관계가 없는 클래스들을 억지로 형 변환 할 경우 발생합니다.

5. ArithmeticException
-0으로 나누는경우 발생





















######################################################################################################
개념정리_finally

try{
}catch(){

}finally{

}

finally 
-예외 발생여부와 관계없이 항상 실행할 코드
-입력후 객체반납 



* try~ catch~ finally
	
- 프로그램에서 예외가 발생했을 경우 프로그램의 갑작스러운 종료를 막고, 정상 실행을 유지할 수 있도록 처리하는 코드를 예외 처리  코드라고 합니다.
- try~ catch ~ finally 블록은 생성자 내부나 메서드 내부에서  작성되어 컴파일  예외와 실행  예외가 발생할 경우에  
예외  처리를  할 수  있게 해줍니다.
- try 블록에는 예외 발생 가능성이 있는 코드를 작성합니다. try 블록의 코드가 예외 발생 없이 정상 실행되면 catch 블록은 실행되지 않습니다.
- try 내부에서 예외가 발생하면 즉시 실행을 멈추고 catch 블록으로 이동하여 예외 처리 코드를 실행합니다.
- 예외 발생 여부와 상관없이 항상 실행할 내용이 있다면 finally 블록 내부에 실행 내용을 작성합니다.




* finally 구문이 실행되지 않는 경우

1. finally 구문 이전에 System.exit() 구문을 호출했을 시
1. 컴퓨터가 꺼져서 시스템이 멈추었을 시
1. finally 블록 내부에서 예외가 발생했을 시(내부에 try catch를 넣어줌)
######################################################################################################







































######################################################################################################
예제28)try~catch~finally

1)아래의 코드에서 예외처리하라
	-단, System.out.println("이문장은 항상 실행됨^_^"); 코드는 실행예외의 여부와 관계없이 실행되도록 하라

package exception.trycatch;

public class TryCatchExample2 {
	public static void main(String[] args) {
		String[] greetings = {"안녕", "헬로", "니하오"};
		int i =0;
		while(i<4) {
			System.out.println(greetings[i]);
			i++;
		}
		System.out.println("프로그램 정상실행종료!");
	}
}



* finally 구문이 실행되지 않는 경우

1. finally 구문 이전에 System.exit() 구문을 호출했을 시
1. 컴퓨터가 꺼져서 시스템이 멈추었을 시
1. finally 블록 내부에서 예외가 발생했을 시(내부에 try catch를 넣어줌)



package exception.trycatch;

public class TryCatchExample {
	public static void main(String[] args) {
		String[] greetings = {"안녕", "헬로", "니하오"};
		int i =0;
		try {
			while(i<4) {
				System.out.println(greetings[i]);			
				i++;
			}
		} catch (Exception e) {
			System.out.println("인덱스범위를 초과했습니다. 종료합니다.");
		} finally {
			System.out.println("i++은 안되도 이건 반드시 실행되지롱");
		}

	System.out.println("i의값: "+i);
	System.out.println("프로그램 정상실행종료!");
}
}


package exception.trycatch;

public class TryCatchExample {
	public static void main(String[] args) {
		String[] greetings = {"안녕", "헬로", "니하오"};
		int i =0;
		while(i<4) {
			try {
				System.out.println(greetings[i]);				
			} catch(Exception e) {
				System.out.println("배열의 참조범위를 벗어남");
				break;
			} finally {
				System.out.println("이문장은 항상 실행됨^_^");
				i++;
			}
			System.out.println("이문장도 항상 실행되지않나?");
		}
		
		System.out.println(i);
		System.out.println("프로그램 정상실행종료!");
	}
}


######################################################################################################






답:


package exception.trycatch;

public class TryCatchExample2 {
	public static void main(String[] args) {
		String[] greetings = {"안녕", "헬로", "니하오"};
		int i =0;
		while(i<3) {
			try {
				System.out.println(greetings[i]);				
			} catch(Exception e) {
				System.out.println("배열의 참조범위를 벗어남");
			} finally {
				System.out.println("이문장은 항상 실행됨^_^");
			}
			System.out.println("이문장도 항상 실행되지않나?");
			i++;
		}
		System.out.println("프로그램 정상실행종료!");
	}
}




















######################################################################################################
개념정리_MultiCatchException

* 다중 catch

- try 블록 내부는 다양한 종류의 예외가 발생할 수 있습니다. 예외가 여러 가지 발생한다면 다중 catch 블록을 작성하여 예외들을 처리합니다.
- 다중 catch 블록을 작성할 때 주의할 점은 상위 예외 클래스가 하위 예외 클래스보다 아래쪽에 위치해야 합니다.
- catch 블록은 위에서부터 차례대로 검색되므로 상위 예외 클래스의 catch 블록이 위에 있다면 하위 예외 클래스의 catch블록은 실행되지 않습니다.
- 자바 7 버전부터 하나의 catch 블록에서 여러 개의 예외를 처리할 수 있도록 기능이 추가되었습니다.
- catch() 괄호 안에 동일하게 처리하고 싶은 예외를 | 로 연결하면 됩니다. 이 방식을 사용할 때는 두 예외가 상속 관계가 있으면 안됩 니다.




######################################################################################################



































######################################################################################################
예제29)MultiCatchExample


0)멤버변수선언
String data1, data2;
int val1, val2;
int result;
Scanner sc;

1)데이터입력
"1번째 데이터 : "
"2번째 데이터 : "

위 형식으로 숫자로만 구성된 문자열 데이터 입력받아서 1번째 데이터는 data1, 2번째 데이터는 data2에 저장

2)데이터타입변경하여 숫자로 만들기
-위에 입력받은 데이터들을 각각 반환하여 int형 데이터로 변경한 후 아래의 관계로 val1, val2에 저장

data1 -> val1
data2 -> val2

3)사칙연산수행
-val1을 val2로 나누어 몫을 반환
-반환된값을 result에 저장

4)출력
-"val1 / val2 = result"의 형태로 출력
	-val1,val2,result의 자리는 실제 변수에서 반환된 값이 들어가야함

5)예외처리
ㄱ.예외발생 가능성 있는 구간 : 1), 3)
-1) : NumberFormatException
-3) : ArithmeticException

ㄴ.예외발생시 처리
-1) : "데이터를 숫자만 넣어주세요." 출력 후 다음 영역실행
-3) : "0으로 나눌 수 없습니다." 출력 후 다음 영역실행
-추가로 예기치 못한 에러발생시 :

ㄷ.반드시 수행해야할 것
-입력할때 사용한 객체자원 반환
-그밖의 자원반납

+예기치못한에러는 위에꺼 다실행하고 아래의 테스트코드 넣어서 실험해본다.(NullPointerException)

위치 : 3)아래에 넣음
String str = null;
str.charAt(0);

package exception.multi;

import java.util.Scanner;

public class MultiCatchExample {
	private String data1;
	private String data2;
	private int val1, val2;
	private int result;
	public Scanner scan = new Scanner(System.in);
	
	
	
	public void inputData() {
		System.out.print("1번째 데이터: ");
		data1 = scan.next();
		System.out.print("2번째 데이터: ");
		data2 = scan.next();			
	}

	public void changeInt() {
		val1 = Integer.valueOf(data1);
		val2 = Integer.valueOf(data2);
	}

	public void mod() {
		result = val1/val2;
	}

	public void printData() {
		mod();
		System.out.printf("%d / %d = %d\n", val1, val2, result);
		String str = null;
		str.charAt(0);
	}


}
package exception.multi;

public class MainClass {
	public static void main(String[] args) {
		MultiCatchExample multi = new MultiCatchExample();

		try {
			multi.inputData();
			multi.changeInt();
			multi.printData();
		} catch(ArithmeticException ar) {
			System.out.println("0으로 나눌 수 없습니다.");
			//ar.printStackTrace();
			System.out.println(ar.getMessage());
		} catch(NumberFormatException num) {
			System.out.println("숫자만 넣어야지! 문자넣으면 에러난다구!");
			System.out.println(num.getMessage());
		} catch(Exception e) {
			System.out.println("예기치 못한 에러 발생!! 긴급!! 긴급!!");
			System.out.println("긴급히 처리하겠습니다!!");
			System.out.println(e.getMessage());
		} finally {
			System.out.println("사랑해요");
			multi.scan.close();
		}
		
	}
}

######################################################################################################






답:







package exception.multy;

import java.util.Scanner;

public class MultiCatchExample {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		
		try {
			System.out.print("1번째 데이터: ");
			String data1 = sc.next();
			System.out.print("2번째 데이터: ");
			String data2 = sc.next();
			
			
			//NumberFormat 발생가능
			int val1 = Integer.parseInt(data1);
			int val2 = Integer.parseInt(data2);
			
			//Arithmetic 발생가능
			int result = val1/val2;
			System.out.println(val1 + " / " + val2 + " = " + result);
			
			//exception 클래스는 모든 예외를 일괄처리할 수 있음 다형성임
			//그래서 모든녀석 Exception이라해도되는데 다중처리를 할때는 자식클래스명칭을
			//명확하게 적어야함
		} catch(NumberFormatException e) {
			System.out.println("데이터를 숫자만 넣어주세요.");
		} catch(ArithmeticException e) {
			System.out.println("0으로 나눌 수 없습니다.");			
		} finally {
			sc.close();
		}
	}
}



















######################################################################################################
개념정리_throws

package exception.throws_;

public class ThrowsExample1 {
	public static String[] greetings = {"안녕", "니하오", "헬로"};
	public static void main(String[] args) {
		/*
		 * thorws가 붙어 있는 메서드나 생성자를 호출할때는 반드시 try블록 내부에서 호출하여
		 * 예외처리를 진행해야함
		 * 또는 다시 throws하여 예외처리를 다시 한 번 떠넘길수 있음
		 */
		try {			
			greet(3);
		} catch(Exception e) {
			e.printStackTrace();
			System.out.println("안녕");
			/*
			 * printStackTrace()는 예외발생 경로를 추적하는 메시지를 출력함
			 * 주로 개발과정에서 예외의 원인을 찾을때 유용하게 사용함
			 */
		}
		
		System.out.println("프로그램 정상종료!!");
		
		
	}
	/*
	 * 예외의 원인이 메서드 선언부가 아닌 호출부에 있을 경우 예외 처리를 메서드
	 * 호출자에게 떠넘기는 방식을 throws라 함
	 * 메서드나 생성자 호출 시 예외처리를 강요하고 싶을 때 사용합니다.
	 */
	public static void greet(int index) throws Exception{
		//내부에서 에러가나면 내가 잘못한게아니고 호출부에서 잘못이 있는거니까 
		//너 무조건 try해라  try안하면 나못쓴다. 
		//난 호출부의 상황에 따라 에러가 날 가능성이 높다. 그러니 안전하게 try안하면 안시켜준다.
//		try {
//			System.out.println(greetings[index]);
//		} catch(Exception e) {
//			System.out.println("배열의 참조범위를 벗어남!");
//		}
		System.out.println(greetings[index]);	
	}
}

######################################################################################################





















######################################################################################################
예제30)throws 떠넘기기

1)아래의 에러코드를 메인에서 최종적으로 해결하는 형태로 만드시오

package exception.throws_;

public class ThrowsExample2 {
	public void aaa(int n) throws Exception{
		System.out.println("aaa 호출!");
		int i = 10 / n;
		System.out.println("계산결과: "+i);
		System.out.println("aaa 실행종료!");
	}
	

	public void bbb() Exception{
		System.out.println("bbb 호출!");
		aaa(0);
		System.out.println("bbb 실행 종료!");
	}
	
	public void ccc() Exception{
		System.out.println("cccc 호출!");
		bbb();
		System.out.println("cccc 실행종료!");
	}
	
	public ThrowsExample2() Exception{
		System.out.println("생성자 호출!!");
		ccc();
		System.out.println("생성자 종료!!");
	}
	
	public static void main(String[] args) {		
		ThrowsExample2 te = new ThrowsExample2();
		e.printStackTrace();
		System.out.println("hihi");
	}
}

package exception.throws_;

public class ThrowsExample {
	
	
	public ThrowsExample() throws Exception{
		System.out.println("생성자 호출!!");
		ccc();
		System.out.println("생성자 종료!!");
	}
	
	
	
	public void aaa(int n) throws Exception{
		System.out.println("aaa 호출!");
		int i = 10 / n;
		System.out.println("계산결과: "+i);
		System.out.println("aaa 실행종료!");
	}
	

	public void bbb() throws Exception{
		System.out.println("bbb 호출!");
		aaa(0);
		System.out.println("bbb 실행 종료!");
	}
	
	public void ccc() throws Exception{
		System.out.println("cccc 호출!");
		bbb();
		System.out.println("cccc 실행종료!");
	}
	
	
	public static void main(String[] args) {		
		try {
			ThrowsExample te = new ThrowsExample();			
		} catch(Exception e) {
			System.out.println("머고이거!");
			System.out.println(e.getMessage());
		}
		
		System.out.println("hihi");
	}
}


######################################################################################################






답:

package exception.throws_;

public class ThrowsExample2 {
	public void aaa(int n) throws Exception{
		System.out.println("aaa 호출!");
		int i = 10 / n;
		System.out.println("계산결과: "+i);
		System.out.println("aaa 실행종료!");
	}
	

	public void bbb() throws Exception{
		System.out.println("bbb 호출!");
		aaa(0);
		System.out.println("bbb 실행 종료!");
	}
	
	public void ccc() throws Exception{
		System.out.println("cccc 호출!");
		bbb();
		System.out.println("cccc 실행종료!");
	}
	
	public ThrowsExample2() throws Exception{
		System.out.println("생성자 호출!!");
		ccc();
		System.out.println("생성자 종료!!");
	}
	
	public static void main(String[] args) {
		try {			
			ThrowsExample2 te = new ThrowsExample2();
		} catch(Exception e) {
			e.printStackTrace();
		}
		System.out.println("hihi");
	}
}


















######################################################################################################
개념정리_throw-throws, 사용자정의 예외




* 예외 강제 발생시키기(throw)

- 사용자가 직접 선언한 예외 클래스나 자바가 제공하는 예외 API에서 예외를 강제 발생시키려면 throw라는 키워드를 이용합니다.




package exception.throw_;

public class ThrowExample {
	public static int calcSum(int n) throws Exception{
	/*
	 * 프로그램이 throw구문을 만나는 순간 즉시 예외를 강제로 발생시키게 되며
	 * 해당 예외를 처리해줄 catch블록을 검색합니다.	
	 * throw가 메서드 내에 포함되는 순간 반드시 해당 메서드는 throws를 붙여야한다.
	 * 의식흐름: 야 이건 우리안에서 에러를 발생시키는건데 만약에 밖에서 try처리를 안해주면
	 * 우리때매 프로그램터지잖아!! 그러니까 안전빵으로 밖에서 try안하면 우리 사용도못하도록
	 * throws붙이자 안붙였다가 징계먹을수도있어!
	 */
		if(n<=0) {
//			System.out.println("매개값을 양수로 전해주세요");
			throw new Exception(); // 프로그램은 에러라생각하지않지만 개발자는에러라고
			//생각하는 상황에서 개발자가 강제로 에러를 발생시키는 것이 throw다.
		}
		int sum = 0;
		for (int i=1;i<=n;i++) {
			sum+=i;
		}
		return sum;
	}
	
	
	public static void main(String[] args) {
		
		try {
			int a = 2;
			System.out.println("성공!");
		} catch(Exception e) {
			System.out.println("에러가발생할수있는코드라했는데 발생하지 않는코드가 문제는 안생기네");
		}
		
		try {
			int result1 = calcSum(100);
			System.out.println("1~100까지의 누적합 : " + result1);
			
			int result2 = calcSum(-100);	//음수가 나오면안되는데 나와서 값이 0이됨
			//설계자의의도 n은 양수만와야함
			System.out.println("1~100까지의 누적합 : " + result2);			
		} catch(Exception e) {
			System.out.println("매개값을 양수로 전달해주세요.");
		}
		
	}
}



package exception.throw_;

public class Account {
	private long balance;
	public long getBalance() {
		return balance;
	}
	
	public void deposit(int money) {
		balance += money;
	}
	
	public void withDraw(int money) throws Exception{
		if(balance<money) {
			throw new Exception(); //잔액이 출금액보다 작으면 음수로처리하면되잖아?
							//즉 이블록에는 에러가 없어! 라고 얘기해서 해당 조건식만으로는
						//에러가안난다. 하지만 우리가 볼때 세상에 음수인돈은 없다.
			//그래서 개발자가 강제로 throw를 이용하여 에러를 발생시킨다. 그리고 해당되는것은
			//호출부에서 try로 받아야한다.
		}
		balance -= money;
	}
}







* 사용자 정의 예외

- 프로그램을 개발하다보면 자바 표준 API에서 제공하는 예외 클래스만으로 다양한 종류의 예외를 표현할 수 없습니다.
- 개발자가 만든 어플리케이션에서 자체적으로 생길 수 있는 예외는 개발자가 직접 예외 클래스를 정의해서 만들어야 합니다.
- 사용자 정의 예외 클래스는 일반 예외로 선언할 경우 Exception 클래스를 상속하여 사용하고, 
	실행 예외로 선언할 경우  RuntimeException 클래스를 상속하면 됩니다.
- 사용자 정의 예외 클래스의 이름은 Exception으로 끝나는 것이 좋습니다.



######################################################################################################
















######################################################################################################
예제31)throw - throws

1)아래의 상황에서 n은 음수가 못들어오도록 하라
	-return으로 종료할수없는 상황이니 강제로 에러를 발생시켜야한다.

package exception.throw_;

public class ThrowExample {
	public static int calcSum(int n) {
		int sum = 0;
		for (int i=1;i<=n;i++) {
			sum+=i;
		}
		return sum;
	}
	public static void main(String[] args) {
		
		int result1 = calcSum(100);
		System.out.println("1~100까지의 누적합 : " + result1);

		int result2 = calcSum(-100);	//음수가 나오면안되는데 나와서 값이 0이됨
		System.out.println("1~100까지의 누적합 : " + result2);
		
	}
}





package exception.throw_;

public class ThrowExample {
	public static int calcSum(int n) throws Exception{
		if(n<0) {
			throw new Exception();
		}
		int sum = 0;
		for (int i=1;i<=n;i++) {
			sum+=i;
		}
		return sum;
	}
	public static void main(String[] args) {

		try {
			int result1 = calcSum(100);
			System.out.println("1~100까지의 누적합 : " + result1);

			int result2 = calcSum(-100);	//음수가 나오면안되는데 나와서 값이 0이됨
			System.out.println("1~100까지의 누적합 : " + result2);
		} catch(Exception e) {
			System.out.println("음수는 안되~~용!!");
		}
	}
}
######################################################################################################






답:



package exception.throw_;

public class ThrowExample {
	public static int calcSum(int n) throws Exception{
	/*
	 * 프로그램이 throw구문을 만나는 순간 즉시 예외를 강제로 발생시키게 되며
	 * 해당 예외를 처리해줄 catch블록을 검색합니다.	
	 * throw가 메서드 내에 포함되는 순간 반드시 해당 메서드는 throws를 붙여야한다.
	 * 의식흐름: 야 이건 우리안에서 에러를 발생시키는건데 만약에 밖에서 try처리를 안해주면
	 * 우리때매 프로그램터지잖아!! 그러니까 안전빵으로 밖에서 try안하면 우리 사용도못하도록
	 * throws붙이자 안붙였다가 징계먹을수도있어!
	 */
		if(n<=0) {
//			System.out.println("매개값을 양수로 전해주세요");
			throw new Exception(); // 프로그램은 에러라생각하지않지만 개발자는에러라고
			//생각하는 상황에서 개발자가 강제로 에러를 발생시키는 것이 throw다.
		}
		int sum = 0;
		for (int i=1;i<=n;i++) {
			sum+=i;
		}
		return sum;
	}
	
	
	public static void main(String[] args) {
		
		try {
			int a = 2;
			System.out.println("성공!");
		} catch(Exception e) {
			System.out.println("에러가발생할수있는코드라했는데 발생하지 않는코드가 문제는 안생기네");
		}
		
		try {
			int result1 = calcSum(100);
			System.out.println("1~100까지의 누적합 : " + result1);
			
			int result2 = calcSum(-100);	//음수가 나오면안되는데 나와서 값이 0이됨
			//설계자의의도 n은 양수만와야함
			System.out.println("1~100까지의 누적합 : " + result2);			
		} catch(Exception e) {
			System.out.println("매개값을 양수로 전달해주세요.");
		}
		
	}
}




######################################################################################################
예제32) throw - throws 2

1)아래 코드에서 출금액이 계좌액보다 클경우 강제로 에러를 발생시키시오.
mainclass나 main메서드 없이 메서드내에서 구현만 하면됨



package exception.throw_;

public class Account1 {
	private long balance;
	public long getBalance() {
		return balance;
	}
	
	public void deposit(int money) {
		balance += money;
	}
	
	public void withDraw(int money) throws Exception{
		balance -= money;
	}
}



######################################################################################################


답:


package exception.throw_;

public class Account1 {
	private long balance;
	public long getBalance() {
		return balance;
	}
	
	public void deposit(int money) {
		balance += money;
	}
	
	public void withDraw(int money) throws Exception{
		if(balance<money) {
			throw new Exception(); //잔액이 출금액보다 작으면 음수로처리하면되잖아?
							//즉 이블록에는 에러가 없어! 라고 얘기해서 해당 조건식만으로는
						//에러가안난다. 하지만 우리가 볼때 세상에 음수인돈은 없다.
			//그래서 개발자가 강제로 throw를 이용하여 에러를 발생시킨다. 그리고 해당되는것은
			//호출부에서 try로 받아야한다.
		}
		balance -= money;
	}
}















######################################################################################################
예제33)사용자정의 예외클래스를 만들어 특정프로그램에서 날수있는 에러를 제어하기(개발자가 규정한 에러, 런타임에러는 아님 그래서 예외클래스가없음)

1)위 문제의 것을 복사하여 Account2를 만들고 위와같이 기본 에러만 발생시키는것이아니라 
 사용자정의 예외클래스를 만들어서 특정 메서드를(printStackTrace말고, 이것도해보긴해라) 통해 세부적인 규정한 에러의 내용을 볼수있도록 하라
-사용자정의 예외클래스로 객체를만들때 message를 직접넣는 생성자로 해보고
 기본생성자로 해라. 출력결과는 같게 하라.

package exception.throw_;

public class Account2 {
	private long balance;
	public long getBalance() {
		return balance;
	}
	
	public void deposit(int money) {
		balance += money;
	}
	
	public void withDraw(int money) throws BalanceInsufficientException{
		if(balance<money) throw new BalanceInsufficientException("아잉 출금액이넘커!");
		balance -= money;
	}
}
package exception.throw_;

public class BalanceInsufficientException extends Exception{
	public BalanceInsufficientException() {
		System.out.println("잔고가 부족합니다.");
	}
	public BalanceInsufficientException(String message) {
		super(message);

	}
}
package exception.throw_;

public class MainClass {
	public static void main(String[] args) {
		Account2 a1 = new Account2();
		
		a1.deposit(1000);
		System.out.println(a1.getBalance());
		
		try {
			a1.withDraw(2000);
		}catch(Exception e) {
			System.out.println(e.getMessage());
		}
		System.out.println(a1.getBalance());
	}
}


######################################################################################################


답:


package exception.throw_;
/*
 * 사용자정의 예외클래스를 만들려면 Exception클래스나 RUntimeException 클래스를
 * 상속해야한다.
 */
public class BalanceInsufficientException extends Exception{
	/*
	 * 일반적으로 사용자 정의 예외 클래스를 만들때는 
	 * 기본 생성자와 예외 원인 메시지를 매개값으로 받는 생성자를
	 * 선언함 
	 * 매개값은 Exception의 생성자로 보내야함
	 */
	public BalanceInsufficientException() {
		super("잔고가 부족합니다.기본생성자");
	}
	public BalanceInsufficientException(String message) {
		super(message);
	}
}


package exception.throw_;
/*
 * account1에서 exception으로 throwthrows를 이용해 강제에러를 발생시켰는데
 * 개발자가 더 완벽하게 에러를 띄우고 싶다.
 */
public class Account2 {
	private long balance;
	public long getBalance() {
		return balance;
	}
	
	public void deposit(int money) {
		balance += money;
	}
	
	public void withDraw(int money) throws BalanceInsufficientException{
		if(balance<money) {
			//throw new BalanceInsufficientException("잔고가 부족합니다.");
			throw new BalanceInsufficientException();
		}
		balance -= money;
	}
}

package exception.throw_;

public class MainClass {

	public static void main(String[] args) {
		Account2 acc = new Account2();
		
		acc.deposit(10000);
		System.out.printf("입금 후 잔액: %d원\n", acc.getBalance());
		
		try {			
			acc.withDraw(70000);
		} catch(BalanceInsufficientException e) {
			//e.printStackTrace();
			/*
			 * -예외 클래스가 제공하는 getMessage() 메서드는 예외의 원인 메시지를 String 
			 * 타입으로 리턴함.
			 * 자바 표준 API에서 제공하는 다양한 예외클래스들은 각각의 예외 원인 메시지가
			 * 기본적으로 객체안에 저장되어있음(기본생성자안에 super로보낼 메세지에 기본값으로
			 * 정해두는 거임 
			 */
			System.out.println(e.getMessage());
		}
		System.out.printf("출금 후 잔액 :  %d원\n", acc.getBalance());
	}

}





















################################################################################################
개념정리_API


* JAVA API(Application Programming Interface)

- API는 라이브러리라고 부르며 프로그램 개발에 자주 사용되는 클래스 및 인터페이스의 모음을 말합니다.
- 자바 표준 API 문서 주소: https://docs.oracle.com/javase/8/docs/api
	-구글에 java api라 검색하면나옴

* java.lang 패키지

- java.lang 패키지는 자바 프로그램의 기본적인 클래스들을 담고 있는 패키지입니다. 
	그렇기 때문에 java.lang 패키지에 있는 클래스와 인터페이스는 import 구문 없이 사용할 수 있습니다.

- java.lang 패키지 주요 클래스

1. Object: 자바 클래스의 최상위 클래스
2. System: 표준 입력장치(키보드)로부터 데이터를 입력받거나 표준 출력장치(모니터)로 출력하기 위해 사용
3. Class: 클래스를 메모리에 로딩할 때 사용
4. String: 문자열을 저장하고 문자열의 여러 가지 정보를 얻을 때 사용
5. StringBuffer, StringBuilder: 문자열을 저장하고 내부 문자열을 조작할 때 사용
6. Math: 수학 함수를 이용할 때 사용
7. Wrapper(Byte, Short, Integer, Long, Float, Double, Boolean, Character)
	: 기본 데이터 타입의 객체를 만들 때 사용

* Object 클래스

- 클래스를 선언할 때 extends 키워드로 다른 클래스를 상속하지 않으면 묵시적으로 Object 클래스를 상속하게  됩니다.  
	따라서 모든 자바의 클래스는 Object 클래스의 자식이거나 자손클래스입니다.
- 모든 클래스가 Object를 상속하기 때문에 Object의 메서드는 모든 클래스에서 사용이 가능합니다.


################################################################################################











######################################################################################################
예제34) 자바 표준api인 lang 라이브러리의 대표 클래스


1.Object : 자바 클래스의 최상위 클래스
2.System : 표준 입력장치(키보드)로부터 데이터를 입력받거나 표준 출력장치(모니터)로 출력하기 위해 사용
3.Class : 클래스를 메모리에 로딩할 때 사용
4.String : 문자열을 저장하고 문자열의 여러 가지 정보를 얻을 때 사용
5.StringBuffer ,StringBuilder : 문자열을 저장하고 내부 문자열을 조작할 때 사용
6. Math: 수학 함수를 이용할 때 사용
7. Wrapper(Byte, Short, Integer, Long, Float, Double, Boolean, Character)
	: 기본 데이터 타입의 객체를 만들 때 사용

######################################################################################################


답:





1. Object: 자바 클래스의 최상위 클래스
2. System: 표준 입력장치(키보드)로부터 데이터를 입력받거나 표준 출력장치(모니터)로 출력하기 위해 사용
3. Class: 클래스를 메모리에 로딩할 때 사용
4. String: 문자열을 저장하고 문자열의 여러 가지 정보를 얻을 때 사용
5. StringBuffer, StringBuilder: 문자열을 저장하고 내부 문자열을 조작할 때 사용
6. Math: 수학 함수를 이용할 때 사용
7. Wrapper(Byte, Short, Integer, Long, Float, Double, Boolean, Character)
	: 기본 데이터 타입의 객체를 만들 때 사용











################################################################################################
개념정리_API_system





* System 클래스

- 자바 프로그램은 운영체제상에서 바로 실행되는 것이 아니라 JVM  위에서  실행됩니다. 
	따라서 운영체제의 모든 기능을 자바 코드로 직접 접근하기는 어렵습니다.
- 하지만 System 클래스를 이용하면 운영체제의 일부 기능을 이용할 수 있습니다. 
	프로그램 종료, 키보드로 입력, 모니터로 출력, 메모 리 정리, 현재 시간 읽기 등이 가능합니다.
- System 클래스의 모든 멤버는 static으로 구성되어 있어 클래스 이름으로 바로 접근이 가능합니다.

- System 클래스 주요 메서드
1. exit(): 현재 실행하고 있는 프로세스를 강제 종료시킵니다. 정상 종료일경우 매개값으로 0을  주고, 비정상 종료인경우 0 이외에
 다른 값을 줍니다.

2. currentTimeMillis(), nanoTime()
: 컴퓨터의 시계로부터 현재 시간을 읽어서 밀리세컨드(1/1000초) 단위와 나노세컨드(1/10^9초)단위의 long값을 리턴합니다. 
주로 프 로그램의 실행 소요 시간 측정으로 성능을 테스트할 때 사용합니다.

package api.lang.system;

public class SystemTime {

	public static void main(String[] args) {
		/*
		 * currentTimeMillis()와 nanoTime() 메서드는 1970년 1월 1일
		 * 자정부터 현재까지의 시간을 초로 변환한
		 * 에폭시간을 각각 long타입의 밀리초(1/1000), 나노초(1/10^9)로 리턴함
		 */
		
		long start = System.currentTimeMillis();
		long sum =0;
		for(long i=1;i<1000000L;i++) {
			sum += i;
		}
		long end = System.currentTimeMillis();
		
		System.out.println("계산에 소요된 시간 : "+(end-start)*0.001+"초");
		
	}

}


3. getProperty(): JVM이 시작할 때 자동 설정되는 시스템의 속성값을 구합니다.
	-표준 자바 api문서에서 찾아봐라 키값확인

4. gc(): Garbage Collector를 실행시킵니다. (좀더 메모리해제를 빨리 하기 위한 것)
자바는 c처럼 포인터를 사용자가 사용불가(객체데이터를 메모리에서 지워버릴 수 없음 기다려야함) 
힙영역의 쓰레기 영역 데이터를 빨리 지우라고 독촉할 수 있음(c처럼 즉시 안됨)
	-과거 안드로이드일때는 자바로 코딩할때 계속 독촉함. 하드웨어가 소프트웨어를 못버티니 계속 메모리에 자원을 반납해야함
	-지금은 이정도아님
################################################################################################











######################################################################################################
예제35) lang 라이브러리 시간측정


1)표준 라이브러리 lang의 클래스 2개를 이용해서 1에서부터 1000까지의 누적합계를 구하는 연산속도를 측정하시오.
	-출력할때는 초단위로 출력하시오
package java_.lang.system;

public class CurrentTimeExample {
	public static void main(String[] args) {
		
		
		int sum=0;
		
		double start = System.currentTimeMillis();
		for(int i=1;i<=1000000000;i++) {
			sum += i;
		}
		double end = System.currentTimeMillis();
		
		System.out.println("연산시간: "+(end-start)*0.001);
	}
}

######################################################################################################


답:






package api.lang.system;

public class SystemTime {

	public static void main(String[] args) {
		/*
		 * currentTimeMillis()와 nanoTime() 메서드는 1970년 1월 1일
		 * 자정부터 현재까지의 시간을 초로 변환한
		 * 에폭시간을 각각 long타입의 밀리초(1/1000), 나노초(1/10^9)로 리턴함
		 */
		
		long start = System.currentTimeMillis();
		long sum =0;
		for(long i=1;i<1000000L;i++) {
			sum += i;
		}
		long end = System.currentTimeMillis();
		
		System.out.println("계산에 소요된 시간 : "+(end-start)*0.001+"초");
		
	}

}











################################################################################################
개념정리_API_String


* String 클래스

- String은 생성자를 사용해서 객체를 만들 필요 없이 기초 데이터를 사용할 때처럼 바로 초기화해서 사용할 수 있습니다.
- String 클래스의 주요 메서드

1. charAt(): 특정 인덱스의 글자를 리턴.
2. indexOf(): 문자열에서 특정문자의 시작 인덱스 값을 반환합니다. 만약 주어진 문자열이 포함되어 있지 않으면 -1을 리턴합니다.
3. length(): 문자열의 길이를 알려줍니다.
package api.lang.string;

public class StringIndexOf {
	public static void main(String[] args) {
		String sbj = "자바 프로그래밍"; //8글자
		//문자열의 문자개수(길이)를 리턴하는 length()
		
		System.out.println("sbj의 길이: "+ sbj.length());
		
		//문자열의 특정 인덱스 문자를 추출하는 charAt()
		System.out.println(sbj.charAt(6));
		
		//문자열의 특정 문자의 인덱스 번호를 리턴하는 indexOf()
		int location = sbj.indexOf("프");
		System.out.println("프의 인덱스번호 : "+location);

	}
}


4. replace(): 특정 문자열을 변경합니다.
package api.lang.string;

public class StringReplace {
	public static void main(String[] args) {
		String str1 = "자바는 객체지향 언어입니다. 자바는 풍부한 API를 지향합니다.";
		String str2 = str1.replace("자바는 ", "JAVA");
		System.out.println(str1);
		System.out.println(str2);
	}
}


5. substring(): 인덱스를 기준으로 그 앞의 문자열을 잘라줍니다. 만약 매개값으로 인덱스를 2개 주면 처음 매개값 이상 두 번째 매개    
      값 미만의 문자열을 제외하고 나머지를 삭제합니다.

package api.lang.string;

public class StringSubstring {
	/*부분문자*/
	//단일문자 : charAt();
	
	public static void main(String[] args) {
		String ssn = "040404-3412343";
		System.out.println(ssn);
		
		
		/*
		 * substring() 메서드에 매개값으로 인덱스를 1개 지정하면
		 * 해당 인덱스부터 끝까지의 문자를 추출함
		 */
		String last = ssn.substring(7);
		System.out.println(last);
		
		
		/*
		 * substring()메서드에 2개를 입력하면 1번째 매개변수부터 2번째매개변수 미만의 범위까지
		 * 문자를 출력해라는 거임
		 */
		String first = ssn.substring(0, 6); //0번인덱스 이상 6번인덱스 미만
		System.out.println(first);
		
	}
}



6. toUpperCase():  문자열을  대문자로 치환합니다.
7. toLowerCase():  문자열을  소문자로 치환합니다.
8. trim(): 문자열의 앞, 뒤 공백을 제거합니다.
9. equals(): 문자열의 값을 비교합니다.
10. valueOf(): 기본 데이터 타입의 값들을 문자열로 변환합니다.
package api.lang.string;

public class StringValueOf {
	public static void main(String[] args) {
		int a = 10;
		double b = 8.79;
		System.out.println(a+b);
		
		String str1 = String.valueOf(a);
		String str2 = String.valueOf(b);
		System.out.println(str1+str2);
		//String.valueof(정수형데이터) 반대관계
		//Integer.parseInt(문자열)
	}
}




* String 클래스의 단점

- String 클래스는 아주 많이 쓰이고 좋은 기능들을 많이 가지고 있지만 메모리를 과소비한다는 문제점이 있습니다.
- String 객체는 처음 초기화된 데이터에 변화가 생기면 기존 객체를 재활용하지 않고 새로운 객체를 생성합니다.

################################################################################################













######################################################################################################
예제36) String 메서드

api.lang.string 패키지를 만들고 아래 클래스를만들어서 내부에 들어갈 함수들을 분류하고 뜻을적은 뒤 해당 메서드들을 사용해봐라

1)StringIndexOf
	str.charAt(0)
	str.indexOf("hi")
	str.length()
2)StringReplace
	str.replace("hi","bye");
3)StringSubstring
	str.substring(3); 3이상~끝까지 리턴
	str.substring(0~6); 0이상6미만 리턴
4)StringValueOf
	int a = 3;
	String.valueOf(a);

그밖에 써볼 메서드
toUpperCase
	str.toUpperCase();
	str.toLowerCase();
toLowerCase
equals : 문자열비교
	str.equals(str2);
trim : 문자열의 앞뒤 공백제거
	str.trim();


package java_.lang_.String_;



public class StringExample {

	public static void main(String[] args) {
//		int a = 3;
//		String str = "45";
//		
//		int a1 = Integer.valueOf(str);
//		
//		System.out.println(a1+1);
//		
//		String hi = String.valueOf(a);
//		
//		System.out.println(hi+1);
//
//		
//		int a2 = Integer.parseInt(str);
//		System.out.println(a2+1);
//		
//		
		String str = "012345678";
		
		System.out.println(str.substring(6));
		System.out.println(str.substring(0,6));
		
		System.out.println(str.indexOf("7"));
		System.out.println(str.replace("3", "iloveyou"));
		
		
		
		String str2 = " dd                            ";
		
		System.out.println(str2.trim());
	}

}

######################################################################################################


답:


1)StringIndexOf
	charAt() : 특정인덱스의 문자반환
	indexOf() : 문자열에서 특정 문자의 인덱스값을 반환
	length() : 문자열의 길이를 반환
2)StringReplace
	replace() : 문자열의 부분 또는 전체 문자열에 해당하는 부분을 다른 문자열로 변경가능
3)StringSubstring
	substring() : 특정 인덱스 앞의 문자열을 모두 자른 후 남은걸 반환함, 
			전달인덱스가 2개인경우 1번째인자이상 2번째인자미만인덱스까지 잘라서 반환함
4)StringValue
	valueOf() : 기본타입의 값들을 문자열로 바꿈























################################################################################################
개념정리_StringBuilder



* String 클래스의 단점

- String 클래스는 아주 많이 쓰이고 좋은 기능들을 많이 가지고 있지만 메모리를 과소비한다는 문제점이 있습니다.
	-내용을바꿀때마다 새로 공간을만들고 버려지는 공간이 생기기때문에 자주 바꿀수록 과소비가 크다.
		-이걸 보완하는게 stringbuilder,stringbuffer이다.
- String 객체는 처음 초기화된 데이터에 변화가 생기면 기존 객체를 재활용하지 않고 새로운 객체를 생성합니다.
*  StringBuilder, StringBuffer

- String 클래스의 단점인 새로운 객체를 생성하는 문제로 인해 속도가 느려지는 현상이 발생하기 때문에 이 문제를 해결하기 위해 
	속도적인 측면에서 개선된 StringBuffer와 StringBuilder를 사용합니다.

- StringBuilder 클래스의 주요 메서드

1. append(): 기존 문자열의 뒤에 문자열을 추가합니다.
2. insert(): 특정 위치에 문자열을 추가합니다.
3. delete(): 문자열을 삭제합니다.
4. deleteCharAt():  특정 인덱스의 문자 하나를   삭제합니다.
5. replace():  문자열의  일부분을  다른  문자열로 대체합니다.
6. setCharAt(): 문자열에서 주어진 index의 문자를 다른 문자로 대체합니다.
7. toString(): StringBuilder 객체의 값을 문자열로 반환합니다.

################################################################################################














######################################################################################################
예제37) String객체와 StringBuilder객체의 속도차이 확인
1)아래에 String 클래스의 함수를 나열하고 그 아래에는 Builder함수의 뜻에 대칭되는 메서드들을 나열하라.
	-그후 BUilder의 메서드를 한번식 수행해봐라

String


String Builder
1. append: 기존 문자열의 뒤에 문자열을 추가합니다.
2. insert: 특정 위치에 문자열을 추가합니다.
3. delete: 문자열을 삭제합니다.
4. deleteCharAt():  특정 인덱스의 문자 하나를   삭제합니다.
5. replace():  문자열의  일부분을  다른  문자열로 대체합니다.
6. setCharAt(3): 문자열에서 주어진 index의 문자를 다른 문자로 대체합니다.
7. toStirng: StringBuilder 객체의 값을 문자열로 반환합니다.

package java_.lang_.stringbuilder;

public class StringBuilderExample {

	public static void main(String[] args) {
		StringBuilder str = new StringBuilder("i love you!");
		str.append(" hi");
		
		str.insert(1, "hoo");
		
		
		System.out.println(str);
		str.delete(0, 5);
		

		System.out.println(str);
		str.deleteCharAt(0);
		System.out.println(str);
		
		str.insert(0, "d");
		System.out.println(str);
		
		System.out.println(str.length());
		
		str.replace(0, 3, "hi");
		System.out.println(str);
		
		str.setCharAt(3, 'h');
		System.out.println(str);
		
		String st = "      hi      ";
		System.out.println(st);
		st = st.toUpperCase();
		
		System.out.println(st);
		
		st = st.replace("H", "nn");
		System.out.println(st);
		
		st = st.trim();
		System.out.println(st);
		
	}

}

######################################################################################################


답:


1. append(): 기존 문자열의 뒤에 문자열을 추가합니다.
2. insert(): 특정 위치에 문자열을 추가합니다.
3. delete(): 문자열을 삭제합니다.
4. deleteCharAt():  특정 인덱스의 문자 하나를   삭제합니다.
5. replace():  문자열의  일부분을  다른  문자열로 대체합니다.
6. setCharAt(): 문자열에서 주어진 index의 문자를 다른 문자로 대체합니다.
7. toString(): StringBuilder 객체의 값을 문자열로 반환합니다.














######################################################################################################
예제38) String객체와 StringBuilder객체의 속도차이 확인

1)A가 초기화된 문자열 2개(타입은 각각 String, SB로 만들고) 십만번동안 A를 추가했을때 누가더 빠른가?
초단위로 나타낼것
package java_.lang_.stringbuilder;

public class StringStringBuilderExample {
	public static void main(String[] args) {
		String str = "hi";
		
		StringBuilder str2 = new StringBuilder("hi");
		
		System.out.println(str);
		System.out.println(str2);
		
		long start = System.currentTimeMillis();
		for(int i=0;i<100000;i++) {
			str+="hi";
		}		
		long end = System.currentTimeMillis();
		
		
		System.out.println("string의 연산시간: "+(end-start)*0.001);
		start = System.currentTimeMillis();
		for(int i=0;i<100000;i++) {
//			str2.append("hi");
			str2.insert(i+1, 'A');
		}		
		end = System.currentTimeMillis();
		System.out.println("stringBuilder의 연산시간: "+(end-start)*0.001);
	}
}

######################################################################################################


답:



package api.lang.stringB;

public class StringTest {
	
	public static void main(String[] args) {
		String str = "A";
		
		long start = System.currentTimeMillis();
		
		for(int i=0;i<100000;i++) {
			str+='A';
		}
		long end = System.currentTimeMillis();
		
		System.out.println("String 객체의 속도측정: " + (end-start)*0.001);
		
		
		StringBuilder sb = new StringBuilder("A");
		
		start = System.currentTimeMillis();
		for(int i=0;i<100000;i++) {
			sb.insert(i+1, 'A');
		}
		end = System.currentTimeMillis();
		
		System.out.println("StringBuilder 객체의 속도측정: " + (end-start)*0.001);
	}

}












################################################################################################
개념정리_java.lang 패키지_Math, wrapper




* Math 클래스

- Math 클래스는 수학 계산에 사용할 수 있는 메서드들을 제공합니다.
- Math 클래스가 제공하는 메서드는 모두 정적 메서드이므로 Math 클래스 이름으로 바로 사용이 가능합니다.
- Math 클래스 주요 메서드
	-공식문서에 훨씬많은 메서드가 있다.

1. abs(): 절대값을 구함.
2. ceil(): 올림값을 구함.
3. floor(): 내림값을 구함.
4. max(): 수를 비교하여 최대값을 구함.
5. min(): 수를 비교하여 최소값을 구함.
6. random(): 랜덤값을 구함(0.0 <= 값 < 1.0)
7. rint(): 현재 수에서 가까운 정수를 실수형태로 구함.
8. round(): 반올림값을 구함.




* Wrapper 클래스
	-객체지향언어는 원래 기본타입이없다고한다.
	-근데 자바는 c처럼 원시타입이있다.
	-메모리에 포장해서 관리하는게아니라 stack영역에 바로 저장하는것을 뜻한다고 하네
	-그래서 완벽한, 순수한 객체지향이 아니라고 한다.
	-기본데이터타입 8개를 클래스로 안만들어놨기때문에 상속해서 다형성을 구현할수없다.
		-객체로 다형성적용해서 업케스팅하는걸 기본타입은 불가능하다는 것 
		-만약 얘도 클래스로 만들었으면 Object로 상속하면되는데 그게 불가능
	-그래서 기본 데이터타입을 wrapper클래스로 포장했다.
		-이렇게하면 완벽한 다형성구현이 된다. 완벽한 객체지향

- 자바는 기본 타입의 값을 갖는 객체를 생성할 수 있습니다.
- 이러한 객체를 포장(Wrapper) 객체라고 하는데 그 이유는 기본 타입의 값을 객체 내부에 두고 포장하기 때문입니다.
- 포장 객체의 특징은 포장하고 있는 기본 타입의 값은 외부에서 변경할 수 없습니다. 만약 변경하고 싶으면 새로운 포장 객체를 생성 해야 합니다.
- 기본 타입의 값을 포장 객체로 만드는 과정을 박싱(Boxing)이라 하며 포장 객체에서 
	기본 타입의 값을 얻어내는 과정을 언박싱 (Unboxing)이라 합니다.
- 포장 클래스의 주요 용도는 기본 타입의 값을 박싱해서 포장 객체로 만드는 것이지만, 
	문자열을 기본 타입 값으로 변환할 때도 많이 사용합니다. 대부분의 포장 클래스는 
	"parse+기본타입" 명으로 되어있는 정적 메서드를 제공합니다.
- Byte, Short, Integer, Long, Float, Double, Boolean, Character

package api.lang.wrapper;

import java.util.Arrays;

public class Boxing {
	public static void main(String[] args) {
		int a = 100;
		double b = 3.51;
		char c = 'H';
		boolean d = false;
		
		//Boxing: 기본타입의 데이터를 객체타입으로 변환
		Integer val1 = new Integer(a);
		Double val2 = new Double(b);
		Character val3 = new Character(c);
		Boolean val4 = new Boolean(d);
		Byte val5 = new Byte((byte)75);
		String val6 = new String("hello");
		
		Object[] arr = {val1,val2,val3,val4,val5,val6};
		//object에 int,double,char,boolean을 다 정의해 놓았단 말인가?
		//그렇지않으면 val1은 object의 메서드와 변수는 쓸수있어도 본인의 변수는쓰지못한다.
		//이론상 object에 기본형타입으로 변수를 만들어놓았고 그녀석을 super를이용해서 자식객체
		//를 만들때 들어온 인자값을 부모클래스에게 보내서 부모클래스의 변수가 찼다고 보는게 맞는듯
		//그래서 객체 하나당 하나의 값밖에 가질수 없고 String은 내부에서 char를 많이 받을수있게
		//char형 배열을 만들어놓은것으로 추측됨
		
		System.out.println(Arrays.toString(arr));
		
		//unboxing: 포장된 데이터를 다시 기본타입으로 변환
		//포장클래스가 제공하는 기본타입이름+value()메서드를 이용
		int i = val1.intValue();
		double j = val2.intValue();
		char k = val3.charValue();
		boolean x = val4.booleanValue();
		byte y = val5.byteValue();
		
		
		
	}
}



package api.lang.wrapper;

import java.util.Arrays;

public class AutoBoxing {
	
	
	public static void main(String[] args) {
		//AutoBoxing: 기본 타입 데이터를 자동으로 객체로 변환
		//자바10부터는 오토박싱기능만을 사용하도록 권고하고 있음
		int a = 100;
		Integer val1 = a;
		Double val2 = 3.1415;
		
		Object[] arr = {56,3.154, "안녕", 99,200.12};
		System.out.println(Arrays.toString(arr));
		
		
		int x = val1;
		double y = val2+5.3; // +연산자를만나면 val2를 언박싱한다음에 5.3과더함 
				//이건 다형성이아니라 그냥 연산자기능임
		//parsing: 문자열 데이터를 기본타입으로 변환
		String s1 = "10";
		String s2 = "5.43";
		
		int i = Integer.parseInt(s1);
		//과정이 우측의 s1을 먼저 integer에 있는 메소드 parseInt가 연산을통해 int로바꾼후
		//int값을 반환한다. 그리고 i가 받는다. 아마 객체를 생성한게아니니까 멤버변수에저장은
		//못할거임 
		double j = Double.parseDouble(s2);
		boolean k = Boolean.parseBoolean("true");
		
		System.out.println(i*j);
		
	}

}

################################################################################################










######################################################################################################
예제39) java.lang.math

아래 빈칸을 채워놓고 연습삼아 뚝딱뚝딱해봐라

1. abs(): 절대값을 구함.
2. ceil(): 올림값을 구함.
3. floor(): 내림값을 구함.
4. max(): 수를 비교하여 최대값을 구함.
5. min(): 수를 비교하여 최소값을 구함.
6. random(): 랜덤값을 구함(0.0 <= 값 < 1.0)
7. rint(): 현재 수(정수,실수)에서 가까운 정수를 실수형태로 구함. //정수인경우 그냥 .0붙여서 실수되는거고 실수의경우 자동 반올림됨
8. round(): 반올림값을 구함.
package java_.lang_.math;

public class MathExample {
	public static void main(String[] args) {
		
		System.out.println(Math.abs(-5));
		System.out.println(Math.ceil(5.34));
		System.out.println(Math.floor(5.34));
		System.out.println(Math.round(5.34));
		System.out.println(Math.max(1,2));
		System.out.println(Math.min(1,2));
		System.out.println(Math.random());
		System.out.println(Math.rint(23.42));
		
	}
}

######################################################################################################


답:

1. abs(): 절대값을 구함.
2. ceil(): 올림값을 구함.
3. floor(): 내림값을 구함.
4. max(): 수를 비교하여 최대값을 구함.
5. min(): 수를 비교하여 최소값을 구함.
6. random(): 랜덤값을 구함(0.0 <= 값 < 1.0)
7. rint(): 현재 수에서 가까운 정수를 실수형태로 구함.
8. round(): 반올림값을 구함.













######################################################################################################
예제40) java.lang.wrapper : 기본타입의 값을 갖는 객체를 포장객체라 한다.

1)아래 abcd를 하나의 배열에 담아라.
	-힌트: 박싱 
	-박싱끝나면 언박싱도 해라

package api.lang.wrapper;

public class Boxing {
	public static void main(String[] args) {
		int a = 100;
		double b = 3.51;
		char c = 'H';
		boolean d = false;
		
		
	}
}

package java_.lang_.wrapper;

public class WrapperExample {
	public static void main(String[] args) {
		int a = 100;
		double b = 3.51;
		char c = 'H';
		boolean d = false;
		
		Integer iA = new Integer(a);
		Double dB = new Double(b);
		Character cC = new Character(c);
		Boolean bD = new Boolean(d);
		Byte bB = new Byte((byte)3);
		String val = new String("hello");
		
		Object[] o = {iA, dB, cC, bD, bB, val};
		
		for(int i=0;i<o.length;i++) {
			System.out.println(o[i]);
		}
		
		
		
		
	}
}


######################################################################################################


답:




package api.lang.wrapper;

import java.util.Arrays;

public class Boxing {
	public static void main(String[] args) {
		int a = 100;
		double b = 3.51;
		char c = 'H';
		boolean d = false;
		
		//Boxing: 기본타입의 데이터를 객체타입으로 변환
		Integer val1 = new Integer(a);
		Double val2 = new Double(b);
		Character val3 = new Character(c);
		Boolean val4 = new Boolean(d);
		Byte val5 = new Byte((byte)75);
		String val6 = new String("hello");
		
		Object[] arr = {val1,val2,val3,val4,val5,val6};
		//object에 int,double,char,boolean을 다 정의해 놓았단 말인가?
		//그렇지않으면 val1은 object의 메서드와 변수는 쓸수있어도 본인의 변수는쓰지못한다.
		//이론상 object에 기본형타입으로 변수를 만들어놓았고 그녀석을 super를이용해서 자식객체
		//를 만들때 들어온 인자값을 부모클래스에게 보내서 부모클래스의 변수가 찼다고 보는게 맞는듯
		//그래서 객체 하나당 하나의 값밖에 가질수 없고 String은 내부에서 char를 많이 받을수있게
		//char형 배열을 만들어놓은것으로 추측됨
		
		System.out.println(Arrays.toString(arr));
		
		//unboxing: 포장된 데이터를 다시 기본타입으로 변환
		//포장클래스가 제공하는 기본타입이름+value()메서드를 이용
		int i = val1.intValue();
		double j = val2.intValue();
		char k = val3.charValue();
		boolean x = val4.booleanValue();
		byte y = val5.byteValue();
		
		
		
	}
}


















######################################################################################################
예제41) java.lang.wrapper 오토박싱언박싱

1)아래 abcd를 하나의 배열에 담아라.
	-힌트: 박싱 
	-박싱끝나면 언박싱도 해라






package api.lang.wrapper;

import java.util.Arrays;

public class AutoBoxing {
	
	
	public static void main(String[] args) {
		//AutoBoxing: 기본 타입 데이터를 자동으로 객체로 변환
		//자바10부터는 오토박싱기능만을 사용하도록 권고하고 있음
		int a = 100;
		
//자동박싱
//a를 자동박싱 변수이름 val1 뒤에거는다 1식추가

//3.1415를 자동박싱


//56, 3.14, "안녕", 99, 200.12를 하나의 배열로만들어라(오토박싱으로)		배열명 : arr


//자동언박싱		
//val1을 정수형 x에 언박싱하라
//박싱된 val2와 5.3을 더한 값을 y에 저장하라(원리를 이해해야함. 박싱된 val2의 값이 언박싱되어 반환된디 덧셈을하는거임

//parsing:문자열데이터를 변경가능한 데이터타입으로 변경 모든 래퍼클래스에 정적 메서드로 있음
//아래 박싱된 s1,s2를 문자열타입에서 본질에 맞는 타입으로 변경하라(정수,실수)(래퍼클래스를사용해야함)

		String s1 = "10";
		String s2 = "5.43";
		
//boolean k를 선언하고 "true"라는 const char*를 본질에 맞는 boolean 으로 변경하라
		
		
		System.out.println(i*j);
		
	}

}

package java_.lang_.wrapper;

public class Example2 {

	public static void main(String[] args) {
		//AutoBoxing: 기본 타입 데이터를 자동으로 객체로 변환
		//자바10부터는 오토박싱기능만을 사용하도록 권고하고 있음
		int a = 100;
		
//자동박싱
//a를 자동박싱 변수이름 val1 뒤에거는다 1식추가
		Integer val1 = a;
//3.1415를 자동박싱
		Double val2 = 3.1415;


//56, 3.14, "안녕", 99, 200.12를 하나의 배열로만들어라(오토박싱으로)		배열명 : arr
		Object[] arr = {56, 3.14, "안녕", 99, 200.12};
		
		for(int i=0;i<arr.length;i++) {
			System.out.println(arr[i]);
		}

//자동언박싱		
//val1을 정수형 x에 언박싱하라
//박싱된 val2와 5.3을 더한 값을 y에 저장하라(원리를 이해해야함. 박싱된 val2의 값이 언박싱되어 반환된디 덧셈을하는거임
		int x = val1;
		double y = val2 + 5.3;
		
		
//parsing:문자열데이터를 변경가능한 데이터타입으로 변경 모든 래퍼클래스에 정적 메서드로 있음
//아래 박싱된 s1,s2를 문자열타입에서 본질에 맞는 타입으로 변경하라(정수,실수)(래퍼클래스를사용해야함)
	
	
		String s1 = "10";
		String s2 = "5.43";
		Integer.parseInt(s1);
		Double.parseDouble(s2);
//boolean k를 선언하고 "true"라는 const char*를 본질에 맞는 boolean 으로 변경하라
		
		boolean k;
		k = Boolean.parseBoolean("true");
		
		
//		System.out.println(i*j);
		
	}

}



######################################################################################################








답:










package api.lang.wrapper;

import java.util.Arrays;

public class AutoBoxing {
	
	
	public static void main(String[] args) {
		//AutoBoxing: 기본 타입 데이터를 자동으로 객체로 변환
		//자바10부터는 오토박싱기능만을 사용하도록 권고하고 있음
		int a = 100;
		Integer val1 = a;
		Double val2 = 3.1415;
		
		Object[] arr = {56,3.154, "안녕", 99,200.12};
		System.out.println(Arrays.toString(arr));
		
		
		int x = val1;
		double y = val2+5.3; // +연산자를만나면 val2를 언박싱한다음에 5.3과더함 
				//이건 다형성이아니라 그냥 연산자기능임
		//parsing: 문자열 데이터를 기본타입으로 변환
		String s1 = "10";
		String s2 = "5.43";
		
		int i = Integer.parseInt(s1);
		//과정이 우측의 s1을 먼저 integer에 있는 메소드 parseInt가 연산을통해 int로바꾼후
		//int값을 반환한다. 그리고 i가 받는다. 아마 객체를 생성한게아니니까 멤버변수에저장은
		//못할거임 
		double j = Double.parseDouble(s2);
		boolean k = Boolean.parseBoolean("true");
		
		System.out.println(i*j);
		
	}

}

















