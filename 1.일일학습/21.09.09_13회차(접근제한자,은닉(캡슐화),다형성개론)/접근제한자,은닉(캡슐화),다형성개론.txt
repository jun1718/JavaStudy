21.09.08_13회차 0442~0554~0637
======================================================================================================
*접근제한자,은닉(캡슐화),다형성개론
======================================================================================================








######################################################################################################
개념정리_접근제한자

modifier		same class	same package	other package	other package
							& subclass(상속)	(universe)
public				o		o		o		o
package friendly		o		o		x		x
protected			o		o		o		x
	-p.f에서 class멤버생성자에대해 제한을걸었을때 해당하는것에대해 같은패키지가 아니면 지금 이것의 사용을 허락하지않겠다 라는뜻인데
		protected는 다른패키지 원칙적으로 안되는데 부모자식관계면 이해해주겠다 라는뜻으로 이해하면 됨.
private				o		x		x		x




* 접근 제한자(Access Modifier)

- 접근 제한자는 클래스와 멤버변수, 메서드, 생성자의 접근을 제어할 수 있는 제한자입니다.
- main() 메서드가 없는 클래스는 외부 클래스에서 이용할 목적으로 설계된 라이브러리 클래스입니다.
- 라이브러리 클래스를 설계할 때는 외부 클래스에서 접근할 수 있는 멤버와 접근할 수 없는 멤버로 구분해서 변수, 생성자, 메서드를 설계하는 것이 바람직합니다.
- 외부에서 객체 생성을 막기 위해 생성자를 호출하지 못하게 하거나 객체의 특정 데이터를 보호하기 위해 해당 멤버변수에  접근하지 못하도록 막는 것이 접근 제한자의 역할입니다.
- 클래스에는 접근 제한자를 public과 package friendly만 붙일 수 있습니다.
	-클래스에선 이거고 나머지 멤버변수 메서드 생성자는 다른것도가능
	
디폴트값: p.f

- 접근 제한자의 종류

1. public: 같은 클래스, 같은 패키지, 다른 패키지를 막론하고 접근이 가능.
1. protected: 같은 클래스, 같은 패키지는 접근이 가능하지만 다른 패키지에 속해있는 클래스인 경우 상속관계가 없으면 접근이 불가능.
1. package friendly(접근 제한자를 붙이지 않는 형태): 같은 클래스, 같은 패키지에서만 접근이 가능하며  패키지가 다를  경우 접근이  불가능.
1. private: 같은 클래스 내부가 아니면 접근이 불가능.


예시는 Day13의 아래 패키지들을 참고
클래스의 public, p.f 예시
	-modi.cls.pac1,2
	
생성자의 public, p.f, private 예시
	-modi.constructor.pac1,2

멤버의 public, p.f, private 예시
	-modi.member.pac1,2

protected에 대한 멤버, 생성자 적용 예시
	-modi.protec.pac1,2

######################################################################################################













######################################################################################################
개념정리_은닉

* 은닉(Encapsulation)

- 은닉은 사용자에게 상세한 내부 구현을 숨기고 필요한 부분만 보이게 하는 것입니다.
	-꽁꽁숨겨놓는 이 은닉을 캡슐화라 한다.
- 은닉을 사용하기 위해서는 클래스의 멤버변수의 접근제한자를 private으로 설정합니다.
- 은닉된 멤버변수에 접근하기 위해서는 공개된(public) 메서드를  통해서  접근할  수 있는데,  변수의  값을 변경시키는데 사용되는  메서드 는 setter메서드라고 부르며, 변수의 값을 얻어오는데 사용하는 메서드를 getter메서드라고 부릅니다.
- 이처럼 공개 메서드를 이용하여 데이터를 변경시킬 경우 메서드 내에 데이터 유효성을 검증할 수 있는 루틴을 넣을 수 있습니다.
- 뿐만 아니라 경우에 따라 접근 권한을 체크할 수 있는 로직을 포함시키면 인가되지 않은 사용자에게 중요한 데이터나 로직을 숨길 수 도 있고, 이를 제어할 수도 있습니다.
- 멤버변수만 private 제한자를 가지는 것은 아닙니다. 외부에 공개하고 싶지 않은 메서드들도 private으로 선언할 수 있습니다.

#setter/getter두는 이유
값의 유효성을 검증하기위해
위치를 왜 main에 안두는가?
	-> 추측) main에서 사용자가 입력하면 if로 처리할수도 있지만 그럼 모든 사용자가 사용하는 main코드에 중복코드가 발생하기도하고
	   main이 아닌 다른곳에서 사용하더라도 계속 적어야한다. 그래서 연관성이 있는 기능은 해당 클래스내에 넣는것이좋기때문에
		밖에서는아예 변수에 접근못하게하고 내부에서 값의 유효성검증을하고 저장하는 기능을가진 메서드를 만들어야하는것이다.

#참고: private로두고 생성자로만 값을 넣고싶은경우 setter/getter 안만들어도됨
#참고: 부모에서 은닉후 자식에서 제한자 정의할때 똑같거나 더 public하게 만들어야한다.

#참고: eclips 기능
	-생성자 자동생성 : alt shift S or 마우스 우클릭 source -> constructor
	-gettersetter만들기또한 동일경로
	-상속시 자식메서드에서 overriding 가능


######################################################################################################















######################################################################################################
개념정리_다형성

* 다형성(Polymorphism)

- 다형성이란 "객체가 여러 형태를 가진다"라는 의미로 해석되며, 하나의 객체가 여러가지 유형으로 사용되는 것을 의미합니다.
- 다형성은 상속을 전제조건으로 합니다.
- 다형성을 위해 자바는 자식클래스가 부모클래스의 타입을 가질 수 있도록 허용합니다. 즉, 부모 타입에 모든 자식객체가 대입될 수 있습니다.

- 객체의 교환성을 제고하기 위함이다.
- 상속을 전제로 서로의 타입을 교환하여 사용할수 있다.



package poly.basic;
/*
 * 하나의 클래스 파일안에 여러 클래스들을 선언할수 있다.
 * 단 파일명과 동일한 이름을 가진 클래스가 반드시 존재해야하며 해당 클래스만 public 제한자를 
 * 가질 수 있다.
 */

class A { 
//	int a;
//	public static void main(String[] args) {
//		Basic a = new Basic();
//		a.z = 4;
//	}
}
class B extends A {}
class C extends A {}
class D extends B {}
class E extends C {}


public class Basic {
//	private int z = 5;
	
	A a = new A();
	B b = new B();
	C c = new C();
	D d = new D();
	E e = new E();
//	public static void main(String[] args) {
//		A a = new A();
//		a.a = 4;
//	}

//	a.a = 4; 왜 접근을못할까? p.f일텐데 public으로 해도안되고 
	
	A a1 = b;	//자식객체가 부모객체로 자동 형변환되는것이다.
	A a2 = c;	//궁금: byte->int로 변경할때는 byte 크기가 작아서 자동형변환되는건데
			//부모객체는 코드양이나 멤버변수 등 메모리공간 자체가 더 작은데 왜 자동형변환되지?
	A a3 = new D();
	A a4 = e;
	
	Object o1 = new A();	//object는 모든 클래스의 부모이기때문에 모든 객체의 형변환
		//가능
	Object o2 = new String();
}



######################################################################################################
